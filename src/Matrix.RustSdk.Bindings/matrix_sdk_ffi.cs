// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.0+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable

using uniffi.matrix_sdk_base;
using uniffi.matrix_sdk_common;
using uniffi.matrix_sdk_crypto;
using uniffi.matrix_sdk_ui;
using uniffi.matrix_sdk;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace uniffi.matrix_sdk_ffi;

using FfiConverterTypeTimestamp = FfiConverterUInt64;
using Timestamp = UInt64;

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer
{
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size)
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                var buffer = _UniFFILib.ffi_matrix_sdk_ffi_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
                if (buffer.data == IntPtr.Zero)
                {
                    throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
                }
                return buffer;
            }
        );
    }

    public static void Free(RustBuffer buffer)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rustbuffer_free(buffer, ref status);
            }
        );
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len)));
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes
{
    public int length;
    public IntPtr data;
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType>
{
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value)
    {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try
        {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        }
        catch
        {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf)
    {
        var stream = rbuf.AsStream();
        try
        {
            var item = Read(stream);
            if (stream.HasRemaining())
            {
                throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
            }
            return item;
        }
        finally
        {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType> : FfiConverter<CsType, RustBuffer>
{
    public override CsType Lift(RustBuffer value)
    {
        return LiftFromRustBuffer(value);
    }

    public override RustBuffer Lower(CsType value)
    {
        return LowerIntoRustBuffer(value);
    }
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus
{
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess()
    {
        return code == 0;
    }

    public bool IsError()
    {
        return code == 1;
    }

    public bool IsPanic()
    {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException : System.Exception
{
    public UniffiException()
        : base() { }

    public UniffiException(string message)
        : base(message) { }
}

internal class UndeclaredErrorException : UniffiException
{
    public UndeclaredErrorException(string message)
        : base(message) { }
}

internal class PanicException : UniffiException
{
    public PanicException(string message)
        : base(message) { }
}

internal class AllocationException : UniffiException
{
    public AllocationException(string message)
        : base(message) { }
}

internal class InternalException : UniffiException
{
    public InternalException(string message)
        : base(message) { }
}

internal class InvalidEnumException : InternalException
{
    public InvalidEnumException(string message)
        : base(message) { }
}

internal class UniffiContractVersionException : UniffiException
{
    public UniffiContractVersionException(string message)
        : base(message) { }
}

internal class UniffiContractChecksumException : UniffiException
{
    public UniffiContractChecksumException(string message)
        : base(message) { }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E>
    where E : System.Exception
{
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
{
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf)
    {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers
{
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E : UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess())
        {
            return return_value;
        }
        else if (status.IsError())
        {
            throw errorHandler.Lift(status.error_buf);
        }
        else if (status.IsPanic())
        {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0)
            {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            }
            else
            {
                throw new PanicException("Rust panic");
            }
        }
        else
        {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E : UniffiException
    {
        _UniffiHelpers.RustCallWithError(
            errorHandler,
            (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback)
    {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }
}

static class FFIObjectUtil
{
    public static void DisposeAll(params Object?[] list)
    {
        foreach (var obj in list)
        {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj)
    {
        if (obj == null)
        {
            return;
        }

        if (obj is IDisposable disposable)
        {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null)
        {
            if (type.IsGenericType)
            {
                if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))
                {
                    foreach (var value in obj)
                    {
                        Dispose(value);
                    }
                }
                else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>)))
                {
                    foreach (var value in obj.Values)
                    {
                        Dispose(value);
                    }
                }
            }
        }
    }
}

// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException : System.Exception
{
    public StreamUnderflowException() { }
}

class BigEndianStream
{
    Stream stream;

    public BigEndianStream(Stream stream)
    {
        this.stream = stream;
    }

    public bool HasRemaining()
    {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position
    {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value)
    {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value)
    {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value)
    {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value)
    {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value)
    {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value)
    {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value)
    {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value)
    {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value)
    {
        unsafe
        {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value)
    {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value)
    {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length)
    {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte()
    {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort()
    {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt()
    {
        CheckRemaining(4);
        return (uint)(stream.ReadByte() << 24 | stream.ReadByte() << 16 | stream.ReadByte() << 8 | stream.ReadByte());
    }

    public ulong ReadULong()
    {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte()
    {
        return (sbyte)ReadByte();
    }

    public short ReadShort()
    {
        return (short)ReadUShort();
    }

    public int ReadInt()
    {
        return (int)ReadUInt();
    }

    public float ReadFloat()
    {
        unsafe
        {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong()
    {
        return (long)ReadULong();
    }

    public double ReadDouble()
    {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length)
    {
        if (stream.Length - stream.Position < length)
        {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.

// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(ulong @data, sbyte @pollResult);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(ulong @handle);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(ulong @handle);

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU8 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI8 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU16 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI16 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructF32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructF64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructPointer @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructVoid @result
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceBackupStateListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceBackupSteadyStateListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceClientDelegateMethod0(
        ulong @uniffiHandle,
        sbyte @isSoftLogout,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceClientDelegateMethod1(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceClientSessionDelegateMethod0(
        ulong @uniffiHandle,
        RustBuffer @userId,
        ref RustBuffer @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceClientSessionDelegateMethod1(
        ulong @uniffiHandle,
        RustBuffer @session,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @identityStatusChange,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceIgnoredUsersListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @ignoredUserIds,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceKnockRequestsListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @joinRequests,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceLiveLocationShareListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @liveLocationShares,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceNotificationSettingsDelegateMethod0(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfacePaginationStatusListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceProgressWatcherMethod0(
        ulong @uniffiHandle,
        RustBuffer @progress,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceQrLoginProgressListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRecoveryStateListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @roomEntriesUpdate,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRoomInfoListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @roomInfo,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRoomListEntriesListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @roomEntriesUpdate,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRoomListServiceStateListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @syncIndicator,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @roomId,
        RustBuffer @error,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0(
        ulong @uniffiHandle,
        RustBuffer @details,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3(
        ulong @uniffiHandle,
        RustBuffer @data,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncServiceStateObserverMethod0(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTimelineListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @diff,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTypingNotificationsListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @typingUserIds,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceUnableToDecryptDelegateMethod0(
        ulong @uniffiHandle,
        RustBuffer @info,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceVerificationStateListenerMethod0(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0(
        ulong @uniffiHandle,
        RustBuffer @capabilities,
        ref RustBuffer @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceBackupStateListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceBackupSteadyStateListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceClientDelegate
    {
        public IntPtr @didReceiveAuthError;
        public IntPtr @didRefreshTokens;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceClientSessionDelegate
    {
        public IntPtr @retrieveSessionFromKeychain;
        public IntPtr @saveSessionInKeychain;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceEnableRecoveryProgressListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceIdentityStatusChangeListener
    {
        public IntPtr @call;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceIgnoredUsersListener
    {
        public IntPtr @call;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceKnockRequestsListener
    {
        public IntPtr @call;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceLiveLocationShareListener
    {
        public IntPtr @call;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceNotificationSettingsDelegate
    {
        public IntPtr @settingsDidChange;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfacePaginationStatusListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceProgressWatcher
    {
        public IntPtr @transmissionProgress;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceQrLoginProgressListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRecoveryStateListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRoomInfoListener
    {
        public IntPtr @call;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRoomListEntriesListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRoomListLoadingStateListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRoomListServiceStateListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceSendQueueRoomErrorListener
    {
        public IntPtr @onError;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate
    {
        public IntPtr @didReceiveVerificationRequest;
        public IntPtr @didAcceptVerificationRequest;
        public IntPtr @didStartSasVerification;
        public IntPtr @didReceiveVerificationData;
        public IntPtr @didFail;
        public IntPtr @didCancel;
        public IntPtr @didFinish;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceSyncServiceStateObserver
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceTimelineListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceTypingNotificationsListener
    {
        public IntPtr @call;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceUnableToDecryptDelegate
    {
        public IntPtr @onUtd;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceVerificationStateListener
    {
        public IntPtr @onUpdate;
        public IntPtr @uniffiFree;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider
    {
        public IntPtr @acquireCapabilities;
        public IntPtr @uniffiFree;
    }

    static _UniFFILib()
    {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();

        UniffiCallbackInterfaceBackupStateListener.Register();
        UniffiCallbackInterfaceBackupSteadyStateListener.Register();
        UniffiCallbackInterfaceClientDelegate.Register();
        UniffiCallbackInterfaceClientSessionDelegate.Register();
        UniffiCallbackInterfaceEnableRecoveryProgressListener.Register();
        UniffiCallbackInterfaceIdentityStatusChangeListener.Register();
        UniffiCallbackInterfaceIgnoredUsersListener.Register();
        UniffiCallbackInterfaceKnockRequestsListener.Register();
        UniffiCallbackInterfaceLiveLocationShareListener.Register();
        UniffiCallbackInterfaceNotificationSettingsDelegate.Register();
        UniffiCallbackInterfacePaginationStatusListener.Register();
        UniffiCallbackInterfaceProgressWatcher.Register();
        UniffiCallbackInterfaceQrLoginProgressListener.Register();
        UniffiCallbackInterfaceRecoveryStateListener.Register();
        UniffiCallbackInterfaceRoomDirectorySearchEntriesListener.Register();
        UniffiCallbackInterfaceRoomInfoListener.Register();
        UniffiCallbackInterfaceRoomListEntriesListener.Register();
        UniffiCallbackInterfaceRoomListLoadingStateListener.Register();
        UniffiCallbackInterfaceRoomListServiceStateListener.Register();
        UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.Register();
        UniffiCallbackInterfaceSendQueueRoomErrorListener.Register();
        UniffiCallbackInterfaceSessionVerificationControllerDelegate.Register();
        UniffiCallbackInterfaceSyncServiceStateObserver.Register();
        UniffiCallbackInterfaceTimelineListener.Register();
        UniffiCallbackInterfaceTypingNotificationsListener.Register();
        UniffiCallbackInterfaceUnableToDecryptDelegate.Register();
        UniffiCallbackInterfaceVerificationStateListener.Register();
        UniffiCallbackInterfaceWidgetCapabilitiesProvider.Register();
    }

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
        IntPtr @ptr,
        RustBuffer @mentions,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_client(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_client(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
        IntPtr @ptr,
        IntPtr @authorizationData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_account_data(IntPtr @ptr, RustBuffer @eventType);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_account_url(IntPtr @ptr, RustBuffer @action);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
        IntPtr @ptr,
        RustBuffer @roomId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_create_room(IntPtr @ptr, RustBuffer @request);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
        IntPtr @ptr,
        RustBuffer @jwt,
        RustBuffer @initialDeviceName,
        RustBuffer @deviceId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
        IntPtr @ptr,
        RustBuffer @authData,
        sbyte @eraseData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
        IntPtr @ptr,
        RustBuffer @identifiers
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_device_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_display_name(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
        IntPtr @ptr,
        sbyte @enable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_encryption(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
        IntPtr @ptr,
        RustBuffer @userId,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
        IntPtr @ptr,
        IntPtr @mediaSource
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
        IntPtr @ptr,
        IntPtr @mediaSource,
        RustBuffer @filename,
        RustBuffer @mimeType,
        sbyte @useCache,
        RustBuffer @tempDir
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
        IntPtr @ptr,
        IntPtr @mediaSource,
        ulong @width,
        ulong @height
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_profile(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_get_room(
        IntPtr @ptr,
        RustBuffer @roomId,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
        IntPtr @ptr,
        RustBuffer @roomAlias
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
        IntPtr @ptr,
        RustBuffer @roomId,
        RustBuffer @viaServers
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_get_url(IntPtr @ptr, RustBuffer @url);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
        IntPtr @ptr,
        RustBuffer @alias
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(IntPtr @ptr, RustBuffer @roomId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
        IntPtr @ptr,
        RustBuffer @roomIdOrAlias,
        RustBuffer @serverNames
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_knock(
        IntPtr @ptr,
        RustBuffer @roomIdOrAlias,
        RustBuffer @reason,
        RustBuffer @serverNames
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_login(
        IntPtr @ptr,
        RustBuffer @username,
        RustBuffer @password,
        RustBuffer @initialDeviceName,
        RustBuffer @deviceId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
        IntPtr @ptr,
        RustBuffer @email,
        RustBuffer @password,
        RustBuffer @initialDeviceName,
        RustBuffer @deviceId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
        IntPtr @ptr,
        RustBuffer @callbackUrl
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_logout(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
        IntPtr @ptr,
        RustBuffer @processSetup
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_reset_server_capabilities(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
        IntPtr @ptr,
        RustBuffer @roomAlias
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
        IntPtr @ptr,
        RustBuffer @session
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(
        IntPtr @ptr,
        RustBuffer @session,
        RustBuffer @roomLoadSettings
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
        IntPtr @ptr,
        RustBuffer @roomAlias
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_rooms(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_search_users(
        IntPtr @ptr,
        RustBuffer @searchTerm,
        ulong @limit
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_server(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_session(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
        IntPtr @ptr,
        RustBuffer @eventType,
        RustBuffer @content
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
        IntPtr @ptr,
        RustBuffer @delegate,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(IntPtr @ptr, RustBuffer @name);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(
        IntPtr @ptr,
        RustBuffer @policy
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
        IntPtr @ptr,
        RustBuffer @identifiers,
        RustBuffer @kind,
        RustBuffer @appDisplayName,
        RustBuffer @deviceDisplayName,
        RustBuffer @profileTag,
        RustBuffer @lang
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
        IntPtr @ptr,
        RustBuffer @redirectUrl,
        RustBuffer @idpId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
        IntPtr @ptr,
        RustBuffer @room
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
        IntPtr @ptr,
        RustBuffer @mimeType,
        RustBuffer @data
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
        IntPtr @ptr,
        RustBuffer @mimeType,
        RustBuffer @data,
        RustBuffer @progressWatcher
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
        IntPtr @ptr,
        RustBuffer @oidcConfiguration,
        RustBuffer @prompt
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_user_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_clientbuilder(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
        IntPtr @ptr,
        RustBuffer @certificates,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
        IntPtr @ptr,
        sbyte @autoEnableBackups,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
        IntPtr @ptr,
        sbyte @autoEnableCrossSigning,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
        IntPtr @ptr,
        RustBuffer @backupDownloadStrategy,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build_with_qr_code(
        IntPtr @ptr,
        IntPtr @qrCodeData,
        RustBuffer @oidcConfiguration,
        ulong @progressListener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
        IntPtr @ptr,
        RustBuffer @holderName,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
        IntPtr @ptr,
        RustBuffer @url,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
        IntPtr @ptr,
        RustBuffer @url,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
        IntPtr @ptr,
        RustBuffer @config,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_decryption_trust_requirement(
        IntPtr @ptr,
        RustBuffer @trustRequirement,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
        IntPtr @ptr,
        RustBuffer @strategy,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
        IntPtr @ptr,
        RustBuffer @serverName,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
        IntPtr @ptr,
        RustBuffer @serverNameOrUrl,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_cache_size(
        IntPtr @ptr,
        RustBuffer @cacheSize,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_journal_size_limit(
        IntPtr @ptr,
        RustBuffer @limit,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_passphrase(
        IntPtr @ptr,
        RustBuffer @passphrase,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
        IntPtr @ptr,
        RustBuffer @dataPath,
        RustBuffer @cachePath,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_pool_max_size(
        IntPtr @ptr,
        RustBuffer @poolMaxSize,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
        IntPtr @ptr,
        ulong @sessionDelegate,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
        IntPtr @ptr,
        RustBuffer @versionBuilder,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_use_event_cache_persistent_storage(
        IntPtr @ptr,
        sbyte @value,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
        IntPtr @ptr,
        RustBuffer @userAgent,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
        IntPtr @ptr,
        RustBuffer @username,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_encryption(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_encryption(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
        IntPtr @ptr,
        sbyte @waitForBackupsToUpload,
        RustBuffer @passphrase,
        ulong @progressListener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
        IntPtr @ptr,
        RustBuffer @recoveryKey
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
        IntPtr @ptr,
        RustBuffer @oldRecoveryKey
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
        IntPtr @ptr,
        RustBuffer @progressListener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_identityresethandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
        IntPtr @ptr,
        RustBuffer @auth
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
        IntPtr @ptr,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
        IntPtr @ptr,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
        IntPtr @ptr,
        sbyte @strict,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
        IntPtr @ptr,
        RustBuffer @path,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_mediasource(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_mediasource(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
        RustBuffer @json,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
        RustBuffer @url,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_notificationclient(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_notificationclient(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
        IntPtr @ptr,
        RustBuffer @roomId,
        RustBuffer @eventId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_notificationsettings(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
        IntPtr @ptr,
        sbyte @isEncrypted,
        sbyte @isOneToOne
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
        IntPtr @ptr,
        RustBuffer @roomId,
        sbyte @isEncrypted,
        sbyte @isOneToOne
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
        IntPtr @ptr,
        RustBuffer @enabled
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
        IntPtr @ptr,
        RustBuffer @roomId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
        IntPtr @ptr,
        RustBuffer @roomId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
        IntPtr @ptr,
        sbyte @enabled
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(
        IntPtr @ptr,
        RustBuffer @ruleId,
        RustBuffer @ruleKind,
        RustBuffer @actions,
        RustBuffer @conditions
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
        IntPtr @ptr,
        sbyte @isEncrypted,
        sbyte @isOneToOne,
        RustBuffer @mode
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
        IntPtr @ptr,
        RustBuffer @delegate,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
        IntPtr @ptr,
        sbyte @enabled
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
        IntPtr @ptr,
        sbyte @enabled
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
        IntPtr @ptr,
        RustBuffer @roomId,
        RustBuffer @mode
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
        IntPtr @ptr,
        sbyte @enabled
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
        IntPtr @ptr,
        RustBuffer @roomId,
        sbyte @isEncrypted,
        sbyte @isOneToOne
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_qrcodedata(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
        RustBuffer @bytes,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_room(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_room(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
        IntPtr @ptr,
        RustBuffer @changes
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
        IntPtr @ptr,
        RustBuffer @userId,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_pin_unpin(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
        IntPtr @ptr,
        RustBuffer @userId,
        RustBuffer @message
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
        IntPtr @ptr,
        RustBuffer @userId,
        RustBuffer @stateEvent
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_display_name(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_edit(
        IntPtr @ptr,
        RustBuffer @eventId,
        IntPtr @newContent
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
        IntPtr @ptr,
        sbyte @enable,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_forget(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_heroes(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
        IntPtr @ptr,
        RustBuffer @devices,
        IntPtr @sendHandle
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_is_direct(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_room_is_public(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_room_is_space(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_join(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
        IntPtr @ptr,
        RustBuffer @userId,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_leave(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(IntPtr @ptr, RustBuffer @receiptType);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
        IntPtr @ptr,
        RustBuffer @eventId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_member(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(IntPtr @ptr, RustBuffer @userId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_members(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_membership(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(
        IntPtr @ptr,
        RustBuffer @alias
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_redact(
        IntPtr @ptr,
        RustBuffer @eventId,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(
        IntPtr @ptr,
        RustBuffer @alias
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_report_content(
        IntPtr @ptr,
        RustBuffer @eventId,
        RustBuffer @score,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_report_room(IntPtr @ptr, RustBuffer @reason);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_room_info(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
        IntPtr @ptr,
        RustBuffer @draft
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
        IntPtr @ptr,
        RustBuffer @callId,
        RustBuffer @application,
        RustBuffer @notifyType,
        RustBuffer @mentions
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(
        IntPtr @ptr,
        RustBuffer @geoUri
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
        IntPtr @ptr,
        RustBuffer @eventType,
        RustBuffer @content
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
        IntPtr @ptr,
        sbyte @isFavourite,
        RustBuffer @tagOrder
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
        IntPtr @ptr,
        sbyte @isLowPriority,
        RustBuffer @tagOrder
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_set_name(IntPtr @ptr, RustBuffer @name);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_set_topic(IntPtr @ptr, RustBuffer @topic);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(IntPtr @ptr, sbyte @newValue);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(
        IntPtr @ptr,
        ulong @durationMillis
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
        IntPtr @ptr,
        ulong @listener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
        IntPtr @ptr,
        ulong @listener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_timeline(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(
        IntPtr @ptr,
        RustBuffer @configuration
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_room_topic(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(IntPtr @ptr, sbyte @isTyping);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
        IntPtr @ptr,
        RustBuffer @userId,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(
        IntPtr @ptr,
        RustBuffer @alias,
        RustBuffer @altAliases
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(
        IntPtr @ptr,
        RustBuffer @visibility
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(
        IntPtr @ptr,
        RustBuffer @newRule
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
        IntPtr @ptr,
        RustBuffer @updates
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(
        IntPtr @ptr,
        RustBuffer @visibility
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
        IntPtr @ptr,
        RustBuffer @mimeType,
        RustBuffer @data,
        RustBuffer @mediaInfo
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
        IntPtr @ptr,
        RustBuffer @userIds,
        IntPtr @sendHandle
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
        IntPtr @ptr,
        ulong @listener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
        IntPtr @ptr,
        RustBuffer @filter,
        uint @batchSize,
        RustBuffer @viaServerName
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roomlist(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roomlist(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
        IntPtr @ptr,
        uint @pageSize,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
        IntPtr @ptr,
        RustBuffer @roomId,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
        IntPtr @ptr,
        RustBuffer @kind,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roomlistitem(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roomlistitem(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roomlistitem_avatar_url(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roomlistitem_canonical_alias(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roomlistitem_display_name(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_full_room(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roomlistitem_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_init_timeline(
        IntPtr @ptr,
        RustBuffer @eventTypeFilter,
        RustBuffer @internalIdPrefix
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_direct(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_encrypted(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_timeline_initialized(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_latest_event(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roomlistitem_membership(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_preview_room(IntPtr @ptr, RustBuffer @via);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistitem_room_info(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roomlistservice(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
        IntPtr @ptr,
        RustBuffer @roomId,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
        IntPtr @ptr,
        RustBuffer @roomIds,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
        IntPtr @ptr,
        uint @delayBeforeShowingInMs,
        uint @delayBeforeHidingInMs,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
        IntPtr @ptr,
        uint @chunkSize,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_roompreview(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_roompreview(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_roompreview_info(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_sendhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_sendhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
        IntPtr @ptr,
        RustBuffer @senderId,
        RustBuffer @flowId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(
        IntPtr @ptr,
        RustBuffer @userId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
        IntPtr @ptr,
        RustBuffer @delegate,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
        IntPtr @ptr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_span(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_span(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_span_current(
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        RustBuffer @file,
        RustBuffer @line,
        RustBuffer @level,
        RustBuffer @target,
        RustBuffer @name,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_span_enter(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_span_exit(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_span_is_none(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_ssohandler(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_ssohandler(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(IntPtr @ptr, RustBuffer @callbackUrl);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_syncservice(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_syncservice(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservice_start(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
        IntPtr @ptr,
        ulong @listener,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_utd_hook(
        IntPtr @ptr,
        ulong @delegate
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_taskhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_taskhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_timeline(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_timeline(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(IntPtr @ptr, ulong @listener);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
        IntPtr @ptr,
        RustBuffer @msgType,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
        IntPtr @ptr,
        RustBuffer @question,
        RustBuffer @answers,
        byte @maxSelections,
        RustBuffer @pollKind
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
        IntPtr @ptr,
        RustBuffer @eventOrTransactionId,
        RustBuffer @newContent
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
        IntPtr @ptr,
        RustBuffer @pollStartEventId,
        RustBuffer @text
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
        IntPtr @ptr,
        RustBuffer @eventId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
        IntPtr @ptr,
        RustBuffer @eventId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
        IntPtr @ptr,
        RustBuffer @eventIdStr
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
        IntPtr @ptr,
        RustBuffer @receiptType
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
        IntPtr @ptr,
        ushort @numEvents
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(
        IntPtr @ptr,
        ushort @numEvents
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(IntPtr @ptr, RustBuffer @eventId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
        IntPtr @ptr,
        RustBuffer @eventOrTransactionId,
        RustBuffer @reason
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
        IntPtr @ptr,
        RustBuffer @sessionIds,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send(IntPtr @ptr, IntPtr @msg);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
        IntPtr @ptr,
        RustBuffer @params,
        RustBuffer @audioInfo,
        RustBuffer @progressWatcher,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
        IntPtr @ptr,
        RustBuffer @params,
        RustBuffer @fileInfo,
        RustBuffer @progressWatcher,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
        IntPtr @ptr,
        RustBuffer @params,
        RustBuffer @thumbnailPath,
        RustBuffer @imageInfo,
        RustBuffer @progressWatcher,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
        IntPtr @ptr,
        RustBuffer @body,
        RustBuffer @geoUri,
        RustBuffer @description,
        RustBuffer @zoomLevel,
        RustBuffer @assetType
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
        IntPtr @ptr,
        RustBuffer @pollStartEventId,
        RustBuffer @answers
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
        IntPtr @ptr,
        RustBuffer @receiptType,
        RustBuffer @eventId
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
        IntPtr @ptr,
        IntPtr @msg,
        RustBuffer @replyParams
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
        IntPtr @ptr,
        RustBuffer @params,
        RustBuffer @thumbnailPath,
        RustBuffer @videoInfo,
        RustBuffer @progressWatcher,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
        IntPtr @ptr,
        RustBuffer @params,
        RustBuffer @audioInfo,
        RustBuffer @waveform,
        RustBuffer @progressWatcher,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
        IntPtr @ptr,
        ulong @listener
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
        IntPtr @ptr,
        RustBuffer @itemId,
        RustBuffer @key
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(IntPtr @ptr, RustBuffer @eventId);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_timelinediff(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_timelinediff(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelinediff_truncate(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_timelineevent(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_timelineevent(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
        RustBuffer @eventTypes,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
        RustBuffer @eventTypes,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_timelineitem(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_timelineitem(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_useridentity(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_useridentity(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_widgetdriver(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
        IntPtr @ptr,
        IntPtr @room,
        ulong @capabilitiesProvider
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(
        IntPtr @ptr,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(IntPtr @ptr);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(IntPtr @ptr, RustBuffer @msg);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceBackupStateListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceBackupSteadyStateListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(
        ref _UniFFILib.UniffiVTableCallbackInterfaceClientDelegate @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(
        ref _UniFFILib.UniffiVTableCallbackInterfaceClientSessionDelegate @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceEnableRecoveryProgressListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceIdentityStatusChangeListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceIgnoredUsersListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceKnockRequestsListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceLiveLocationShareListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(
        ref _UniFFILib.UniffiVTableCallbackInterfaceNotificationSettingsDelegate @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfacePaginationStatusListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(
        ref _UniFFILib.UniffiVTableCallbackInterfaceProgressWatcher @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceQrLoginProgressListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRecoveryStateListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRoomInfoListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRoomListEntriesListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRoomListLoadingStateListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRoomListServiceStateListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceSendQueueRoomErrorListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(
        ref _UniFFILib.UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(
        ref _UniFFILib.UniffiVTableCallbackInterfaceSyncServiceStateObserver @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceTimelineListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceTypingNotificationsListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(
        ref _UniFFILib.UniffiVTableCallbackInterfaceUnableToDecryptDelegate @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(
        ref _UniFFILib.UniffiVTableCallbackInterfaceVerificationStateListener @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(
        ref _UniFFILib.UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider @vtable
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
        RustBuffer @message,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
        RustBuffer @caption,
        RustBuffer @formattedCaption,
        RustBuffer @mentions,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(
        RustBuffer @widgetSettings,
        IntPtr @room,
        RustBuffer @props
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
        RustBuffer @ownUserId,
        RustBuffer @ownDeviceId,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_func_init_platform(
        RustBuffer @config,
        sbyte @useLightweightTokioRuntime,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
        RustBuffer @alias,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_matrix_sdk_ffi_fn_func_log_event(
        RustBuffer @file,
        RustBuffer @line,
        RustBuffer @level,
        RustBuffer @target,
        RustBuffer @message,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_make_element_well_known(
        RustBuffer @string,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
        RustBuffer @settings,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
        RustBuffer @roomAlias,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
        RustBuffer @userId,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
        RustBuffer @body,
        RustBuffer @htmlBody,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
        RustBuffer @body,
        RustBuffer @htmlBody,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        RustBuffer @md,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
        RustBuffer @md,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
        RustBuffer @msgtype,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
        RustBuffer @props,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
        RustBuffer @uri,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
        RustBuffer @roomName,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(ref UniffiRustCallStatus _uniffi_out_err);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern long uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
        RustBuffer @role,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
        long @powerLevel,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_ffi_rustbuffer_alloc(
        ulong @size,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_ffi_rustbuffer_from_bytes(
        ForeignBytes @bytes,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rustbuffer_free(
        RustBuffer @buf,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_ffi_rustbuffer_reserve(
        RustBuffer @buf,
        ulong @additional,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_u8(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_u8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_u8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_matrix_sdk_ffi_rust_future_complete_u8(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_i8(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_i8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_i8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_matrix_sdk_ffi_rust_future_complete_i8(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_u16(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_u16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_u16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_matrix_sdk_ffi_rust_future_complete_u16(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_i16(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_i16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_i16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_matrix_sdk_ffi_rust_future_complete_i16(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_u32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_u32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_u32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_matrix_sdk_ffi_rust_future_complete_u32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_i32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_i32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_i32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_matrix_sdk_ffi_rust_future_complete_i32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_u64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_u64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_u64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_matrix_sdk_ffi_rust_future_complete_u64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_i64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_i64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_i64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_matrix_sdk_ffi_rust_future_complete_i64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_f32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_f32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_f32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_matrix_sdk_ffi_rust_future_complete_f32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_f64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_f64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_f64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_matrix_sdk_ffi_rust_future_complete_f64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_pointer(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_pointer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_pointer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_matrix_sdk_ffi_rust_future_complete_pointer(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_poll_void(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_cancel_void(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_free_void(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_ffi_rust_future_complete_void(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_init_platform();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_log_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_account_data();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_account_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_create_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_device_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_display_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_encryption();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_profile();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_get_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_homeserver();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_knock();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_login();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_logout();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_notification_client();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_restore_session();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_rooms();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_search_users();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_server();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_session();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_sync_service();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_upload_media();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_user_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_use_event_cache_persistent_storage();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_recover();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_mediasource_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_ban_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_display_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_edit();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_forget();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_heroes();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_is_direct();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_is_public();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_is_space();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_join();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_kick_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_leave();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_member();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_members();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_membership();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_raw_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_redact();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_report_content();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_report_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_room_info();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_send_raw();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_set_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_set_topic();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_timeline();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_topic();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_unban_user();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlist_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_display_name();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_init_timeline();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_encrypted();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_timeline_initialized();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_membership();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_preview_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roompreview_info();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_span_enter();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_span_exit();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_span_is_none();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservice_start();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservice_state();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_utd_hook();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_edit();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_span_current();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_span_new();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities();

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_matrix_sdk_ffi_uniffi_contract_version();

    static void uniffiCheckContractApiVersion()
    {
        var scaffolding_contract_version = _UniFFILib.ffi_matrix_sdk_ffi_uniffi_contract_version();
        if (26 != scaffolding_contract_version)
        {
            throw new UniffiContractVersionException(
                $"uniffi.matrix_sdk_ffi: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`"
            );
        }
    }

    static void uniffiCheckApiChecksums()
    {
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message();
            if (checksum != 1366)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message` checksum `1366`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit();
            if (checksum != 33992)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit` checksum `33992`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id();
            if (checksum != 15808)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id` checksum `15808`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url();
            if (checksum != 6844)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url` checksum `6844`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions();
            if (checksum != 30181)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions` checksum `30181`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_init_platform();
            if (checksum != 35062)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_init_platform` checksum `35062`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid();
            if (checksum != 54845)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid` checksum `54845`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_log_event();
            if (checksum != 62286)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_log_event` checksum `62286`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known();
            if (checksum != 21379)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known` checksum `21379`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver();
            if (checksum != 34206)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver` checksum `34206`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink();
            if (checksum != 13776)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink` checksum `13776`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink();
            if (checksum != 46473)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink` checksum `46473`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html();
            if (checksum != 37203)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html` checksum `37203`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote();
            if (checksum != 8938)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote` checksum `8938`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown();
            if (checksum != 58385)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown` checksum `58385`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote();
            if (checksum != 20152)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote` checksum `20152`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new();
            if (checksum != 57839)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new` checksum `57839`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget();
            if (checksum != 4988)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget` checksum `4988`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from();
            if (checksum != 49710)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from` checksum `49710`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name();
            if (checksum != 65010)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name` checksum `65010`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha();
            if (checksum != 4038)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha` checksum `4038`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role();
            if (checksum != 61777)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role` checksum `61777`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level();
            if (checksum != 48532)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level` checksum `48532`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions();
            if (checksum != 8867)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions` checksum `8867`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth();
            if (checksum != 53440)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth` checksum `53440`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_account_data();
            if (checksum != 50433)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_account_data` checksum `50433`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_account_url();
            if (checksum != 42373)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_account_url` checksum `42373`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions();
            if (checksum != 35296)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions` checksum `35296`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url();
            if (checksum != 27867)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url` checksum `27867`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo();
            if (checksum != 18126)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo` checksum `18126`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url();
            if (checksum != 50226)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url` checksum `50226`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account();
            if (checksum != 39890)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account` checksum `39890`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches();
            if (checksum != 47085)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches` checksum `47085`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_create_room();
            if (checksum != 52700)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_create_room` checksum `52700`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt();
            if (checksum != 19710)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt` checksum `19710`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account();
            if (checksum != 20658)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account` checksum `20658`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher();
            if (checksum != 45990)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher` checksum `45990`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_device_id();
            if (checksum != 44340)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_device_id` checksum `44340`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_display_name();
            if (checksum != 56259)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_display_name` checksum `56259`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues();
            if (checksum != 30834)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues` checksum `30834`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_encryption();
            if (checksum != 9657)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_encryption` checksum `9657`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room();
            if (checksum != 5137)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room` checksum `5137`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content();
            if (checksum != 40308)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content` checksum `40308`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file();
            if (checksum != 52604)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file` checksum `52604`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail();
            if (checksum != 52601)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail` checksum `52601`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings();
            if (checksum != 49769)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings` checksum `49769`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_profile();
            if (checksum != 60062)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_profile` checksum `60062`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms();
            if (checksum != 22399)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms` checksum `22399`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_room();
            if (checksum != 30376)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_room` checksum `30376`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias();
            if (checksum != 7674)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias` checksum `7674`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id();
            if (checksum != 36348)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id` checksum `36348`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller();
            if (checksum != 55934)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller` checksum `55934`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_get_url();
            if (checksum != 50489)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_get_url` checksum `50489`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_homeserver();
            if (checksum != 26427)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_homeserver` checksum `26427`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details();
            if (checksum != 63487)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details` checksum `63487`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user();
            if (checksum != 14588)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user` checksum `14588`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users();
            if (checksum != 49620)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users` checksum `49620`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available();
            if (checksum != 23322)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available` checksum `23322`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id();
            if (checksum != 64032)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id` checksum `64032`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias();
            if (checksum != 18521)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias` checksum `18521`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_knock();
            if (checksum != 48652)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_knock` checksum `48652`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_login();
            if (checksum != 33276)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_login` checksum `33276`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email();
            if (checksum != 11789)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email` checksum `11789`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback();
            if (checksum != 32591)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback` checksum `32591`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_logout();
            if (checksum != 42911)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_logout` checksum `42911`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_notification_client();
            if (checksum != 37308)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_notification_client` checksum `37308`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar();
            if (checksum != 29033)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar` checksum `29033`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities();
            if (checksum != 39651)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities` checksum `39651`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias();
            if (checksum != 3551)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias` checksum `3551`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_restore_session();
            if (checksum != 56125)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_restore_session` checksum `56125`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with();
            if (checksum != 20927)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with` checksum `20927`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists();
            if (checksum != 20359)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists` checksum `20359`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search();
            if (checksum != 39855)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search` checksum `39855`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_rooms();
            if (checksum != 29558)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_rooms` checksum `29558`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_search_users();
            if (checksum != 42927)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_search_users` checksum `42927`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_server();
            if (checksum != 63276)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_server` checksum `63276`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_session();
            if (checksum != 8085)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_session` checksum `8085`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data();
            if (checksum != 18256)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data` checksum `18256`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate();
            if (checksum != 59796)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate` checksum `59796`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name();
            if (checksum != 15292)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name` checksum `15292`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy();
            if (checksum != 2414)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy` checksum `2414`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher();
            if (checksum != 41975)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher` checksum `41975`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version();
            if (checksum != 4957)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version` checksum `4957`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login();
            if (checksum != 34571)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login` checksum `34571`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users();
            if (checksum != 23285)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users` checksum `23285`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status();
            if (checksum != 57403)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status` checksum `57403`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_sync_service();
            if (checksum != 52812)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_sync_service` checksum `52812`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room();
            if (checksum != 56986)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room` checksum `56986`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user();
            if (checksum != 8489)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user` checksum `8489`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar();
            if (checksum != 64486)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar` checksum `64486`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_upload_media();
            if (checksum != 51195)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_upload_media` checksum `51195`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc();
            if (checksum != 35004)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc` checksum `35004`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_user_id();
            if (checksum != 40531)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_user_id` checksum `40531`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name();
            if (checksum != 57725)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name` checksum `57725`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates();
            if (checksum != 14763)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates` checksum `14763`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups();
            if (checksum != 44502)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups` checksum `44502`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing();
            if (checksum != 37167)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing` checksum `37167`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy();
            if (checksum != 11959)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy` checksum `11959`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build();
            if (checksum != 56018)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build` checksum `56018`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code();
            if (checksum != 42452)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code` checksum `42452`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name();
            if (checksum != 46627)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name` checksum `46627`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh();
            if (checksum != 43839)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh` checksum `43839`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates();
            if (checksum != 47525)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates` checksum `47525`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification();
            if (checksum != 2334)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification` checksum `2334`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock();
            if (checksum != 42214)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock` checksum `42214`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url();
            if (checksum != 28347)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url` checksum `28347`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy();
            if (checksum != 5659)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy` checksum `5659`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config();
            if (checksum != 58783)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config` checksum `58783`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement();
            if (checksum != 2776)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement` checksum `2776`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy();
            if (checksum != 41183)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy` checksum `41183`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name();
            if (checksum != 29096)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name` checksum `29096`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url();
            if (checksum != 30022)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url` checksum `30022`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size();
            if (checksum != 32604)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size` checksum `32604`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit();
            if (checksum != 21378)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit` checksum `21378`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase();
            if (checksum != 55403)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase` checksum `55403`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths();
            if (checksum != 54230)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths` checksum `54230`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size();
            if (checksum != 6011)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size` checksum `6011`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate();
            if (checksum != 8576)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate` checksum `8576`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder();
            if (checksum != 39381)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder` checksum `39381`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained();
            if (checksum != 6898)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained` checksum `6898`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_use_event_cache_persistent_storage();
            if (checksum != 58836)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_use_event_cache_persistent_storage` checksum `58836`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent();
            if (checksum != 13719)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent` checksum `13719`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username();
            if (checksum != 45302)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username` checksum `45302`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server();
            if (checksum != 45490)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server` checksum `45490`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state();
            if (checksum != 51049)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state` checksum `51049`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener();
            if (checksum != 14246)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener` checksum `14246`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key();
            if (checksum != 58425)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key` checksum `58425`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery();
            if (checksum != 18699)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery` checksum `18699`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key();
            if (checksum != 11864)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key` checksum `11864`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups();
            if (checksum != 55446)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups` checksum `55446`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery();
            if (checksum != 64351)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery` checksum `64351`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device();
            if (checksum != 27955)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device` checksum `27955`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recover();
            if (checksum != 33712)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_recover` checksum `33712`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset();
            if (checksum != 12902)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset` checksum `12902`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state();
            if (checksum != 54051)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state` checksum `54051`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener();
            if (checksum != 36612)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener` checksum `36612`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity();
            if (checksum != 13780)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity` checksum `13780`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key();
            if (checksum != 20380)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key` checksum `20380`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity();
            if (checksum != 20644)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity` checksum `20644`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state();
            if (checksum != 29114)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state` checksum `29114`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener();
            if (checksum != 59806)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener` checksum `59806`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state();
            if (checksum != 37503)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state` checksum `37503`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks();
            if (checksum != 41585)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks` checksum `41585`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version();
            if (checksum != 36573)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version` checksum `36573`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts();
            if (checksum != 63396)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts` checksum `63396`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login();
            if (checksum != 46090)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login` checksum `46090`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login();
            if (checksum != 33501)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login` checksum `33501`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url();
            if (checksum != 61326)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url` checksum `61326`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type();
            if (checksum != 43501)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type` checksum `43501`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel();
            if (checksum != 57622)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel` checksum `57622`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset();
            if (checksum != 11997)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset` checksum `11997`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event();
            if (checksum != 51792)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event` checksum `51792`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id();
            if (checksum != 5876)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id` checksum `5876`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept();
            if (checksum != 25656)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept` checksum `25656`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline();
            if (checksum != 65054)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline` checksum `65054`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban();
            if (checksum != 26242)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban` checksum `26242`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen();
            if (checksum != 36036)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen` checksum `36036`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis();
            if (checksum != 5211)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis` checksum `5211`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info();
            if (checksum != 55450)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info` checksum `55450`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle();
            if (checksum != 46057)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle` checksum `46057`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields();
            if (checksum != 12518)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields` checksum `12518`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path();
            if (checksum != 16357)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path` checksum `16357`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist();
            if (checksum != 12883)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist` checksum `12883`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json();
            if (checksum != 23306)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json` checksum `23306`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_mediasource_url();
            if (checksum != 62692)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_mediasource_url` checksum `62692`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification();
            if (checksum != 2524)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification` checksum `2524`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device();
            if (checksum != 37323)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device` checksum `37323`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device();
            if (checksum != 21251)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device` checksum `21251`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules();
            if (checksum != 60025)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules` checksum `60025`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode();
            if (checksum != 36211)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode` checksum `36211`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings();
            if (checksum != 55295)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings` checksum `55295`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules();
            if (checksum != 19849)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules` checksum `19849`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode();
            if (checksum != 18228)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode` checksum `18228`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled();
            if (checksum != 12210)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled` checksum `12210`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled();
            if (checksum != 533)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled` checksum `533`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled();
            if (checksum != 13304)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled` checksum `13304`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled();
            if (checksum != 49857)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled` checksum `49857`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode();
            if (checksum != 35399)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode` checksum `35399`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled();
            if (checksum != 16823)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled` checksum `16823`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule();
            if (checksum != 465)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule` checksum `465`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode();
            if (checksum != 9426)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode` checksum `9426`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate();
            if (checksum != 57636)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate` checksum `57636`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled();
            if (checksum != 11988)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled` checksum `11988`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled();
            if (checksum != 31650)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled` checksum `31650`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode();
            if (checksum != 4135)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode` checksum `4135`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled();
            if (checksum != 56594)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled` checksum `56594`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room();
            if (checksum != 47580)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room` checksum `47580`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count();
            if (checksum != 61905)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count` checksum `61905`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants();
            if (checksum != 41533)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants` checksum `41533`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases();
            if (checksum != 28555)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases` checksum `28555`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes();
            if (checksum != 44206)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes` checksum `44206`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url();
            if (checksum != 34637)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url` checksum `34637`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_ban_user();
            if (checksum != 35046)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_ban_user` checksum `35046`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban();
            if (checksum != 64711)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban` checksum `64711`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite();
            if (checksum != 62459)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite` checksum `62459`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick();
            if (checksum != 12773)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick` checksum `12773`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin();
            if (checksum != 8341)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin` checksum `8341`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other();
            if (checksum != 13274)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other` checksum `13274`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own();
            if (checksum != 57442)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own` checksum `57442`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message();
            if (checksum != 36743)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message` checksum `36743`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state();
            if (checksum != 19062)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state` checksum `19062`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification();
            if (checksum != 18832)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification` checksum `18832`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias();
            if (checksum != 19786)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias` checksum `19786`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft();
            if (checksum != 39667)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft` checksum `39667`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage();
            if (checksum != 13838)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage` checksum `13838`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key();
            if (checksum != 18081)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key` checksum `18081`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_display_name();
            if (checksum != 64194)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_display_name` checksum `64194`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_edit();
            if (checksum != 61956)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_edit` checksum `61956`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption();
            if (checksum != 14669)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption` checksum `14669`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue();
            if (checksum != 23914)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue` checksum `23914`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state();
            if (checksum != 9101)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state` checksum `9101`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_forget();
            if (checksum != 37840)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_forget` checksum `37840`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels();
            if (checksum != 54094)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels` checksum `54094`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility();
            if (checksum != 412)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility` checksum `412`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call();
            if (checksum != 33588)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call` checksum `33588`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_heroes();
            if (checksum != 22313)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_heroes` checksum `22313`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_id();
            if (checksum != 61990)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_id` checksum `61990`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend();
            if (checksum != 39984)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend` checksum `39984`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user();
            if (checksum != 62239)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user` checksum `62239`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id();
            if (checksum != 41133)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id` checksum `41133`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count();
            if (checksum != 1023)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count` checksum `1023`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_is_direct();
            if (checksum != 10462)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_is_direct` checksum `10462`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_is_public();
            if (checksum != 7336)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_is_public` checksum `7336`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled();
            if (checksum != 36591)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled` checksum `36591`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_is_space();
            if (checksum != 16919)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_is_space` checksum `16919`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned();
            if (checksum != 49186)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned` checksum `49186`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_join();
            if (checksum != 9240)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_join` checksum `9240`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count();
            if (checksum != 55835)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count` checksum `55835`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_kick_user();
            if (checksum != 28600)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_kick_user` checksum `28600`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state();
            if (checksum != 16843)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state` checksum `16843`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_leave();
            if (checksum != 63688)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_leave` checksum `63688`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft();
            if (checksum != 38115)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft` checksum `38115`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read();
            if (checksum != 16004)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read` checksum `16004`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink();
            if (checksum != 36705)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink` checksum `36705`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink();
            if (checksum != 47781)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink` checksum `47781`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_member();
            if (checksum != 48980)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_member` checksum `48980`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url();
            if (checksum != 29492)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url` checksum `29492`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name();
            if (checksum != 33206)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name` checksum `33206`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_members();
            if (checksum != 42691)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_members` checksum `42691`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync();
            if (checksum != 3255)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync` checksum `3255`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_membership();
            if (checksum != 26065)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_membership` checksum `26065`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id();
            if (checksum != 39510)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id` checksum `39510`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory();
            if (checksum != 13924)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory` checksum `13924`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_raw_name();
            if (checksum != 15453)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_raw_name` checksum `15453`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_redact();
            if (checksum != 45810)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_redact` checksum `45810`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar();
            if (checksum != 7230)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar` checksum `7230`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory();
            if (checksum != 16926)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory` checksum `16926`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_report_content();
            if (checksum != 16529)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_report_content` checksum `16529`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_report_room();
            if (checksum != 8059)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_report_room` checksum `8059`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels();
            if (checksum != 63622)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels` checksum `63622`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string();
            if (checksum != 37832)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string` checksum `37832`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_room_info();
            if (checksum != 41146)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_room_info` checksum `41146`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft();
            if (checksum != 62232)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft` checksum `62232`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification();
            if (checksum != 43366)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification` checksum `43366`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed();
            if (checksum != 53551)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed` checksum `53551`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location();
            if (checksum != 34248)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location` checksum `34248`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_send_raw();
            if (checksum != 20486)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_send_raw` checksum `20486`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite();
            if (checksum != 64403)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite` checksum `64403`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority();
            if (checksum != 48070)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority` checksum `48070`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_set_name();
            if (checksum != 52127)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_set_name` checksum `52127`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_set_topic();
            if (checksum != 5576)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_set_topic` checksum `5576`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag();
            if (checksum != 2381)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag` checksum `2381`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share();
            if (checksum != 11488)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share` checksum `11488`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share();
            if (checksum != 19983)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share` checksum `19983`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes();
            if (checksum != 8526)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes` checksum `8526`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests();
            if (checksum != 30649)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests` checksum `30649`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares();
            if (checksum != 57037)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares` checksum `57037`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates();
            if (checksum != 48209)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates` checksum `48209`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications();
            if (checksum != 38524)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications` checksum `38524`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user();
            if (checksum != 47787)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user` checksum `47787`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_timeline();
            if (checksum != 701)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_timeline` checksum `701`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration();
            if (checksum != 35159)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration` checksum `35159`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_topic();
            if (checksum != 59745)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_topic` checksum `59745`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice();
            if (checksum != 28642)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice` checksum `28642`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_unban_user();
            if (checksum != 1803)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_unban_user` checksum `1803`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias();
            if (checksum != 25065)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias` checksum `25065`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility();
            if (checksum != 26248)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility` checksum `26248`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules();
            if (checksum != 49303)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules` checksum `49303`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users();
            if (checksum != 52057)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users` checksum `52057`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility();
            if (checksum != 64724)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility` checksum `64724`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar();
            if (checksum != 19069)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar` checksum `19069`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend();
            if (checksum != 33485)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend` checksum `33485`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page();
            if (checksum != 34221)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page` checksum `34221`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages();
            if (checksum != 2923)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages` checksum `2923`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page();
            if (checksum != 29305)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page` checksum `29305`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results();
            if (checksum != 30207)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results` checksum `30207`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search();
            if (checksum != 24438)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search` checksum `24438`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters();
            if (checksum != 36097)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters` checksum `36097`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state();
            if (checksum != 21585)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state` checksum `21585`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_room();
            if (checksum != 8801)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlist_room` checksum `8801`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page();
            if (checksum != 47748)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page` checksum `47748`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page();
            if (checksum != 61352)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page` checksum `61352`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter();
            if (checksum != 61202)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter` checksum `61202`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller();
            if (checksum != 36258)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller` checksum `36258`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream();
            if (checksum != 56632)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream` checksum `56632`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url();
            if (checksum != 39097)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url` checksum `39097`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias();
            if (checksum != 63300)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias` checksum `63300`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_display_name();
            if (checksum != 8651)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_display_name` checksum `8651`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room();
            if (checksum != 17298)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room` checksum `17298`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id();
            if (checksum != 41176)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id` checksum `41176`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_init_timeline();
            if (checksum != 61817)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_init_timeline` checksum `61817`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct();
            if (checksum != 53352)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct` checksum `53352`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_encrypted();
            if (checksum != 65150)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_encrypted` checksum `65150`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_timeline_initialized();
            if (checksum != 46855)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_timeline_initialized` checksum `46855`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event();
            if (checksum != 38259)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event` checksum `38259`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_membership();
            if (checksum != 1596)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_membership` checksum `1596`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_preview_room();
            if (checksum != 62868)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_preview_room` checksum `62868`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info();
            if (checksum != 32985)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info` checksum `32985`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms();
            if (checksum != 49704)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms` checksum `49704`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room();
            if (checksum != 5185)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room` checksum `5185`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state();
            if (checksum != 64650)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state` checksum `64650`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms();
            if (checksum != 59765)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms` checksum `59765`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator();
            if (checksum != 16821)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator` checksum `16821`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len();
            if (checksum != 39835)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len` checksum `39835`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk();
            if (checksum != 23186)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk` checksum `23186`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget();
            if (checksum != 18179)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget` checksum `18179`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_info();
            if (checksum != 9145)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roompreview_info` checksum `9145`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter();
            if (checksum != 1297)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter` checksum `1297`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave();
            if (checksum != 21886)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave` checksum `21886`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details();
            if (checksum != 1443)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details` checksum `1443`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel();
            if (checksum != 62384)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel` checksum `62384`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join();
            if (checksum != 1903)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join` checksum `1903`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort();
            if (checksum != 11570)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort` checksum `11570`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend();
            if (checksum != 28691)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend` checksum `28691`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request();
            if (checksum != 53466)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request` checksum `53466`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request();
            if (checksum != 37982)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request` checksum `37982`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification();
            if (checksum != 27140)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification` checksum `27140`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification();
            if (checksum != 32994)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification` checksum `32994`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification();
            if (checksum != 64345)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification` checksum `64345`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification();
            if (checksum != 4777)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification` checksum `4777`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification();
            if (checksum != 26149)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification` checksum `26149`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate();
            if (checksum != 42324)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate` checksum `42324`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification();
            if (checksum != 16328)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification` checksum `16328`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description();
            if (checksum != 21346)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description` checksum `21346`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol();
            if (checksum != 46075)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol` checksum `46075`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_span_enter();
            if (checksum != 8900)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_span_enter` checksum `8900`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_span_exit();
            if (checksum != 47924)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_span_exit` checksum `47924`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_span_is_none();
            if (checksum != 33327)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_span_is_none` checksum `33327`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish();
            if (checksum != 64706)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish` checksum `64706`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url();
            if (checksum != 10889)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url` checksum `10889`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service();
            if (checksum != 26426)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service` checksum `26426`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_start();
            if (checksum != 16010)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservice_start` checksum `16010`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_state();
            if (checksum != 61806)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservice_state` checksum `61806`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop();
            if (checksum != 42435)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop` checksum `42435`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish();
            if (checksum != 22814)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish` checksum `22814`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock();
            if (checksum != 56326)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock` checksum `56326`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode();
            if (checksum != 16958)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode` checksum `16958`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_utd_hook();
            if (checksum != 9029)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_utd_hook` checksum `9029`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel();
            if (checksum != 9124)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel` checksum `9124`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished();
            if (checksum != 29008)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished` checksum `29008`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener();
            if (checksum != 18746)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener` checksum `18746`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content();
            if (checksum != 21811)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content` checksum `21811`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll();
            if (checksum != 37925)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll` checksum `37925`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_edit();
            if (checksum != 42189)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_edit` checksum `42189`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll();
            if (checksum != 32659)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll` checksum `32659`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event();
            if (checksum != 54068)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event` checksum `54068`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members();
            if (checksum != 37994)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members` checksum `37994`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id();
            if (checksum != 33999)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id` checksum `33999`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details();
            if (checksum != 54225)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details` checksum `54225`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read();
            if (checksum != 16621)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read` checksum `16621`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards();
            if (checksum != 36829)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards` checksum `36829`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards();
            if (checksum != 30268)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards` checksum `30268`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event();
            if (checksum != 41687)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event` checksum `41687`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event();
            if (checksum != 48707)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event` checksum `48707`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption();
            if (checksum != 21112)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption` checksum `21112`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send();
            if (checksum != 9553)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send` checksum `9553`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio();
            if (checksum != 22559)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio` checksum `22559`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file();
            if (checksum != 4588)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file` checksum `4588`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image();
            if (checksum != 25436)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image` checksum `25436`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location();
            if (checksum != 47400)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location` checksum `47400`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response();
            if (checksum != 7453)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response` checksum `7453`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt();
            if (checksum != 37532)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt` checksum `37532`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply();
            if (checksum != 31468)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply` checksum `31468`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video();
            if (checksum != 1445)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video` checksum `1445`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message();
            if (checksum != 50042)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message` checksum `50042`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status();
            if (checksum != 46161)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status` checksum `46161`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction();
            if (checksum != 29303)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction` checksum `29303`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event();
            if (checksum != 52414)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event` checksum `52414`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append();
            if (checksum != 8453)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append` checksum `8453`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change();
            if (checksum != 4562)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change` checksum `4562`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert();
            if (checksum != 26630)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert` checksum `26630`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back();
            if (checksum != 53464)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back` checksum `53464`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front();
            if (checksum != 42084)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front` checksum `42084`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove();
            if (checksum != 74)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove` checksum `74`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset();
            if (checksum != 34118)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset` checksum `34118`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set();
            if (checksum != 13334)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set` checksum `13334`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate();
            if (checksum != 34040)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate` checksum `34040`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id();
            if (checksum != 11088)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id` checksum `11088`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type();
            if (checksum != 12922)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type` checksum `12922`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id();
            if (checksum != 18142)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id` checksum `18142`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp();
            if (checksum != 50929)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp` checksum `50929`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event();
            if (checksum != 6106)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event` checksum `6106`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual();
            if (checksum != 50960)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual` checksum `50960`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug();
            if (checksum != 38094)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug` checksum `38094`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id();
            if (checksum != 39945)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id` checksum `39945`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications();
            if (checksum != 33024)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications` checksum `33024`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count();
            if (checksum != 35997)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count` checksum `35997`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count();
            if (checksum != 35655)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count` checksum `35655`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation();
            if (checksum != 2948)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation` checksum `2948`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified();
            if (checksum != 61954)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified` checksum `61954`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key();
            if (checksum != 4041)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key` checksum `4041`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin();
            if (checksum != 62925)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin` checksum `62925`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified();
            if (checksum != 41686)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified` checksum `41686`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification();
            if (checksum != 3578)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification` checksum `3578`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run();
            if (checksum != 7519)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run` checksum `7519`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv();
            if (checksum != 2662)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv` checksum `2662`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send();
            if (checksum != 18689)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send` checksum `18689`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new();
            if (checksum != 27991)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new` checksum `27991`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json();
            if (checksum != 10564)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json` checksum `10564`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url();
            if (checksum != 11983)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url` checksum `11983`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes();
            if (checksum != 32675)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes` checksum `32675`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_span_current();
            if (checksum != 53698)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_span_current` checksum `53698`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_span_new();
            if (checksum != 14105)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_span_new` checksum `14105`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude();
            if (checksum != 53805)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude` checksum `53805`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include();
            if (checksum != 25498)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include` checksum `25498`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update();
            if (checksum != 12849)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update` checksum `12849`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update();
            if (checksum != 41052)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update` checksum `41052`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error();
            if (checksum != 26350)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error` checksum `26350`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens();
            if (checksum != 16325)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens` checksum `16325`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain();
            if (checksum != 43954)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain` checksum `43954`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain();
            if (checksum != 53223)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain` checksum `53223`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update();
            if (checksum != 13538)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update` checksum `13538`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call();
            if (checksum != 57311)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call` checksum `57311`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call();
            if (checksum != 47519)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call` checksum `47519`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call();
            if (checksum != 10077)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call` checksum `10077`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call();
            if (checksum != 34519)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call` checksum `34519`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change();
            if (checksum != 51708)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change` checksum `51708`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update();
            if (checksum != 65318)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update` checksum `65318`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress();
            if (checksum != 41133)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress` checksum `41133`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update();
            if (checksum != 9758)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update` checksum `9758`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update();
            if (checksum != 64575)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update` checksum `64575`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update();
            if (checksum != 41968)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update` checksum `41968`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call();
            if (checksum != 44934)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call` checksum `44934`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update();
            if (checksum != 12576)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update` checksum `12576`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update();
            if (checksum != 23169)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update` checksum `23169`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update();
            if (checksum != 24823)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update` checksum `24823`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update();
            if (checksum != 36937)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update` checksum `36937`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error();
            if (checksum != 38224)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error` checksum `38224`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request();
            if (checksum != 3417)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request` checksum `3417`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request();
            if (checksum != 3733)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request` checksum `3733`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification();
            if (checksum != 56833)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification` checksum `56833`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data();
            if (checksum != 30840)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data` checksum `30840`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail();
            if (checksum != 32164)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail` checksum `32164`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel();
            if (checksum != 3367)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel` checksum `3367`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish();
            if (checksum != 37905)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish` checksum `37905`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update();
            if (checksum != 62231)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update` checksum `62231`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update();
            if (checksum != 30147)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update` checksum `30147`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call();
            if (checksum != 64299)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call` checksum `64299`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd();
            if (checksum != 61791)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd` checksum `61791`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update();
            if (checksum != 38998)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update` checksum `38998`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities();
            if (checksum != 12846)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.matrix_sdk_ffi: uniffi bindings expected function `uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities` checksum `12846`, library returned `{checksum}`"
                );
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625

class FfiConverterUInt8 : FfiConverter<byte, byte>
{
    public static FfiConverterUInt8 INSTANCE = new FfiConverterUInt8();

    public override byte Lift(byte value)
    {
        return value;
    }

    public override byte Read(BigEndianStream stream)
    {
        return stream.ReadByte();
    }

    public override byte Lower(byte value)
    {
        return value;
    }

    public override int AllocationSize(byte value)
    {
        return 1;
    }

    public override void Write(byte value, BigEndianStream stream)
    {
        stream.WriteByte(value);
    }
}

class FfiConverterUInt16 : FfiConverter<ushort, ushort>
{
    public static FfiConverterUInt16 INSTANCE = new FfiConverterUInt16();

    public override ushort Lift(ushort value)
    {
        return value;
    }

    public override ushort Read(BigEndianStream stream)
    {
        return stream.ReadUShort();
    }

    public override ushort Lower(ushort value)
    {
        return value;
    }

    public override int AllocationSize(ushort value)
    {
        return 2;
    }

    public override void Write(ushort value, BigEndianStream stream)
    {
        stream.WriteUShort(value);
    }
}

class FfiConverterUInt32 : FfiConverter<uint, uint>
{
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value)
    {
        return value;
    }

    public override uint Read(BigEndianStream stream)
    {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value)
    {
        return value;
    }

    public override int AllocationSize(uint value)
    {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream)
    {
        stream.WriteUInt(value);
    }
}

class FfiConverterInt32 : FfiConverter<int, int>
{
    public static FfiConverterInt32 INSTANCE = new FfiConverterInt32();

    public override int Lift(int value)
    {
        return value;
    }

    public override int Read(BigEndianStream stream)
    {
        return stream.ReadInt();
    }

    public override int Lower(int value)
    {
        return value;
    }

    public override int AllocationSize(int value)
    {
        return 4;
    }

    public override void Write(int value, BigEndianStream stream)
    {
        stream.WriteInt(value);
    }
}

class FfiConverterUInt64 : FfiConverter<ulong, ulong>
{
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value)
    {
        return value;
    }

    public override ulong Read(BigEndianStream stream)
    {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value)
    {
        return value;
    }

    public override int AllocationSize(ulong value)
    {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream)
    {
        stream.WriteULong(value);
    }
}

class FfiConverterInt64 : FfiConverter<long, long>
{
    public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

    public override long Lift(long value)
    {
        return value;
    }

    public override long Read(BigEndianStream stream)
    {
        return stream.ReadLong();
    }

    public override long Lower(long value)
    {
        return value;
    }

    public override int AllocationSize(long value)
    {
        return 8;
    }

    public override void Write(long value, BigEndianStream stream)
    {
        stream.WriteLong(value);
    }
}

class FfiConverterDouble : FfiConverter<double, double>
{
    public static FfiConverterDouble INSTANCE = new FfiConverterDouble();

    public override double Lift(double value)
    {
        return value;
    }

    public override double Read(BigEndianStream stream)
    {
        return stream.ReadDouble();
    }

    public override double Lower(double value)
    {
        return value;
    }

    public override int AllocationSize(double value)
    {
        return 8;
    }

    public override void Write(double value, BigEndianStream stream)
    {
        stream.WriteDouble(value);
    }
}

class FfiConverterBoolean : FfiConverter<bool, sbyte>
{
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value)
    {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream)
    {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value)
    {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value)
    {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream)
    {
        stream.WriteSByte(Lower(value));
    }
}

class FfiConverterString : FfiConverter<string, RustBuffer>
{
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value)
    {
        try
        {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        }
        finally
        {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value)
    {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}

class FfiConverterByteArray : FfiConverterRustBuffer<byte[]>
{
    public static FfiConverterByteArray INSTANCE = new FfiConverterByteArray();

    public override byte[] Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        return stream.ReadBytes(length);
    }

    public override int AllocationSize(byte[] value)
    {
        return 4 + value.Length;
    }

    public override void Write(byte[] value, BigEndianStream stream)
    {
        stream.WriteInt(value.Length);
        stream.WriteBytes(value);
    }
}

class FfiConverterDuration : FfiConverterRustBuffer<TimeSpan>
{
    public static FfiConverterDuration INSTANCE = new FfiConverterDuration();

    // https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/TimeSpan.cs
    private const uint NanosecondsPerTick = 100;

    public override TimeSpan Read(BigEndianStream stream)
    {
        var seconds = stream.ReadULong();
        var nanoseconds = stream.ReadUInt();
        var ticks = seconds * TimeSpan.TicksPerSecond;
        ticks += nanoseconds / NanosecondsPerTick;
        return new TimeSpan(Convert.ToInt64(ticks));
    }

    public override int AllocationSize(TimeSpan value)
    {
        // 8 bytes for seconds, 4 bytes for nanoseconds
        return 12;
    }

    public override void Write(TimeSpan value, BigEndianStream stream)
    {
        stream.WriteULong(Convert.ToUInt64(value.Ticks / TimeSpan.TicksPerSecond));
        stream.WriteUInt(Convert.ToUInt32(value.Ticks % TimeSpan.TicksPerSecond * NanosecondsPerTick));
    }
}

internal interface IClient
{
    /// <summary>
    /// Aborts an existing OIDC login operation that might have been cancelled,
    /// failed etc.
    /// </summary>
    Task AbortOidcAuth(OAuthAuthorizationData @authorizationData);

    /// <summary>
    /// Get the content of the event of the given type out of the account data
    /// store.
    ///
    /// It will be returned as a JSON string.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<string?> AccountData(string @eventType);

    /// <exception cref="ClientException"></exception>
    Task<string?> AccountUrl(AccountManagementAction? @action);

    /// <summary>
    /// Find all sliding sync versions that are available.
    ///
    /// Be careful: This method may hit the store and will send new requests for
    /// each call. It can be costly to call it repeatedly.
    ///
    /// If `.well-known` or `/versions` is unreachable, it will simply move
    /// potential sliding sync versions aside. No error will be reported.
    /// </summary>
    Task<List<SlidingSyncVersion>> AvailableSlidingSyncVersions();

    /// <summary>
    /// Sends a request to retrieve the avatar URL. Will fill the cache used by
    /// [`Self::cached_avatar_url`] on success.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<string?> AvatarUrl();

    /// <summary>
    /// Waits until an at least partially synced room is received, and returns
    /// it.
    ///
    /// **Note: this function will loop endlessly until either it finds the room
    /// or an externally set timeout happens.**
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<Room> AwaitRoomRemoteEcho(string @roomId);

    /// <summary>
    /// Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<string?> CachedAvatarUrl();

    /// <summary>
    /// Lets the user know whether this is an `m.login.password` based
    /// auth and if the account can actually be deactivated
    /// </summary>
    bool CanDeactivateAccount();

    /// <summary>
    /// Clear all the non-critical caches for this Client instance.
    ///
    /// - This will empty all the room's persisted event caches, so all rooms
    /// will start as if they were empty.
    /// - This will empty the media cache according to the current media
    /// retention policy.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ClearCaches();

    /// <exception cref="ClientException"></exception>
    Task<string> CreateRoom(CreateRoomParameters @request);

    /// <summary>
    /// Login using JWT
    /// This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
    /// For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task CustomLoginWithJwt(string @jwt, string? @initialDeviceName, string? @deviceId);

    /// <summary>
    /// Deactivate this account definitively.
    /// Similarly to `encryption::reset_identity` this
    /// will only work with password-based authentication (`m.login.password`)
    ///
    /// # Arguments
    ///
    /// * `auth_data` - This request uses the [User-Interactive Authentication
    /// API][uiaa]. The first request needs to set this to `None` and will
    /// always fail and the same request needs to be made but this time with
    /// some `auth_data` provided.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task DeactivateAccount(AuthData? @authData, bool @eraseData);

    /// <summary>
    /// Deletes a pusher of given pusher ids
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task DeletePusher(PusherIdentifiers @identifiers);

    /// <exception cref="ClientException"></exception>
    string DeviceId();

    /// <exception cref="ClientException"></exception>
    Task<string> DisplayName();

    /// <summary>
    /// Enables or disables all the room send queues at once.
    ///
    /// When connectivity is lost on a device, it is recommended to disable the
    /// room sending queues.
    ///
    /// This can be controlled for individual rooms, using
    /// [`Room::enable_send_queue`].
    /// </summary>
    Task EnableAllSendQueues(bool @enable);
    Encryption Encryption();

    /// <exception cref="ClientException"></exception>
    Room? GetDmRoom(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<byte[]> GetMediaContent(MediaSource @mediaSource);

    /// <exception cref="ClientException"></exception>
    Task<MediaFileHandle> GetMediaFile(
        MediaSource @mediaSource,
        string? @filename,
        string @mimeType,
        bool @useCache,
        string? @tempDir
    );

    /// <exception cref="ClientException"></exception>
    Task<byte[]> GetMediaThumbnail(MediaSource @mediaSource, ulong @width, ulong @height);
    Task<NotificationSettings> GetNotificationSettings();

    /// <exception cref="ClientException"></exception>
    Task<UserProfile> GetProfile(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<List<string>> GetRecentlyVisitedRooms();

    /// <summary>
    /// Get a room by its ID.
    ///
    /// # Arguments
    ///
    /// * `room_id` - The ID of the room to get.
    ///
    /// # Returns
    ///
    /// A `Result` containing an optional room, or a `ClientError`.
    /// This method will not initialize the room's timeline or populate it with
    /// events.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Room? GetRoom(string @roomId);

    /// <summary>
    /// Given a room alias, get the preview of a room, to interact with it.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<RoomPreview> GetRoomPreviewFromRoomAlias(string @roomAlias);

    /// <summary>
    /// Given a room id, get the preview of a room, to interact with it.
    ///
    /// The list of `via_servers` must be a list of servers that know
    /// about the room and can resolve it, and that may appear as a `via`
    /// parameter in e.g. a permalink URL. This list can be empty.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<RoomPreview> GetRoomPreviewFromRoomId(string @roomId, List<string> @viaServers);

    /// <exception cref="ClientException"></exception>
    Task<SessionVerificationController> GetSessionVerificationController();

    /// <summary>
    /// Allows generic GET requests to be made through the SDKs internal HTTP
    /// client
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<string> GetUrl(string @url);

    /// <summary>
    /// The homeserver this client is configured to use.
    /// </summary>
    string Homeserver();

    /// <summary>
    /// Information about login options for the client's homeserver.
    /// </summary>
    Task<HomeserverLoginDetails> HomeserverLoginDetails();

    /// <exception cref="ClientException"></exception>
    Task IgnoreUser(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<List<string>> IgnoredUsers();

    /// <summary>
    /// Checks if a room alias is not in use yet.
    ///
    /// Returns:
    /// - `Ok(true)` if the room alias is available.
    /// - `Ok(false)` if it's not (the resolve alias request returned a `404`
    /// status code).
    /// - An `Err` otherwise.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> IsRoomAliasAvailable(string @alias);

    /// <summary>
    /// Join a room by its ID.
    ///
    /// Use this method when the homeserver already knows of the given room ID.
    /// Otherwise use `join_room_by_id_or_alias` so you can pass a list of
    /// server names for the homeserver to find the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<Room> JoinRoomById(string @roomId);

    /// <summary>
    /// Join a room by its ID or alias.
    ///
    /// When supplying the room's ID, you can also supply a list of server names
    /// for the homeserver to find the room. Typically these server names
    /// come from a permalink's `via` parameters, or from resolving a room's
    /// alias into an ID.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<Room> JoinRoomByIdOrAlias(string @roomIdOrAlias, List<string> @serverNames);

    /// <summary>
    /// Knock on a room to join it using its ID or alias.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<Room> Knock(string @roomIdOrAlias, string? @reason, List<string> @serverNames);

    /// <summary>
    /// Login using a username and password.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Login(string @username, string @password, string? @initialDeviceName, string? @deviceId);

    /// <summary>
    /// Login using an email and password.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task LoginWithEmail(string @email, string @password, string? @initialDeviceName, string? @deviceId);

    /// <summary>
    /// Completes the OIDC login process.
    /// </summary>
    /// <exception cref="OidcException"></exception>
    Task LoginWithOidcCallback(string @callbackUrl);

    /// <summary>
    /// Log the current user out.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Logout();

    /// <exception cref="ClientException"></exception>
    Task<NotificationClient> NotificationClient(NotificationProcessSetup @processSetup);

    /// <exception cref="ClientException"></exception>
    Task RemoveAvatar();

    /// <summary>
    /// Empty the server version and unstable features cache.
    ///
    /// Since the SDK caches server capabilities (versions and unstable
    /// features), it's possible to have a stale entry in the cache. This
    /// functions makes it possible to force reset it.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ResetServerCapabilities();

    /// <summary>
    /// Resolves the given room alias to a room ID (and a list of servers), if
    /// possible.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<ResolvedRoomAlias?> ResolveRoomAlias(string @roomAlias);

    /// <summary>
    /// Restores the client from a `Session`.
    ///
    /// It reloads the entire set of rooms from the previous session.
    ///
    /// If you want to control the amount of rooms to reloads, check
    /// [`Client::restore_session_with`].
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task RestoreSession(Session @session);

    /// <summary>
    /// Restores the client from a `Session`.
    ///
    /// It reloads a set of rooms controlled by [`RoomLoadSettings`].
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task RestoreSessionWith(Session @session, RoomLoadSettings @roomLoadSettings);

    /// <summary>
    /// Checks if a room alias exists in the current homeserver.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> RoomAliasExists(string @roomAlias);
    RoomDirectorySearch RoomDirectorySearch();
    List<Room> Rooms();

    /// <exception cref="ClientException"></exception>
    Task<SearchUsersResults> SearchUsers(string @searchTerm, ulong @limit);

    /// <summary>
    /// The URL of the server.
    ///
    /// Not to be confused with the `Self::homeserver`. `server` is usually
    /// the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
    /// `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
    /// homeserver (at the time of writing  2024-08-28).
    ///
    /// This value is optional depending on how the `Client` has been built.
    /// If it's been built from a homeserver URL directly, we don't know the
    /// server. However, if the `Client` has been built from a server URL or
    /// name, then the homeserver has been discovered, and we know both.
    /// </summary>
    string? Server();

    /// <exception cref="ClientException"></exception>
    Session Session();

    /// <summary>
    /// Set the given account data content for the given event type.
    ///
    /// It should be supplied as a JSON string.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SetAccountData(string @eventType, string @content);
    TaskHandle? SetDelegate(ClientDelegate? @delegate);

    /// <exception cref="ClientException"></exception>
    Task SetDisplayName(string @name);

    /// <summary>
    /// Set the media retention policy.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SetMediaRetentionPolicy(MediaRetentionPolicy @policy);

    /// <summary>
    /// Registers a pusher with given parameters
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SetPusher(
        PusherIdentifiers @identifiers,
        PusherKind @kind,
        string @appDisplayName,
        string @deviceDisplayName,
        string? @profileTag,
        string @lang
    );

    /// <summary>
    /// The sliding sync version.
    /// </summary>
    SlidingSyncVersion SlidingSyncVersion();

    /// <summary>
    /// Returns a handler to start the SSO login process.
    /// </summary>
    /// <exception cref="SsoException"></exception>
    Task<SsoHandler> StartSsoLogin(string @redirectUrl, string? @idpId);
    TaskHandle SubscribeToIgnoredUsers(IgnoredUsersListener @listener);

    /// <summary>
    /// Subscribe to the global enablement status of the send queue, at the
    /// client-wide level.
    ///
    /// The given listener will be immediately called with the initial value of
    /// the enablement status.
    /// </summary>
    TaskHandle SubscribeToSendQueueStatus(SendQueueRoomErrorListener @listener);
    SyncServiceBuilder SyncService();

    /// <exception cref="ClientException"></exception>
    Task TrackRecentlyVisitedRoom(string @room);

    /// <exception cref="ClientException"></exception>
    Task UnignoreUser(string @userId);

    /// <exception cref="ClientException"></exception>
    Task UploadAvatar(string @mimeType, byte[] @data);

    /// <exception cref="ClientException"></exception>
    Task<string> UploadMedia(string @mimeType, byte[] @data, ProgressWatcher? @progressWatcher);

    /// <summary>
    /// Requests the URL needed for opening a web view using OIDC. Once the web
    /// view has succeeded, call `login_with_oidc_callback` with the callback it
    /// returns. If a failure occurs and a callback isn't available, make sure
    /// to call `abort_oidc_auth` to inform the client of this.
    ///
    /// # Arguments
    ///
    /// * `oidc_configuration` - The configuration used to load the credentials
    /// of the client if it is already registered with the authorization
    /// server, or register the client and store its credentials if it isn't.
    ///
    /// * `prompt` - The desired user experience in the web UI. No value means
    /// that the user wishes to login into an existing account, and a value of
    /// `Create` means that the user wishes to register a new account.
    /// </summary>
    /// <exception cref="OidcException"></exception>
    Task<OAuthAuthorizationData> UrlForOidc(OidcConfiguration @oidcConfiguration, OidcPrompt? @prompt);

    /// <exception cref="ClientException"></exception>
    string UserId();

    /// <summary>
    /// The server name part of the current user ID
    /// </summary>
    /// <exception cref="ClientException"></exception>
    string UserIdServerName();
}

internal class Client : IClient, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Client(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~Client()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_client(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_client(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Aborts an existing OIDC login operation that might have been cancelled,
    /// failed etc.
    /// </summary>
    public async Task AbortOidcAuth(OAuthAuthorizationData @authorizationData)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
                    thisPtr,
                    FfiConverterTypeOAuthAuthorizationData.INSTANCE.Lower(@authorizationData)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Get the content of the event of the given type out of the account data
    /// store.
    ///
    /// It will be returned as a JSON string.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<string?> AccountData(string @eventType)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_account_data(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventType)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string?> AccountUrl(AccountManagementAction? @action)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_account_url(
                    thisPtr,
                    FfiConverterOptionalTypeAccountManagementAction.INSTANCE.Lower(@action)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Find all sliding sync versions that are available.
    ///
    /// Be careful: This method may hit the store and will send new requests for
    /// each call. It can be costly to call it repeatedly.
    ///
    /// If `.well-known` or `/versions` is unreachable, it will simply move
    /// potential sliding sync versions aside. No error will be reported.
    /// </summary>
    public async Task<List<SlidingSyncVersion>> AvailableSlidingSyncVersions()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterSequenceTypeSlidingSyncVersion.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Sends a request to retrieve the avatar URL. Will fill the cache used by
    /// [`Self::cached_avatar_url`] on success.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<string?> AvatarUrl()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Waits until an at least partially synced room is received, and returns
    /// it.
    ///
    /// **Note: this function will loop endlessly until either it finds the room
    /// or an externally set timeout happens.**
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<Room> AwaitRoomRemoteEcho(string @roomId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoom.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<string?> CachedAvatarUrl()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Lets the user know whether this is an `m.login.password` based
    /// auth and if the account can actually be deactivated
    /// </summary>
    public bool CanDeactivateAccount()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Clear all the non-critical caches for this Client instance.
    ///
    /// - This will empty all the room's persisted event caches, so all rooms
    /// will start as if they were empty.
    /// - This will empty the media cache according to the current media
    /// retention policy.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ClearCaches()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string> CreateRoom(CreateRoomParameters @request)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_create_room(
                    thisPtr,
                    FfiConverterTypeCreateRoomParameters.INSTANCE.Lower(@request)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Login using JWT
    /// This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
    /// For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task CustomLoginWithJwt(string @jwt, string? @initialDeviceName, string? @deviceId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@jwt),
                    FfiConverterOptionalString.INSTANCE.Lower(@initialDeviceName),
                    FfiConverterOptionalString.INSTANCE.Lower(@deviceId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Deactivate this account definitively.
    /// Similarly to `encryption::reset_identity` this
    /// will only work with password-based authentication (`m.login.password`)
    ///
    /// # Arguments
    ///
    /// * `auth_data` - This request uses the [User-Interactive Authentication
    /// API][uiaa]. The first request needs to set this to `None` and will
    /// always fail and the same request needs to be made but this time with
    /// some `auth_data` provided.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task DeactivateAccount(AuthData? @authData, bool @eraseData)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
                    thisPtr,
                    FfiConverterOptionalTypeAuthData.INSTANCE.Lower(@authData),
                    FfiConverterBoolean.INSTANCE.Lower(@eraseData)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Deletes a pusher of given pusher ids
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task DeletePusher(PusherIdentifiers @identifiers)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
                    thisPtr,
                    FfiConverterTypePusherIdentifiers.INSTANCE.Lower(@identifiers)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public string DeviceId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_device_id(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string> DisplayName()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_display_name(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Enables or disables all the room send queues at once.
    ///
    /// When connectivity is lost on a device, it is recommended to disable the
    /// room sending queues.
    ///
    /// This can be controlled for individual rooms, using
    /// [`Room::enable_send_queue`].
    /// </summary>
    public async Task EnableAllSendQueues(bool @enable)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@enable)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    public Encryption Encryption()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeEncryption.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_encryption(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public Room? GetDmRoom(string @userId)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeRoom.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@userId),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<byte[]> GetMediaContent(MediaSource @mediaSource)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
                    thisPtr,
                    FfiConverterTypeMediaSource.INSTANCE.Lower(@mediaSource)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterByteArray.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<MediaFileHandle> GetMediaFile(
        MediaSource @mediaSource,
        string? @filename,
        string @mimeType,
        bool @useCache,
        string? @tempDir
    )
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
                    thisPtr,
                    FfiConverterTypeMediaSource.INSTANCE.Lower(@mediaSource),
                    FfiConverterOptionalString.INSTANCE.Lower(@filename),
                    FfiConverterString.INSTANCE.Lower(@mimeType),
                    FfiConverterBoolean.INSTANCE.Lower(@useCache),
                    FfiConverterOptionalString.INSTANCE.Lower(@tempDir)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeMediaFileHandle.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<byte[]> GetMediaThumbnail(MediaSource @mediaSource, ulong @width, ulong @height)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
                    thisPtr,
                    FfiConverterTypeMediaSource.INSTANCE.Lower(@mediaSource),
                    FfiConverterUInt64.INSTANCE.Lower(@width),
                    FfiConverterUInt64.INSTANCE.Lower(@height)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterByteArray.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public async Task<NotificationSettings> GetNotificationSettings()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeNotificationSettings.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<UserProfile> GetProfile(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeUserProfile.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<List<string>> GetRecentlyVisitedRooms()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterSequenceString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Get a room by its ID.
    ///
    /// # Arguments
    ///
    /// * `room_id` - The ID of the room to get.
    ///
    /// # Returns
    ///
    /// A `Result` containing an optional room, or a `ClientError`.
    /// This method will not initialize the room's timeline or populate it with
    /// events.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public Room? GetRoom(string @roomId)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeRoom.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_room(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@roomId),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Given a room alias, get the preview of a room, to interact with it.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<RoomPreview> GetRoomPreviewFromRoomAlias(string @roomAlias)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomAlias)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoomPreview.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Given a room id, get the preview of a room, to interact with it.
    ///
    /// The list of `via_servers` must be a list of servers that know
    /// about the room and can resolve it, and that may appear as a `via`
    /// parameter in e.g. a permalink URL. This list can be empty.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<RoomPreview> GetRoomPreviewFromRoomId(string @roomId, List<string> @viaServers)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId),
                    FfiConverterSequenceString.INSTANCE.Lower(@viaServers)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoomPreview.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<SessionVerificationController> GetSessionVerificationController()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeSessionVerificationController.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Allows generic GET requests to be made through the SDKs internal HTTP
    /// client
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<string> GetUrl(string @url)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_get_url(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@url)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// The homeserver this client is configured to use.
    /// </summary>
    public string Homeserver()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_homeserver(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Information about login options for the client's homeserver.
    /// </summary>
    public async Task<HomeserverLoginDetails> HomeserverLoginDetails()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeHomeserverLoginDetails.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task IgnoreUser(string @userId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<List<string>> IgnoredUsers()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterSequenceString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Checks if a room alias is not in use yet.
    ///
    /// Returns:
    /// - `Ok(true)` if the room alias is available.
    /// - `Ok(false)` if it's not (the resolve alias request returned a `404`
    /// status code).
    /// - An `Err` otherwise.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> IsRoomAliasAvailable(string @alias)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@alias)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Join a room by its ID.
    ///
    /// Use this method when the homeserver already knows of the given room ID.
    /// Otherwise use `join_room_by_id_or_alias` so you can pass a list of
    /// server names for the homeserver to find the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<Room> JoinRoomById(string @roomId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoom.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Join a room by its ID or alias.
    ///
    /// When supplying the room's ID, you can also supply a list of server names
    /// for the homeserver to find the room. Typically these server names
    /// come from a permalink's `via` parameters, or from resolving a room's
    /// alias into an ID.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<Room> JoinRoomByIdOrAlias(string @roomIdOrAlias, List<string> @serverNames)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomIdOrAlias),
                    FfiConverterSequenceString.INSTANCE.Lower(@serverNames)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoom.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Knock on a room to join it using its ID or alias.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<Room> Knock(string @roomIdOrAlias, string? @reason, List<string> @serverNames)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_knock(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomIdOrAlias),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason),
                    FfiConverterSequenceString.INSTANCE.Lower(@serverNames)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoom.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Login using a username and password.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Login(string @username, string @password, string? @initialDeviceName, string? @deviceId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_login(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@username),
                    FfiConverterString.INSTANCE.Lower(@password),
                    FfiConverterOptionalString.INSTANCE.Lower(@initialDeviceName),
                    FfiConverterOptionalString.INSTANCE.Lower(@deviceId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Login using an email and password.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task LoginWithEmail(string @email, string @password, string? @initialDeviceName, string? @deviceId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@email),
                    FfiConverterString.INSTANCE.Lower(@password),
                    FfiConverterOptionalString.INSTANCE.Lower(@initialDeviceName),
                    FfiConverterOptionalString.INSTANCE.Lower(@deviceId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Completes the OIDC login process.
    /// </summary>
    /// <exception cref="OidcException"></exception>
    public async Task LoginWithOidcCallback(string @callbackUrl)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@callbackUrl)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeOidcError.INSTANCE
        );
    }

    /// <summary>
    /// Log the current user out.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Logout()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_logout(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<NotificationClient> NotificationClient(NotificationProcessSetup @processSetup)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
                    thisPtr,
                    FfiConverterTypeNotificationProcessSetup.INSTANCE.Lower(@processSetup)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeNotificationClient.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task RemoveAvatar()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Empty the server version and unstable features cache.
    ///
    /// Since the SDK caches server capabilities (versions and unstable
    /// features), it's possible to have a stale entry in the cache. This
    /// functions makes it possible to force reset it.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ResetServerCapabilities()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_reset_server_capabilities(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Resolves the given room alias to a room ID (and a list of servers), if
    /// possible.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<ResolvedRoomAlias?> ResolveRoomAlias(string @roomAlias)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomAlias)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeResolvedRoomAlias.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Restores the client from a `Session`.
    ///
    /// It reloads the entire set of rooms from the previous session.
    ///
    /// If you want to control the amount of rooms to reloads, check
    /// [`Client::restore_session_with`].
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task RestoreSession(Session @session)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
                    thisPtr,
                    FfiConverterTypeSession.INSTANCE.Lower(@session)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Restores the client from a `Session`.
    ///
    /// It reloads a set of rooms controlled by [`RoomLoadSettings`].
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task RestoreSessionWith(Session @session, RoomLoadSettings @roomLoadSettings)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(
                    thisPtr,
                    FfiConverterTypeSession.INSTANCE.Lower(@session),
                    FfiConverterTypeRoomLoadSettings.INSTANCE.Lower(@roomLoadSettings)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Checks if a room alias exists in the current homeserver.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> RoomAliasExists(string @roomAlias)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomAlias)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public RoomDirectorySearch RoomDirectorySearch()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomDirectorySearch.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(thisPtr, ref _status)
                )
            )
        );
    }

    public List<Room> Rooms()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterSequenceTypeRoom.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_rooms(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<SearchUsersResults> SearchUsers(string @searchTerm, ulong @limit)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_search_users(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@searchTerm),
                    FfiConverterUInt64.INSTANCE.Lower(@limit)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeSearchUsersResults.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// The URL of the server.
    ///
    /// Not to be confused with the `Self::homeserver`. `server` is usually
    /// the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
    /// `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
    /// homeserver (at the time of writing  2024-08-28).
    ///
    /// This value is optional depending on how the `Client` has been built.
    /// If it's been built from a homeserver URL directly, we don't know the
    /// server. However, if the `Client` has been built from a server URL or
    /// name, then the homeserver has been discovered, and we know both.
    /// </summary>
    public string? Server()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_server(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public Session Session()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSession.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_session(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Set the given account data content for the given event type.
    ///
    /// It should be supplied as a JSON string.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SetAccountData(string @eventType, string @content)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventType),
                    FfiConverterString.INSTANCE.Lower(@content)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public TaskHandle? SetDelegate(ClientDelegate? @delegate)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
                            thisPtr,
                            FfiConverterOptionalTypeClientDelegate.INSTANCE.Lower(@delegate),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task SetDisplayName(string @name)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@name)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Set the media retention policy.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SetMediaRetentionPolicy(MediaRetentionPolicy @policy)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(
                    thisPtr,
                    FfiConverterTypeMediaRetentionPolicy.INSTANCE.Lower(@policy)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Registers a pusher with given parameters
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SetPusher(
        PusherIdentifiers @identifiers,
        PusherKind @kind,
        string @appDisplayName,
        string @deviceDisplayName,
        string? @profileTag,
        string @lang
    )
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
                    thisPtr,
                    FfiConverterTypePusherIdentifiers.INSTANCE.Lower(@identifiers),
                    FfiConverterTypePusherKind.INSTANCE.Lower(@kind),
                    FfiConverterString.INSTANCE.Lower(@appDisplayName),
                    FfiConverterString.INSTANCE.Lower(@deviceDisplayName),
                    FfiConverterOptionalString.INSTANCE.Lower(@profileTag),
                    FfiConverterString.INSTANCE.Lower(@lang)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// The sliding sync version.
    /// </summary>
    public SlidingSyncVersion SlidingSyncVersion()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSlidingSyncVersion.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Returns a handler to start the SSO login process.
    /// </summary>
    /// <exception cref="SsoException"></exception>
    public async Task<SsoHandler> StartSsoLogin(string @redirectUrl, string? @idpId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@redirectUrl),
                    FfiConverterOptionalString.INSTANCE.Lower(@idpId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeSsoHandler.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeSsoError.INSTANCE
        );
    }

    public TaskHandle SubscribeToIgnoredUsers(IgnoredUsersListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
                            thisPtr,
                            FfiConverterTypeIgnoredUsersListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Subscribe to the global enablement status of the send queue, at the
    /// client-wide level.
    ///
    /// The given listener will be immediately called with the initial value of
    /// the enablement status.
    /// </summary>
    public TaskHandle SubscribeToSendQueueStatus(SendQueueRoomErrorListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
                            thisPtr,
                            FfiConverterTypeSendQueueRoomErrorListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    public SyncServiceBuilder SyncService()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSyncServiceBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_sync_service(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task TrackRecentlyVisitedRoom(string @room)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@room)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task UnignoreUser(string @userId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task UploadAvatar(string @mimeType, byte[] @data)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@mimeType),
                    FfiConverterByteArray.INSTANCE.Lower(@data)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string> UploadMedia(string @mimeType, byte[] @data, ProgressWatcher? @progressWatcher)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@mimeType),
                    FfiConverterByteArray.INSTANCE.Lower(@data),
                    FfiConverterOptionalTypeProgressWatcher.INSTANCE.Lower(@progressWatcher)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Requests the URL needed for opening a web view using OIDC. Once the web
    /// view has succeeded, call `login_with_oidc_callback` with the callback it
    /// returns. If a failure occurs and a callback isn't available, make sure
    /// to call `abort_oidc_auth` to inform the client of this.
    ///
    /// # Arguments
    ///
    /// * `oidc_configuration` - The configuration used to load the credentials
    /// of the client if it is already registered with the authorization
    /// server, or register the client and store its credentials if it isn't.
    ///
    /// * `prompt` - The desired user experience in the web UI. No value means
    /// that the user wishes to login into an existing account, and a value of
    /// `Create` means that the user wishes to register a new account.
    /// </summary>
    /// <exception cref="OidcException"></exception>
    public async Task<OAuthAuthorizationData> UrlForOidc(OidcConfiguration @oidcConfiguration, OidcPrompt? @prompt)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
                    thisPtr,
                    FfiConverterTypeOidcConfiguration.INSTANCE.Lower(@oidcConfiguration),
                    FfiConverterOptionalTypeOidcPrompt.INSTANCE.Lower(@prompt)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeOAuthAuthorizationData.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeOidcError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public string UserId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_user_id(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// The server name part of the current user ID
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public string UserIdServerName()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeClient : FfiConverter<Client, IntPtr>
{
    public static FfiConverterTypeClient INSTANCE = new FfiConverterTypeClient();

    public override IntPtr Lower(Client value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Client Lift(IntPtr value)
    {
        return new Client(value);
    }

    public override Client Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Client value)
    {
        return 8;
    }

    public override void Write(Client value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IClientBuilder
{
    ClientBuilder AddRootCertificates(List<byte[]> @certificates);

    /// <summary>
    /// Automatically create a backup version if no backup exists.
    /// </summary>
    ClientBuilder AutoEnableBackups(bool @autoEnableBackups);
    ClientBuilder AutoEnableCrossSigning(bool @autoEnableCrossSigning);

    /// <summary>
    /// Select a strategy to download room keys from the backup. By default
    /// we download after a decryption failure.
    ///
    /// Take a look at the [`BackupDownloadStrategy`] enum for more options.
    /// </summary>
    ClientBuilder BackupDownloadStrategy(BackupDownloadStrategy @backupDownloadStrategy);

    /// <exception cref="ClientBuildException"></exception>
    Task<Client> Build();

    /// <summary>
    /// Finish the building of the client and attempt to log in using the
    /// provided [`QrCodeData`].
    ///
    /// This method will build the client and immediately attempt to log the
    /// client in using the provided [`QrCodeData`] using the login
    /// mechanism described in [MSC4108]. As such this methods requires OAuth
    /// 2.0 support as well as sliding sync support.
    ///
    /// The usage of the progress_listener is required to transfer the
    /// [`CheckCode`] to the existing client.
    ///
    /// [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
    /// </summary>
    /// <exception cref="HumanQrLoginException"></exception>
    Task<Client> BuildWithQrCode(
        QrCodeData @qrCodeData,
        OidcConfiguration @oidcConfiguration,
        QrLoginProgressListener @progressListener
    );
    ClientBuilder CrossProcessStoreLocksHolderName(string @holderName);
    ClientBuilder DisableAutomaticTokenRefresh();

    /// <summary>
    /// Don't trust any system root certificates, only trust the certificates
    /// provided through
    /// [`add_root_certificates`][ClientBuilder::add_root_certificates].
    /// </summary>
    ClientBuilder DisableBuiltInRootCertificates();
    ClientBuilder DisableSslVerification();
    ClientBuilder EnableOidcRefreshLock();
    ClientBuilder HomeserverUrl(string @url);
    ClientBuilder Proxy(string @url);

    /// <summary>
    /// Add a default request config to this client.
    /// </summary>
    ClientBuilder RequestConfig(RequestConfig @config);

    /// <summary>
    /// Set the trust requirement to be used when decrypting events.
    /// </summary>
    ClientBuilder RoomDecryptionTrustRequirement(TrustRequirement @trustRequirement);

    /// <summary>
    /// Set the strategy to be used for picking recipient devices when sending
    /// an encrypted message.
    /// </summary>
    ClientBuilder RoomKeyRecipientStrategy(CollectStrategy @strategy);
    ClientBuilder ServerName(string @serverName);
    ClientBuilder ServerNameOrHomeserverUrl(string @serverNameOrUrl);

    /// <summary>
    /// Set the cache size for the SQLite stores given to
    /// [`ClientBuilder::session_paths`].
    ///
    /// Each store exposes a SQLite connection. This method controls the cache
    /// size, in **bytes (!)**.
    ///
    /// The cache represents data SQLite holds in memory at once per open
    /// database file. The default cache implementation does not allocate the
    /// full amount of cache memory all at once. Cache memory is allocated
    /// in smaller chunks on an as-needed basis.
    ///
    /// See [`SqliteStoreConfig::cache_size`] to learn more.
    /// </summary>
    ClientBuilder SessionCacheSize(uint? @cacheSize);

    /// <summary>
    /// Set the size limit for the SQLite WAL files of stores given to
    /// [`ClientBuilder::session_paths`].
    ///
    /// Each store uses the WAL journal mode. This method controls the size
    /// limit of the WAL files, in **bytes (!)**.
    ///
    /// See [`SqliteStoreConfig::journal_size_limit`] to learn more.
    /// </summary>
    ClientBuilder SessionJournalSizeLimit(uint? @limit);

    /// <summary>
    /// Set the passphrase for the stores given to
    /// [`ClientBuilder::session_paths`].
    /// </summary>
    ClientBuilder SessionPassphrase(string? @passphrase);

    /// <summary>
    /// Sets the paths that the client will use to store its data and caches.
    /// Both paths **must** be unique per session as the SDK stores aren't
    /// capable of handling multiple users, however it is valid to use the
    /// same path for both stores on a single session.
    ///
    /// Leaving this unset tells the client to use an in-memory data store.
    /// </summary>
    ClientBuilder SessionPaths(string @dataPath, string @cachePath);

    /// <summary>
    /// Set the pool max size for the SQLite stores given to
    /// [`ClientBuilder::session_paths`].
    ///
    /// Each store exposes an async pool of connections. This method controls
    /// the size of the pool. The larger the pool is, the more memory is
    /// consumed, but also the more the app is reactive because it doesn't need
    /// to wait on a pool to be available to run queries.
    ///
    /// See [`SqliteStoreConfig::pool_max_size`] to learn more.
    /// </summary>
    ClientBuilder SessionPoolMaxSize(uint? @poolMaxSize);
    ClientBuilder SetSessionDelegate(ClientSessionDelegate @sessionDelegate);
    ClientBuilder SlidingSyncVersionBuilder(SlidingSyncVersionBuilder @versionBuilder);

    /// <summary>
    /// Tell the client that the system is memory constrained, like in a push
    /// notification process for example.
    ///
    /// So far, at the time of writing (2025-04-07), it changes the defaults of
    /// [`SqliteStoreConfig`], so one might not need to call
    /// [`ClientBuilder::session_cache_size`] and siblings for example. Please
    /// check [`SqliteStoreConfig::with_low_memory_config`].
    /// </summary>
    ClientBuilder SystemIsMemoryConstrained();

    /// <summary>
    /// Whether to use the event cache persistent storage or not.
    ///
    /// This is a temporary feature flag, for testing the event cache's
    /// persistent storage. Follow new developments in https://github.com/matrix-org/matrix-rust-sdk/issues/3280.
    ///
    /// This is disabled by default. When disabled, a one-time cleanup is
    /// performed when creating the client, and it will clear all the events
    /// previously stored in the event cache.
    ///
    /// When enabled, it will attempt to store events in the event cache as
    /// they're received, and reuse them when reconstructing timelines.
    /// </summary>
    ClientBuilder UseEventCachePersistentStorage(bool @value);
    ClientBuilder UserAgent(string @userAgent);
    ClientBuilder Username(string @username);
}

internal class ClientBuilder : IClientBuilder, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public ClientBuilder(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~ClientBuilder()
    {
        Destroy();
    }

    public ClientBuilder()
        : this(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(ref _status)
            )
        ) { }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_clientbuilder(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public ClientBuilder AddRootCertificates(List<byte[]> @certificates)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
                            thisPtr,
                            FfiConverterSequenceByteArray.INSTANCE.Lower(@certificates),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Automatically create a backup version if no backup exists.
    /// </summary>
    public ClientBuilder AutoEnableBackups(bool @autoEnableBackups)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
                            thisPtr,
                            FfiConverterBoolean.INSTANCE.Lower(@autoEnableBackups),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder AutoEnableCrossSigning(bool @autoEnableCrossSigning)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
                            thisPtr,
                            FfiConverterBoolean.INSTANCE.Lower(@autoEnableCrossSigning),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Select a strategy to download room keys from the backup. By default
    /// we download after a decryption failure.
    ///
    /// Take a look at the [`BackupDownloadStrategy`] enum for more options.
    /// </summary>
    public ClientBuilder BackupDownloadStrategy(BackupDownloadStrategy @backupDownloadStrategy)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
                            thisPtr,
                            FfiConverterTypeBackupDownloadStrategy.INSTANCE.Lower(@backupDownloadStrategy),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="ClientBuildException"></exception>
    public async Task<Client> Build()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeClient.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientBuildError.INSTANCE
        );
    }

    /// <summary>
    /// Finish the building of the client and attempt to log in using the
    /// provided [`QrCodeData`].
    ///
    /// This method will build the client and immediately attempt to log the
    /// client in using the provided [`QrCodeData`] using the login
    /// mechanism described in [MSC4108]. As such this methods requires OAuth
    /// 2.0 support as well as sliding sync support.
    ///
    /// The usage of the progress_listener is required to transfer the
    /// [`CheckCode`] to the existing client.
    ///
    /// [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
    /// </summary>
    /// <exception cref="HumanQrLoginException"></exception>
    public async Task<Client> BuildWithQrCode(
        QrCodeData @qrCodeData,
        OidcConfiguration @oidcConfiguration,
        QrLoginProgressListener @progressListener
    )
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build_with_qr_code(
                    thisPtr,
                    FfiConverterTypeQrCodeData.INSTANCE.Lower(@qrCodeData),
                    FfiConverterTypeOidcConfiguration.INSTANCE.Lower(@oidcConfiguration),
                    FfiConverterTypeQrLoginProgressListener.INSTANCE.Lower(@progressListener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeClient.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeHumanQrLoginError.INSTANCE
        );
    }

    public ClientBuilder CrossProcessStoreLocksHolderName(string @holderName)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@holderName),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder DisableAutomaticTokenRefresh()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Don't trust any system root certificates, only trust the certificates
    /// provided through
    /// [`add_root_certificates`][ClientBuilder::add_root_certificates].
    /// </summary>
    public ClientBuilder DisableBuiltInRootCertificates()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder DisableSslVerification()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder EnableOidcRefreshLock()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder HomeserverUrl(string @url)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@url),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder Proxy(string @url)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@url),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Add a default request config to this client.
    /// </summary>
    public ClientBuilder RequestConfig(RequestConfig @config)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
                            thisPtr,
                            FfiConverterTypeRequestConfig.INSTANCE.Lower(@config),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Set the trust requirement to be used when decrypting events.
    /// </summary>
    public ClientBuilder RoomDecryptionTrustRequirement(TrustRequirement @trustRequirement)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_decryption_trust_requirement(
                            thisPtr,
                            FfiConverterTypeTrustRequirement.INSTANCE.Lower(@trustRequirement),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Set the strategy to be used for picking recipient devices when sending
    /// an encrypted message.
    /// </summary>
    public ClientBuilder RoomKeyRecipientStrategy(CollectStrategy @strategy)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
                            thisPtr,
                            FfiConverterTypeCollectStrategy.INSTANCE.Lower(@strategy),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder ServerName(string @serverName)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@serverName),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder ServerNameOrHomeserverUrl(string @serverNameOrUrl)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@serverNameOrUrl),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Set the cache size for the SQLite stores given to
    /// [`ClientBuilder::session_paths`].
    ///
    /// Each store exposes a SQLite connection. This method controls the cache
    /// size, in **bytes (!)**.
    ///
    /// The cache represents data SQLite holds in memory at once per open
    /// database file. The default cache implementation does not allocate the
    /// full amount of cache memory all at once. Cache memory is allocated
    /// in smaller chunks on an as-needed basis.
    ///
    /// See [`SqliteStoreConfig::cache_size`] to learn more.
    /// </summary>
    public ClientBuilder SessionCacheSize(uint? @cacheSize)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_cache_size(
                            thisPtr,
                            FfiConverterOptionalUInt32.INSTANCE.Lower(@cacheSize),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Set the size limit for the SQLite WAL files of stores given to
    /// [`ClientBuilder::session_paths`].
    ///
    /// Each store uses the WAL journal mode. This method controls the size
    /// limit of the WAL files, in **bytes (!)**.
    ///
    /// See [`SqliteStoreConfig::journal_size_limit`] to learn more.
    /// </summary>
    public ClientBuilder SessionJournalSizeLimit(uint? @limit)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_journal_size_limit(
                            thisPtr,
                            FfiConverterOptionalUInt32.INSTANCE.Lower(@limit),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Set the passphrase for the stores given to
    /// [`ClientBuilder::session_paths`].
    /// </summary>
    public ClientBuilder SessionPassphrase(string? @passphrase)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_passphrase(
                            thisPtr,
                            FfiConverterOptionalString.INSTANCE.Lower(@passphrase),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Sets the paths that the client will use to store its data and caches.
    /// Both paths **must** be unique per session as the SDK stores aren't
    /// capable of handling multiple users, however it is valid to use the
    /// same path for both stores on a single session.
    ///
    /// Leaving this unset tells the client to use an in-memory data store.
    /// </summary>
    public ClientBuilder SessionPaths(string @dataPath, string @cachePath)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@dataPath),
                            FfiConverterString.INSTANCE.Lower(@cachePath),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Set the pool max size for the SQLite stores given to
    /// [`ClientBuilder::session_paths`].
    ///
    /// Each store exposes an async pool of connections. This method controls
    /// the size of the pool. The larger the pool is, the more memory is
    /// consumed, but also the more the app is reactive because it doesn't need
    /// to wait on a pool to be available to run queries.
    ///
    /// See [`SqliteStoreConfig::pool_max_size`] to learn more.
    /// </summary>
    public ClientBuilder SessionPoolMaxSize(uint? @poolMaxSize)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_pool_max_size(
                            thisPtr,
                            FfiConverterOptionalUInt32.INSTANCE.Lower(@poolMaxSize),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder SetSessionDelegate(ClientSessionDelegate @sessionDelegate)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
                            thisPtr,
                            FfiConverterTypeClientSessionDelegate.INSTANCE.Lower(@sessionDelegate),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder SlidingSyncVersionBuilder(SlidingSyncVersionBuilder @versionBuilder)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
                            thisPtr,
                            FfiConverterTypeSlidingSyncVersionBuilder.INSTANCE.Lower(@versionBuilder),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Tell the client that the system is memory constrained, like in a push
    /// notification process for example.
    ///
    /// So far, at the time of writing (2025-04-07), it changes the defaults of
    /// [`SqliteStoreConfig`], so one might not need to call
    /// [`ClientBuilder::session_cache_size`] and siblings for example. Please
    /// check [`SqliteStoreConfig::with_low_memory_config`].
    /// </summary>
    public ClientBuilder SystemIsMemoryConstrained()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Whether to use the event cache persistent storage or not.
    ///
    /// This is a temporary feature flag, for testing the event cache's
    /// persistent storage. Follow new developments in https://github.com/matrix-org/matrix-rust-sdk/issues/3280.
    ///
    /// This is disabled by default. When disabled, a one-time cleanup is
    /// performed when creating the client, and it will clear all the events
    /// previously stored in the event cache.
    ///
    /// When enabled, it will attempt to store events in the event cache as
    /// they're received, and reuse them when reconstructing timelines.
    /// </summary>
    public ClientBuilder UseEventCachePersistentStorage(bool @value)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_use_event_cache_persistent_storage(
                            thisPtr,
                            FfiConverterBoolean.INSTANCE.Lower(@value),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder UserAgent(string @userAgent)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@userAgent),
                            ref _status
                        )
                )
            )
        );
    }

    public ClientBuilder Username(string @username)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeClientBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@username),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeClientBuilder : FfiConverter<ClientBuilder, IntPtr>
{
    public static FfiConverterTypeClientBuilder INSTANCE = new FfiConverterTypeClientBuilder();

    public override IntPtr Lower(ClientBuilder value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override ClientBuilder Lift(IntPtr value)
    {
        return new ClientBuilder(value);
    }

    public override ClientBuilder Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(ClientBuilder value)
    {
        return 8;
    }

    public override void Write(ClientBuilder value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IEncryption
{
    /// <summary>
    /// Does a backup exist on the server?
    ///
    /// Because the homeserver doesn't notify us about changes to the backup
    /// version, the [`BackupState`] and its listener are a bit crippled.
    /// The `BackupState::Unknown` state might mean there is no backup at all or
    /// a backup exists but we don't have access to it.
    ///
    /// Therefore it is necessary to poll the server for an answer every time
    /// you want to differentiate between those two states.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> BackupExistsOnServer();
    BackupState BackupState();
    TaskHandle BackupStateListener(BackupStateListener @listener);

    /// <summary>
    /// Get the public curve25519 key of our own device in base64. This is
    /// usually what is called the identity key of the device.
    /// </summary>
    Task<string?> Curve25519Key();

    /// <exception cref="RecoveryException"></exception>
    Task DisableRecovery();

    /// <summary>
    /// Get the public ed25519 key of our own device. This is usually what is
    /// called the fingerprint of the device.
    /// </summary>
    Task<string?> Ed25519Key();

    /// <exception cref="RecoveryException"></exception>
    Task EnableBackups();

    /// <exception cref="RecoveryException"></exception>
    Task<string> EnableRecovery(
        bool @waitForBackupsToUpload,
        string? @passphrase,
        EnableRecoveryProgressListener @progressListener
    );

    /// <exception cref="RecoveryException"></exception>
    Task<bool> IsLastDevice();

    /// <exception cref="RecoveryException"></exception>
    Task Recover(string @recoveryKey);

    /// <exception cref="RecoveryException"></exception>
    Task<string> RecoverAndReset(string @oldRecoveryKey);
    RecoveryState RecoveryState();
    TaskHandle RecoveryStateListener(RecoveryStateListener @listener);

    /// <summary>
    /// Completely reset the current user's crypto identity: reset the cross
    /// signing keys, delete the existing backup and recovery key.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<IdentityResetHandle?> ResetIdentity();

    /// <exception cref="RecoveryException"></exception>
    Task<string> ResetRecoveryKey();

    /// <summary>
    /// Get the E2EE identity of a user.
    ///
    /// This method always tries to fetch the identity from the store, which we
    /// only have if the user is tracked, meaning that we are both members
    /// of the same encrypted room. If no user is found locally, a request will
    /// be made to the homeserver.
    ///
    /// # Arguments
    ///
    /// * `user_id` - The ID of the user that the identity belongs to.
    ///
    /// Returns a `UserIdentity` if one is found. Returns an error if there
    /// was an issue with the crypto store or with the request to the
    /// homeserver.
    ///
    /// This will always return `None` if the client hasn't been logged in.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<UserIdentity?> UserIdentity(string @userId);
    VerificationState VerificationState();
    TaskHandle VerificationStateListener(VerificationStateListener @listener);

    /// <exception cref="SteadyStateException"></exception>
    Task WaitForBackupUploadSteadyState(BackupSteadyStateListener? @progressListener);

    /// <summary>
    /// Waits for end-to-end encryption initialization tasks to finish, if any
    /// was running in the background.
    /// </summary>
    Task WaitForE2eeInitializationTasks();
}

internal class Encryption : IEncryption, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Encryption(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~Encryption()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_encryption(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_encryption(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Does a backup exist on the server?
    ///
    /// Because the homeserver doesn't notify us about changes to the backup
    /// version, the [`BackupState`] and its listener are a bit crippled.
    /// The `BackupState::Unknown` state might mean there is no backup at all or
    /// a backup exists but we don't have access to it.
    ///
    /// Therefore it is necessary to poll the server for an answer every time
    /// you want to differentiate between those two states.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> BackupExistsOnServer()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public BackupState BackupState()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeBackupState.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(thisPtr, ref _status)
                )
            )
        );
    }

    public TaskHandle BackupStateListener(BackupStateListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
                            thisPtr,
                            FfiConverterTypeBackupStateListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Get the public curve25519 key of our own device in base64. This is
    /// usually what is called the identity key of the device.
    /// </summary>
    public async Task<string?> Curve25519Key()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task DisableRecovery()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    /// <summary>
    /// Get the public ed25519 key of our own device. This is usually what is
    /// called the fingerprint of the device.
    /// </summary>
    public async Task<string?> Ed25519Key()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task EnableBackups()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task<string> EnableRecovery(
        bool @waitForBackupsToUpload,
        string? @passphrase,
        EnableRecoveryProgressListener @progressListener
    )
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@waitForBackupsToUpload),
                    FfiConverterOptionalString.INSTANCE.Lower(@passphrase),
                    FfiConverterTypeEnableRecoveryProgressListener.INSTANCE.Lower(@progressListener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task<bool> IsLastDevice()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task Recover(string @recoveryKey)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@recoveryKey)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task<string> RecoverAndReset(string @oldRecoveryKey)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@oldRecoveryKey)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    public RecoveryState RecoveryState()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRecoveryState.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(thisPtr, ref _status)
                )
            )
        );
    }

    public TaskHandle RecoveryStateListener(RecoveryStateListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
                            thisPtr,
                            FfiConverterTypeRecoveryStateListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Completely reset the current user's crypto identity: reset the cross
    /// signing keys, delete the existing backup and recovery key.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<IdentityResetHandle?> ResetIdentity()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeIdentityResetHandle.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="RecoveryException"></exception>
    public async Task<string> ResetRecoveryKey()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeRecoveryError.INSTANCE
        );
    }

    /// <summary>
    /// Get the E2EE identity of a user.
    ///
    /// This method always tries to fetch the identity from the store, which we
    /// only have if the user is tracked, meaning that we are both members
    /// of the same encrypted room. If no user is found locally, a request will
    /// be made to the homeserver.
    ///
    /// # Arguments
    ///
    /// * `user_id` - The ID of the user that the identity belongs to.
    ///
    /// Returns a `UserIdentity` if one is found. Returns an error if there
    /// was an issue with the crypto store or with the request to the
    /// homeserver.
    ///
    /// This will always return `None` if the client hasn't been logged in.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<UserIdentity?> UserIdentity(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeUserIdentity.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public VerificationState VerificationState()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeVerificationState.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(thisPtr, ref _status)
                )
            )
        );
    }

    public TaskHandle VerificationStateListener(VerificationStateListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
                            thisPtr,
                            FfiConverterTypeVerificationStateListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="SteadyStateException"></exception>
    public async Task WaitForBackupUploadSteadyState(BackupSteadyStateListener? @progressListener)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
                    thisPtr,
                    FfiConverterOptionalTypeBackupSteadyStateListener.INSTANCE.Lower(@progressListener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeSteadyStateError.INSTANCE
        );
    }

    /// <summary>
    /// Waits for end-to-end encryption initialization tasks to finish, if any
    /// was running in the background.
    /// </summary>
    public async Task WaitForE2eeInitializationTasks()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }
}

class FfiConverterTypeEncryption : FfiConverter<Encryption, IntPtr>
{
    public static FfiConverterTypeEncryption INSTANCE = new FfiConverterTypeEncryption();

    public override IntPtr Lower(Encryption value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Encryption Lift(IntPtr value)
    {
        return new Encryption(value);
    }

    public override Encryption Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Encryption value)
    {
        return 8;
    }

    public override void Write(Encryption value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IHomeserverLoginDetails
{
    /// <summary>
    /// The sliding sync version.
    /// </summary>
    SlidingSyncVersion SlidingSyncVersion();

    /// <summary>
    /// The prompts advertised by the authentication issuer for use in the login
    /// URL.
    /// </summary>
    List<OidcPrompt> SupportedOidcPrompts();

    /// <summary>
    /// Whether the current homeserver supports login using OIDC.
    /// </summary>
    bool SupportsOidcLogin();

    /// <summary>
    /// Whether the current homeserver supports the password login flow.
    /// </summary>
    bool SupportsPasswordLogin();

    /// <summary>
    /// The URL of the currently configured homeserver.
    /// </summary>
    string Url();
}

internal class HomeserverLoginDetails : IHomeserverLoginDetails, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public HomeserverLoginDetails(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~HomeserverLoginDetails()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// The sliding sync version.
    /// </summary>
    public SlidingSyncVersion SlidingSyncVersion()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSlidingSyncVersion.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// The prompts advertised by the authentication issuer for use in the login
    /// URL.
    /// </summary>
    public List<OidcPrompt> SupportedOidcPrompts()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterSequenceTypeOidcPrompt.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Whether the current homeserver supports login using OIDC.
    /// </summary>
    public bool SupportsOidcLogin()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Whether the current homeserver supports the password login flow.
    /// </summary>
    public bool SupportsPasswordLogin()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// The URL of the currently configured homeserver.
    /// </summary>
    public string Url()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeHomeserverLoginDetails : FfiConverter<HomeserverLoginDetails, IntPtr>
{
    public static FfiConverterTypeHomeserverLoginDetails INSTANCE = new FfiConverterTypeHomeserverLoginDetails();

    public override IntPtr Lower(HomeserverLoginDetails value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override HomeserverLoginDetails Lift(IntPtr value)
    {
        return new HomeserverLoginDetails(value);
    }

    public override HomeserverLoginDetails Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(HomeserverLoginDetails value)
    {
        return 8;
    }

    public override void Write(HomeserverLoginDetails value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IIdentityResetHandle
{
    /// <summary>
    /// Get the underlying [`CrossSigningResetAuthType`] this identity reset
    /// process is using.
    /// </summary>
    CrossSigningResetAuthType AuthType();
    Task Cancel();

    /// <summary>
    /// This method starts the identity reset process and
    /// will go through the following steps:
    ///
    /// 1. Disable backing up room keys and delete the active backup
    /// 2. Disable recovery and delete secret storage
    /// 3. Go through the cross-signing key reset flow
    /// 4. Finally, re-enable key backups only if they were enabled before
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Reset(AuthData? @auth);
}

internal class IdentityResetHandle : IIdentityResetHandle, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public IdentityResetHandle(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~IdentityResetHandle()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_identityresethandle(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Get the underlying [`CrossSigningResetAuthType`] this identity reset
    /// process is using.
    /// </summary>
    public CrossSigningResetAuthType AuthType()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeCrossSigningResetAuthType.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(thisPtr, ref _status)
                )
            )
        );
    }

    public async Task Cancel()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// This method starts the identity reset process and
    /// will go through the following steps:
    ///
    /// 1. Disable backing up room keys and delete the active backup
    /// 2. Disable recovery and delete secret storage
    /// 3. Go through the cross-signing key reset flow
    /// 4. Finally, re-enable key backups only if they were enabled before
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Reset(AuthData? @auth)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
                    thisPtr,
                    FfiConverterOptionalTypeAuthData.INSTANCE.Lower(@auth)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeIdentityResetHandle : FfiConverter<IdentityResetHandle, IntPtr>
{
    public static FfiConverterTypeIdentityResetHandle INSTANCE = new FfiConverterTypeIdentityResetHandle();

    public override IntPtr Lower(IdentityResetHandle value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override IdentityResetHandle Lift(IntPtr value)
    {
        return new IdentityResetHandle(value);
    }

    public override IdentityResetHandle Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(IdentityResetHandle value)
    {
        return 8;
    }

    public override void Write(IdentityResetHandle value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IInReplyToDetails
{
    RepliedToEventDetails Event();
    string EventId();
}

internal class InReplyToDetails : IInReplyToDetails, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public InReplyToDetails(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~InReplyToDetails()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public RepliedToEventDetails Event()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRepliedToEventDetails.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(thisPtr, ref _status)
                )
            )
        );
    }

    public string EventId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeInReplyToDetails : FfiConverter<InReplyToDetails, IntPtr>
{
    public static FfiConverterTypeInReplyToDetails INSTANCE = new FfiConverterTypeInReplyToDetails();

    public override IntPtr Lower(InReplyToDetails value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override InReplyToDetails Lift(IntPtr value)
    {
        return new InReplyToDetails(value);
    }

    public override InReplyToDetails Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(InReplyToDetails value)
    {
        return 8;
    }

    public override void Write(InReplyToDetails value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A set of actions to perform for a knock request.
/// </summary>
internal interface IKnockRequestActions
{
    /// <summary>
    /// Accepts the knock request by inviting the user to the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Accept();

    /// <summary>
    /// Declines the knock request by kicking the user from the room with an
    /// optional reason.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Decline(string? @reason);

    /// <summary>
    /// Declines the knock request by banning the user from the room with an
    /// optional reason.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task DeclineAndBan(string? @reason);

    /// <summary>
    /// Marks the knock request as 'seen'.
    ///
    /// **IMPORTANT**: this won't update the current reference to this request,
    /// a new one with the updated value should be emitted instead.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task MarkAsSeen();
}

/// <summary>
/// A set of actions to perform for a knock request.
/// </summary>
internal class KnockRequestActions : IKnockRequestActions, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public KnockRequestActions(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~KnockRequestActions()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Accepts the knock request by inviting the user to the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Accept()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Declines the knock request by kicking the user from the room with an
    /// optional reason.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Decline(string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
                    thisPtr,
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Declines the knock request by banning the user from the room with an
    /// optional reason.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task DeclineAndBan(string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
                    thisPtr,
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Marks the knock request as 'seen'.
    ///
    /// **IMPORTANT**: this won't update the current reference to this request,
    /// a new one with the updated value should be emitted instead.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task MarkAsSeen()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeKnockRequestActions : FfiConverter<KnockRequestActions, IntPtr>
{
    public static FfiConverterTypeKnockRequestActions INSTANCE = new FfiConverterTypeKnockRequestActions();

    public override IntPtr Lower(KnockRequestActions value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override KnockRequestActions Lift(IntPtr value)
    {
        return new KnockRequestActions(value);
    }

    public override KnockRequestActions Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(KnockRequestActions value)
    {
        return 8;
    }

    public override void Write(KnockRequestActions value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// Wrapper to retrieve some timeline item info lazily.
/// </summary>
internal interface ILazyTimelineItemProvider
{
    bool ContainsOnlyEmojis();

    /// <summary>
    /// Returns some debug information for this event timeline item.
    /// </summary>
    EventTimelineItemDebugInfo DebugInfo();

    /// <summary>
    /// For local echoes, return the associated send handle; returns `None` for
    /// remote echoes.
    /// </summary>
    SendHandle? GetSendHandle();

    /// <summary>
    /// Returns the shields for this event timeline item.
    /// </summary>
    ShieldState? GetShields(bool @strict);
}

/// <summary>
/// Wrapper to retrieve some timeline item info lazily.
/// </summary>
internal class LazyTimelineItemProvider : ILazyTimelineItemProvider, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public LazyTimelineItemProvider(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~LazyTimelineItemProvider()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public bool ContainsOnlyEmojis()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Returns some debug information for this event timeline item.
    /// </summary>
    public EventTimelineItemDebugInfo DebugInfo()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeEventTimelineItemDebugInfo.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// For local echoes, return the associated send handle; returns `None` for
    /// remote echoes.
    /// </summary>
    public SendHandle? GetSendHandle()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeSendHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Returns the shields for this event timeline item.
    /// </summary>
    public ShieldState? GetShields(bool @strict)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeShieldState.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
                            thisPtr,
                            FfiConverterBoolean.INSTANCE.Lower(@strict),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeLazyTimelineItemProvider : FfiConverter<LazyTimelineItemProvider, IntPtr>
{
    public static FfiConverterTypeLazyTimelineItemProvider INSTANCE = new FfiConverterTypeLazyTimelineItemProvider();

    public override IntPtr Lower(LazyTimelineItemProvider value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override LazyTimelineItemProvider Lift(IntPtr value)
    {
        return new LazyTimelineItemProvider(value);
    }

    public override LazyTimelineItemProvider Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(LazyTimelineItemProvider value)
    {
        return 8;
    }

    public override void Write(LazyTimelineItemProvider value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A file handle that takes ownership of a media file on disk. When the handle
/// is dropped, the file will be removed from the disk.
/// </summary>
internal interface IMediaFileHandle
{
    /// <summary>
    /// Get the media file's path.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    string Path();

    /// <exception cref="ClientException"></exception>
    bool Persist(string @path);
}

/// <summary>
/// A file handle that takes ownership of a media file on disk. When the handle
/// is dropped, the file will be removed from the disk.
/// </summary>
internal class MediaFileHandle : IMediaFileHandle, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public MediaFileHandle(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~MediaFileHandle()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Get the media file's path.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public string Path()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public bool Persist(string @path)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@path),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeMediaFileHandle : FfiConverter<MediaFileHandle, IntPtr>
{
    public static FfiConverterTypeMediaFileHandle INSTANCE = new FfiConverterTypeMediaFileHandle();

    public override IntPtr Lower(MediaFileHandle value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override MediaFileHandle Lift(IntPtr value)
    {
        return new MediaFileHandle(value);
    }

    public override MediaFileHandle Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(MediaFileHandle value)
    {
        return 8;
    }

    public override void Write(MediaFileHandle value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IMediaSource
{
    string ToJson();
    string Url();
}

internal class MediaSource : IMediaSource, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public MediaSource(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~MediaSource()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_mediasource(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_mediasource(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public string ToJson()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(thisPtr, ref _status)
                )
            )
        );
    }

    public string Url()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_mediasource_url(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public static MediaSource FromJson(string @json)
    {
        return new MediaSource(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
                        FfiConverterString.INSTANCE.Lower(@json),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public static MediaSource FromUrl(string @url)
    {
        return new MediaSource(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
                        FfiConverterString.INSTANCE.Lower(@url),
                        ref _status
                    )
            )
        );
    }
}

class FfiConverterTypeMediaSource : FfiConverter<MediaSource, IntPtr>
{
    public static FfiConverterTypeMediaSource INSTANCE = new FfiConverterTypeMediaSource();

    public override IntPtr Lower(MediaSource value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override MediaSource Lift(IntPtr value)
    {
        return new MediaSource(value);
    }

    public override MediaSource Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(MediaSource value)
    {
        return 8;
    }

    public override void Write(MediaSource value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface INotificationClient
{
    /// <summary>
    /// See also documentation of
    /// `MatrixNotificationClient::get_notification`.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<NotificationItem?> GetNotification(string @roomId, string @eventId);
}

internal class NotificationClient : INotificationClient, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public NotificationClient(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~NotificationClient()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_notificationclient(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_notificationclient(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// See also documentation of
    /// `MatrixNotificationClient::get_notification`.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<NotificationItem?> GetNotification(string @roomId, string @eventId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId),
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeNotificationItem.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeNotificationClient : FfiConverter<NotificationClient, IntPtr>
{
    public static FfiConverterTypeNotificationClient INSTANCE = new FfiConverterTypeNotificationClient();

    public override IntPtr Lower(NotificationClient value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override NotificationClient Lift(IntPtr value)
    {
        return new NotificationClient(value);
    }

    public override NotificationClient Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(NotificationClient value)
    {
        return 8;
    }

    public override void Write(NotificationClient value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface INotificationSettings
{
    /// <summary>
    /// Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
    ///
    /// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
    /// </summary>
    Task<bool> CanHomeserverPushEncryptedEventToDevice();

    /// <summary>
    /// Returns true if [MSC 4028 push rule][rule] is supported and enabled.
    ///
    /// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
    /// </summary>
    Task<bool> CanPushEncryptedEventToDevice();

    /// <summary>
    /// Get whether some enabled keyword rules exist.
    /// </summary>
    Task<bool> ContainsKeywordsRules();

    /// <summary>
    /// Get the default room notification mode
    ///
    /// The mode will depend on the associated `PushRule` based on whether the
    /// room is encrypted or not, and on the number of members.
    ///
    /// # Arguments
    ///
    /// * `is_encrypted` - whether the room is encrypted
    /// * `is_one_to_one` - whether the room is a direct chats involving two
    /// people
    /// </summary>
    Task<RoomNotificationMode> GetDefaultRoomNotificationMode(bool @isEncrypted, bool @isOneToOne);

    /// <summary>
    /// Get the notification settings for a room.
    ///
    /// # Arguments
    ///
    /// * `room_id` - the room ID
    /// * `is_encrypted` - whether the room is encrypted
    /// * `is_one_to_one` - whether the room is a direct chat involving two
    /// people
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task<RoomNotificationSettings> GetRoomNotificationSettings(string @roomId, bool @isEncrypted, bool @isOneToOne);

    /// <summary>
    /// Get all room IDs for which a user-defined rule exists.
    /// </summary>
    Task<List<string>> GetRoomsWithUserDefinedRules(bool? @enabled);

    /// <summary>
    /// Get the user defined room notification mode
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task<RoomNotificationMode?> GetUserDefinedRoomNotificationMode(string @roomId);

    /// <summary>
    /// Get whether the `.m.rule.call` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task<bool> IsCallEnabled();

    /// <summary>
    /// Get whether the `.m.rule.invite_for_me` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task<bool> IsInviteForMeEnabled();

    /// <summary>
    /// Get whether room mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task<bool> IsRoomMentionEnabled();

    /// <summary>
    /// Get whether user mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task<bool> IsUserMentionEnabled();

    /// <summary>
    /// Restore the default notification mode for a room
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task RestoreDefaultRoomNotificationMode(string @roomId);

    /// <summary>
    /// Set whether the `.m.rule.call` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetCallEnabled(bool @enabled);

    /// <summary>
    /// Sets a custom push rule with the given actions and conditions.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetCustomPushRule(string @ruleId, RuleKind @ruleKind, List<Action> @actions, List<PushCondition> @conditions);

    /// <summary>
    /// Set the default room notification mode
    ///
    /// # Arguments
    ///
    /// * `is_encrypted` - whether the mode is for encrypted rooms
    /// * `is_one_to_one` - whether the mode is for direct chats involving two
    /// people
    /// * `mode` - the new default mode
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetDefaultRoomNotificationMode(bool @isEncrypted, bool @isOneToOne, RoomNotificationMode @mode);
    void SetDelegate(NotificationSettingsDelegate? @delegate);

    /// <summary>
    /// Set whether the `.m.rule.invite_for_me` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetInviteForMeEnabled(bool @enabled);

    /// <summary>
    /// Set whether room mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetRoomMentionEnabled(bool @enabled);

    /// <summary>
    /// Set the notification mode for a room.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetRoomNotificationMode(string @roomId, RoomNotificationMode @mode);

    /// <summary>
    /// Set whether user mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task SetUserMentionEnabled(bool @enabled);

    /// <summary>
    /// Unmute a room.
    ///
    /// # Arguments
    ///
    /// * `room_id` - the room to unmute
    /// * `is_encrypted` - whether the room is encrypted
    /// * `is_one_to_one` - whether the room is a direct chat involving two
    /// people
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    Task UnmuteRoom(string @roomId, bool @isEncrypted, bool @isOneToOne);
}

internal class NotificationSettings : INotificationSettings, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public NotificationSettings(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~NotificationSettings()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_notificationsettings(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
    ///
    /// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
    /// </summary>
    public async Task<bool> CanHomeserverPushEncryptedEventToDevice()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Returns true if [MSC 4028 push rule][rule] is supported and enabled.
    ///
    /// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
    /// </summary>
    public async Task<bool> CanPushEncryptedEventToDevice()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Get whether some enabled keyword rules exist.
    /// </summary>
    public async Task<bool> ContainsKeywordsRules()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Get the default room notification mode
    ///
    /// The mode will depend on the associated `PushRule` based on whether the
    /// room is encrypted or not, and on the number of members.
    ///
    /// # Arguments
    ///
    /// * `is_encrypted` - whether the room is encrypted
    /// * `is_one_to_one` - whether the room is a direct chats involving two
    /// people
    /// </summary>
    public async Task<RoomNotificationMode> GetDefaultRoomNotificationMode(bool @isEncrypted, bool @isOneToOne)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@isEncrypted),
                    FfiConverterBoolean.INSTANCE.Lower(@isOneToOne)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomNotificationMode.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Get the notification settings for a room.
    ///
    /// # Arguments
    ///
    /// * `room_id` - the room ID
    /// * `is_encrypted` - whether the room is encrypted
    /// * `is_one_to_one` - whether the room is a direct chat involving two
    /// people
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task<RoomNotificationSettings> GetRoomNotificationSettings(
        string @roomId,
        bool @isEncrypted,
        bool @isOneToOne
    )
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId),
                    FfiConverterBoolean.INSTANCE.Lower(@isEncrypted),
                    FfiConverterBoolean.INSTANCE.Lower(@isOneToOne)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomNotificationSettings.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Get all room IDs for which a user-defined rule exists.
    /// </summary>
    public async Task<List<string>> GetRoomsWithUserDefinedRules(bool? @enabled)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
                    thisPtr,
                    FfiConverterOptionalBoolean.INSTANCE.Lower(@enabled)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterSequenceString.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Get the user defined room notification mode
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task<RoomNotificationMode?> GetUserDefinedRoomNotificationMode(string @roomId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeRoomNotificationMode.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Get whether the `.m.rule.call` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task<bool> IsCallEnabled()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Get whether the `.m.rule.invite_for_me` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task<bool> IsInviteForMeEnabled()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Get whether room mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task<bool> IsRoomMentionEnabled()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Get whether user mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task<bool> IsUserMentionEnabled()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Restore the default notification mode for a room
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task RestoreDefaultRoomNotificationMode(string @roomId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Set whether the `.m.rule.call` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetCallEnabled(bool @enabled)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@enabled)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Sets a custom push rule with the given actions and conditions.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetCustomPushRule(
        string @ruleId,
        RuleKind @ruleKind,
        List<Action> @actions,
        List<PushCondition> @conditions
    )
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@ruleId),
                    FfiConverterTypeRuleKind.INSTANCE.Lower(@ruleKind),
                    FfiConverterSequenceTypeAction.INSTANCE.Lower(@actions),
                    FfiConverterSequenceTypePushCondition.INSTANCE.Lower(@conditions)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Set the default room notification mode
    ///
    /// # Arguments
    ///
    /// * `is_encrypted` - whether the mode is for encrypted rooms
    /// * `is_one_to_one` - whether the mode is for direct chats involving two
    /// people
    /// * `mode` - the new default mode
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetDefaultRoomNotificationMode(bool @isEncrypted, bool @isOneToOne, RoomNotificationMode @mode)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@isEncrypted),
                    FfiConverterBoolean.INSTANCE.Lower(@isOneToOne),
                    FfiConverterTypeRoomNotificationMode.INSTANCE.Lower(@mode)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    public void SetDelegate(NotificationSettingsDelegate? @delegate)
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
                        thisPtr,
                        FfiConverterOptionalTypeNotificationSettingsDelegate.INSTANCE.Lower(@delegate),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Set whether the `.m.rule.invite_for_me` push rule is enabled
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetInviteForMeEnabled(bool @enabled)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@enabled)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Set whether room mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetRoomMentionEnabled(bool @enabled)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@enabled)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Set the notification mode for a room.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetRoomNotificationMode(string @roomId, RoomNotificationMode @mode)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId),
                    FfiConverterTypeRoomNotificationMode.INSTANCE.Lower(@mode)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Set whether user mentions are enabled.
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task SetUserMentionEnabled(bool @enabled)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@enabled)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }

    /// <summary>
    /// Unmute a room.
    ///
    /// # Arguments
    ///
    /// * `room_id` - the room to unmute
    /// * `is_encrypted` - whether the room is encrypted
    /// * `is_one_to_one` - whether the room is a direct chat involving two
    /// people
    /// </summary>
    /// <exception cref="NotificationSettingsException"></exception>
    public async Task UnmuteRoom(string @roomId, bool @isEncrypted, bool @isOneToOne)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@roomId),
                    FfiConverterBoolean.INSTANCE.Lower(@isEncrypted),
                    FfiConverterBoolean.INSTANCE.Lower(@isOneToOne)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeNotificationSettingsError.INSTANCE
        );
    }
}

class FfiConverterTypeNotificationSettings : FfiConverter<NotificationSettings, IntPtr>
{
    public static FfiConverterTypeNotificationSettings INSTANCE = new FfiConverterTypeNotificationSettings();

    public override IntPtr Lower(NotificationSettings value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override NotificationSettings Lift(IntPtr value)
    {
        return new NotificationSettings(value);
    }

    public override NotificationSettings Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(NotificationSettings value)
    {
        return 8;
    }

    public override void Write(NotificationSettings value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// Data for the QR code login mechanism.
///
/// The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
/// decoded from a QR code.
/// </summary>
internal interface IQrCodeData { }

/// <summary>
/// Data for the QR code login mechanism.
///
/// The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
/// decoded from a QR code.
/// </summary>
internal class QrCodeData : IQrCodeData, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public QrCodeData(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~QrCodeData()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_qrcodedata(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Attempt to decode a slice of bytes into a [`QrCodeData`] object.
    ///
    /// The slice of bytes would generally be returned by a QR code decoder.
    /// </summary>
    /// <exception cref="QrCodeDecodeException"></exception>
    public static QrCodeData FromBytes(byte[] @bytes)
    {
        return new QrCodeData(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeQrCodeDecodeError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
                        FfiConverterByteArray.INSTANCE.Lower(@bytes),
                        ref _status
                    )
            )
        );
    }
}

class FfiConverterTypeQrCodeData : FfiConverter<QrCodeData, IntPtr>
{
    public static FfiConverterTypeQrCodeData INSTANCE = new FfiConverterTypeQrCodeData();

    public override IntPtr Lower(QrCodeData value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override QrCodeData Lift(IntPtr value)
    {
        return new QrCodeData(value);
    }

    public override QrCodeData Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(QrCodeData value)
    {
        return 8;
    }

    public override void Write(QrCodeData value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoom
{
    ulong ActiveMembersCount();

    /// <summary>
    /// Returns a Vec of userId's that participate in the room call.
    ///
    /// MatrixRTC memberships with application "m.call" and scope "m.room" are
    /// considered. A user can occur twice if they join with two devices.
    /// convert to a set depending if the different users are required or the
    /// amount of sessions.
    ///
    /// The vector is ordered by oldest membership user to newest.
    /// </summary>
    List<string> ActiveRoomCallParticipants();
    List<string> AlternativeAliases();

    /// <exception cref="ClientException"></exception>
    Task ApplyPowerLevelChanges(RoomPowerLevelChanges @changes);
    string? AvatarUrl();

    /// <exception cref="ClientException"></exception>
    Task BanUser(string @userId, string? @reason);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserBan(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserInvite(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserKick(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserPinUnpin(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserRedactOther(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserRedactOwn(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserSendMessage(string @userId, MessageLikeEventType @message);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserSendState(string @userId, StateEventType @stateEvent);

    /// <exception cref="ClientException"></exception>
    Task<bool> CanUserTriggerRoomNotification(string @userId);
    string? CanonicalAlias();

    /// <summary>
    /// Remove the `ComposerDraft` stored in the state store for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ClearComposerDraft();

    /// <summary>
    /// Clear the event cache storage for the current room.
    ///
    /// This will remove all the information related to the event cache, in
    /// memory and in the persisted storage, if enabled.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ClearEventCacheStorage();

    /// <summary>
    /// Forces the currently active room key, which is used to encrypt messages,
    /// to be rotated.
    ///
    /// A new room key will be crated and shared with all the room members the
    /// next time a message will be sent. You don't have to call this method,
    /// room keys will be rotated automatically when necessary. This method is
    /// still useful for debugging purposes.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task DiscardRoomKey();

    /// <summary>
    /// Returns the room's name from the state event if available, otherwise
    /// compute a room name based on the room's nature (DM or not) and number of
    /// members.
    /// </summary>
    string? DisplayName();

    /// <summary>
    /// Edit an event given its event id.
    ///
    /// Useful outside the context of a timeline, or when a timeline doesn't
    /// have the full content of an event.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Edit(string @eventId, RoomMessageEventContentWithoutRelation @newContent);

    /// <summary>
    /// Enable End-to-end encryption in this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task EnableEncryption();

    /// <summary>
    /// Enable or disable the send queue for that particular room.
    /// </summary>
    void EnableSendQueue(bool @enable);
    EncryptionState EncryptionState();

    /// <summary>
    /// Forget this room.
    ///
    /// This communicates to the homeserver that it should forget the room.
    ///
    /// Only left or banned-from rooms can be forgotten.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Forget();

    /// <exception cref="ClientException"></exception>
    Task<RoomPowerLevels> GetPowerLevels();

    /// <summary>
    /// Returns the visibility for this room in the room directory.
    ///
    /// [Public](`RoomVisibility::Public`) rooms are listed in the room
    /// directory and can be found using it.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<RoomVisibility> GetRoomVisibility();

    /// <summary>
    /// Is there a non expired membership with application "m.call" and scope
    /// "m.room" in this room.
    /// </summary>
    bool HasActiveRoomCall();

    /// <summary>
    /// Returns the room heroes for this room.
    /// </summary>
    List<RoomHero> Heroes();
    string Id();

    /// <summary>
    /// Set the local trust for the given devices to `LocalTrust::Ignored`
    /// and resend messages that failed to send because said devices are
    /// unverified (in response to
    /// `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
    /// # Arguments
    ///
    /// * `devices` - The map of users identifiers to device identifiers
    /// received in the error
    /// * `transaction_id` - The send queue transaction identifier of the local
    /// echo the send error applies to
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task IgnoreDeviceTrustAndResend(Dictionary<string, List<string>> @devices, SendHandle @sendHandle);

    /// <summary>
    /// Ignores a user.
    ///
    /// # Arguments
    ///
    /// * `user_id` - The ID of the user to ignore.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task IgnoreUser(string @userId);

    /// <exception cref="ClientException"></exception>
    Task InviteUserById(string @userId);
    ulong InvitedMembersCount();
    Task<bool> IsDirect();
    bool IsPublic();

    /// <summary>
    /// Returns whether the send queue for that particular room is enabled or
    /// not.
    /// </summary>
    bool IsSendQueueEnabled();
    bool IsSpace();
    bool IsTombstoned();

    /// <summary>
    /// Join this room.
    ///
    /// Only invited and left rooms can be joined via this method.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Join();
    ulong JoinedMembersCount();

    /// <exception cref="ClientException"></exception>
    Task KickUser(string @userId, string? @reason);

    /// <exception cref="ClientException"></exception>
    Task<EncryptionState> LatestEncryptionState();

    /// <summary>
    /// Leave this room.
    ///
    /// Only invited and joined rooms can be left.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Leave();

    /// <summary>
    /// Retrieve the `ComposerDraft` stored in the state store for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<ComposerDraft?> LoadComposerDraft();

    /// <summary>
    /// Mark a room as read, by attaching a read receipt on the latest event.
    ///
    /// Note: this does NOT unset the unread flag; it's the caller's
    /// responsibility to do so, if needs be.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task MarkAsRead(ReceiptType @receiptType);

    /// <exception cref="ClientException"></exception>
    Task<string> MatrixToEventPermalink(string @eventId);

    /// <exception cref="ClientException"></exception>
    Task<string> MatrixToPermalink();

    /// <exception cref="ClientException"></exception>
    Task<RoomMember> Member(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<string?> MemberAvatarUrl(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<string?> MemberDisplayName(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<RoomMembersIterator> Members();

    /// <exception cref="ClientException"></exception>
    Task<RoomMembersIterator> MembersNoSync();
    Membership Membership();
    string OwnUserId();

    /// <summary>
    /// Publish a new room alias for this room in the room directory.
    ///
    /// Returns:
    /// - `true` if the room alias didn't exist and it's now published.
    /// - `false` if the room alias was already present so it couldn't be
    /// published.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> PublishRoomAliasInRoomDirectory(string @alias);

    /// <summary>
    /// The raw name as present in the room state event.
    /// </summary>
    string? RawName();

    /// <summary>
    /// Redacts an event from the room.
    ///
    /// # Arguments
    ///
    /// * `event_id` - The ID of the event to redact
    ///
    /// * `reason` - The reason for the event being redacted (optional). its
    /// transaction ID (optional). If not given one is created.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Redact(string @eventId, string? @reason);

    /// <summary>
    /// Removes the current room avatar
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task RemoveAvatar();

    /// <summary>
    /// Remove an existing room alias for this room in the room directory.
    ///
    /// Returns:
    /// - `true` if the room alias was present and it's now removed from the
    /// room directory.
    /// - `false` if the room alias didn't exist so it couldn't be removed.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> RemoveRoomAliasFromRoomDirectory(string @alias);

    /// <summary>
    /// Reports an event from the room.
    ///
    /// # Arguments
    ///
    /// * `event_id` - The ID of the event to report
    ///
    /// * `reason` - The reason for the event being reported (optional).
    ///
    /// * `score` - The score to rate this content as where -100 is most
    /// offensive and 0 is inoffensive (optional).
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ReportContent(string @eventId, int? @score, string? @reason);

    /// <summary>
    /// Reports a room as inappropriate to the server.
    /// The caller is not required to be joined to the room to report it.
    ///
    /// # Arguments
    ///
    /// * `reason` - The reason the room is being reported.
    ///
    /// # Errors
    ///
    /// Returns an error if the room is not found or on rate limit
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ReportRoom(string? @reason);

    /// <exception cref="ClientException"></exception>
    Task<RoomPowerLevels> ResetPowerLevels();

    /// <summary>
    /// Return a debug representation for the internal room events data
    /// structure, one line per entry in the resulting vector.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<List<string>> RoomEventsDebugString();

    /// <exception cref="ClientException"></exception>
    Task<RoomInfo> RoomInfo();

    /// <summary>
    /// Store the given `ComposerDraft` in the state store using the current
    /// room id, as identifier.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SaveComposerDraft(ComposerDraft @draft);

    /// <summary>
    /// Send a call notification event in the current room.
    ///
    /// This is only supposed to be used in **custom** situations where the user
    /// explicitly chooses to send a `m.call.notify` event to invite/notify
    /// someone explicitly in unusual conditions. The default should be to
    /// use `send_call_notification_if_necessary` just before a new room call is
    /// created/joined.
    ///
    /// One example could be that the UI allows to start a call with a subset of
    /// users of the room members first. And then later on the user can
    /// invite more users to the call.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SendCallNotification(
        string @callId,
        RtcApplicationType @application,
        NotifyType @notifyType,
        Mentions @mentions
    );

    /// <summary>
    /// This will only send a call notification event if appropriate.
    ///
    /// This function is supposed to be called whenever the user creates a room
    /// call. It will send a `m.call.notify` event if:
    /// - there is not yet a running call.
    ///
    /// It will configure the notify type: ring or notify based on:
    /// - is this a DM room -> ring
    /// - is this a group with more than one other member -> notify
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SendCallNotificationIfNeeded();

    /// <summary>
    /// Send the current users live location beacon in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SendLiveLocation(string @geoUri);

    /// <summary>
    /// Send a raw event to the room.
    ///
    /// # Arguments
    ///
    /// * `event_type` - The type of the event to send.
    ///
    /// * `content` - The content of the event to send encoded as JSON string.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SendRaw(string @eventType, string @content);

    /// <exception cref="ClientException"></exception>
    Task SetIsFavourite(bool @isFavourite, double? @tagOrder);

    /// <exception cref="ClientException"></exception>
    Task SetIsLowPriority(bool @isLowPriority, double? @tagOrder);

    /// <summary>
    /// Sets a new name to the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SetName(string @name);

    /// <summary>
    /// Sets a new topic in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SetTopic(string @topic);

    /// <summary>
    /// Set (or unset) a flag on the room to indicate that the user has
    /// explicitly marked it as unread.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SetUnreadFlag(bool @newValue);

    /// <summary>
    /// Start the current users live location share in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task StartLiveLocationShare(ulong @durationMillis);

    /// <summary>
    /// Stop the current users live location share in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task StopLiveLocationShare();

    /// <exception cref="ClientException"></exception>
    Task<TaskHandle> SubscribeToIdentityStatusChanges(IdentityStatusChangeListener @listener);

    /// <summary>
    /// Subscribes to requests to join this room (knock member events), using a
    /// `listener` to be notified of the changes.
    ///
    /// The current requests to join the room will be emitted immediately
    /// when subscribing, along with a [`TaskHandle`] to cancel the
    /// subscription.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<TaskHandle> SubscribeToKnockRequests(KnockRequestsListener @listener);

    /// <summary>
    /// Subscribes to live location shares in this room, using a `listener` to
    /// be notified of the changes.
    ///
    /// The current live location shares will be emitted immediately when
    /// subscribing, along with a [`TaskHandle`] to cancel the subscription.
    /// </summary>
    TaskHandle SubscribeToLiveLocationShares(LiveLocationShareListener @listener);
    TaskHandle SubscribeToRoomInfoUpdates(RoomInfoListener @listener);
    TaskHandle SubscribeToTypingNotifications(TypingNotificationsListener @listener);

    /// <exception cref="ClientException"></exception>
    Task<RoomMemberRole> SuggestedRoleForUser(string @userId);

    /// <exception cref="ClientException"></exception>
    Task<Timeline> Timeline();

    /// <summary>
    /// Build a new timeline instance with the given configuration.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<Timeline> TimelineWithConfiguration(TimelineConfiguration @configuration);
    string? Topic();

    /// <exception cref="ClientException"></exception>
    Task TypingNotice(bool @isTyping);

    /// <exception cref="ClientException"></exception>
    Task UnbanUser(string @userId, string? @reason);

    /// <summary>
    /// Update the canonical alias of the room.
    ///
    /// Note that publishing the alias in the room directory is done separately.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task UpdateCanonicalAlias(string? @alias, List<string> @altAliases);

    /// <summary>
    /// Update room history visibility for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task UpdateHistoryVisibility(RoomHistoryVisibility @visibility);

    /// <summary>
    /// Update the join rule for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task UpdateJoinRules(JoinRule @newRule);

    /// <exception cref="ClientException"></exception>
    Task UpdatePowerLevelsForUsers(List<UserPowerLevelUpdate> @updates);

    /// <summary>
    /// Update the room's visibility in the room directory.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task UpdateRoomVisibility(RoomVisibility @visibility);

    /// <summary>
    /// Upload and set the room's avatar.
    ///
    /// This will upload the data produced by the reader to the homeserver's
    /// content repository, and set the room's avatar to the MXC URI for the
    /// uploaded file.
    ///
    /// # Arguments
    ///
    /// * `mime_type` - The mime description of the avatar, for example
    /// image/jpeg
    /// * `data` - The raw data that will be uploaded to the homeserver's
    /// content repository
    /// * `media_info` - The media info used as avatar image info.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task UploadAvatar(string @mimeType, byte[] @data, ImageInfo? @mediaInfo);

    /// <summary>
    /// Remove verification requirements for the given users and
    /// resend messages that failed to send because their identities were no
    /// longer verified (in response to
    /// `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
    ///
    /// # Arguments
    ///
    /// * `user_ids` - The list of users identifiers received in the error
    /// * `transaction_id` - The send queue transaction identifier of the local
    /// echo the send error applies to
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task WithdrawVerificationAndResend(List<string> @userIds, SendHandle @sendHandle);
}

internal class Room : IRoom, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Room(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~Room()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_room(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_room(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public ulong ActiveMembersCount()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterUInt64.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Returns a Vec of userId's that participate in the room call.
    ///
    /// MatrixRTC memberships with application "m.call" and scope "m.room" are
    /// considered. A user can occur twice if they join with two devices.
    /// convert to a set depending if the different users are required or the
    /// amount of sessions.
    ///
    /// The vector is ordered by oldest membership user to newest.
    /// </summary>
    public List<string> ActiveRoomCallParticipants()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterSequenceString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public List<string> AlternativeAliases()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterSequenceString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task ApplyPowerLevelChanges(RoomPowerLevelChanges @changes)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
                    thisPtr,
                    FfiConverterTypeRoomPowerLevelChanges.INSTANCE.Lower(@changes)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public string? AvatarUrl()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task BanUser(string @userId, string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserBan(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserInvite(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserKick(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserPinUnpin(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_pin_unpin(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserRedactOther(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserRedactOwn(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserSendMessage(string @userId, MessageLikeEventType @message)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId),
                    FfiConverterTypeMessageLikeEventType.INSTANCE.Lower(@message)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserSendState(string @userId, StateEventType @stateEvent)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId),
                    FfiConverterTypeStateEventType.INSTANCE.Lower(@stateEvent)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<bool> CanUserTriggerRoomNotification(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public string? CanonicalAlias()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Remove the `ComposerDraft` stored in the state store for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ClearComposerDraft()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Clear the event cache storage for the current room.
    ///
    /// This will remove all the information related to the event cache, in
    /// memory and in the persisted storage, if enabled.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ClearEventCacheStorage()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Forces the currently active room key, which is used to encrypt messages,
    /// to be rotated.
    ///
    /// A new room key will be crated and shared with all the room members the
    /// next time a message will be sent. You don't have to call this method,
    /// room keys will be rotated automatically when necessary. This method is
    /// still useful for debugging purposes.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task DiscardRoomKey()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Returns the room's name from the state event if available, otherwise
    /// compute a room name based on the room's nature (DM or not) and number of
    /// members.
    /// </summary>
    public string? DisplayName()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_display_name(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Edit an event given its event id.
    ///
    /// Useful outside the context of a timeline, or when a timeline doesn't
    /// have the full content of an event.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Edit(string @eventId, RoomMessageEventContentWithoutRelation @newContent)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_edit(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId),
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lower(@newContent)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Enable End-to-end encryption in this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task EnableEncryption()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Enable or disable the send queue for that particular room.
    /// </summary>
    public void EnableSendQueue(bool @enable)
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
                        thisPtr,
                        FfiConverterBoolean.INSTANCE.Lower(@enable),
                        ref _status
                    )
            )
        );
    }

    public EncryptionState EncryptionState()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeEncryptionState.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Forget this room.
    ///
    /// This communicates to the homeserver that it should forget the room.
    ///
    /// Only left or banned-from rooms can be forgotten.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Forget()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_forget(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomPowerLevels> GetPowerLevels()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomPowerLevels.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Returns the visibility for this room in the room directory.
    ///
    /// [Public](`RoomVisibility::Public`) rooms are listed in the room
    /// directory and can be found using it.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<RoomVisibility> GetRoomVisibility()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomVisibility.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Is there a non expired membership with application "m.call" and scope
    /// "m.room" in this room.
    /// </summary>
    public bool HasActiveRoomCall()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Returns the room heroes for this room.
    /// </summary>
    public List<RoomHero> Heroes()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterSequenceTypeRoomHero.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_heroes(thisPtr, ref _status)
                )
            )
        );
    }

    public string Id()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_id(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Set the local trust for the given devices to `LocalTrust::Ignored`
    /// and resend messages that failed to send because said devices are
    /// unverified (in response to
    /// `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
    /// # Arguments
    ///
    /// * `devices` - The map of users identifiers to device identifiers
    /// received in the error
    /// * `transaction_id` - The send queue transaction identifier of the local
    /// echo the send error applies to
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task IgnoreDeviceTrustAndResend(Dictionary<string, List<string>> @devices, SendHandle @sendHandle)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
                    thisPtr,
                    FfiConverterDictionaryStringSequenceString.INSTANCE.Lower(@devices),
                    FfiConverterTypeSendHandle.INSTANCE.Lower(@sendHandle)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Ignores a user.
    ///
    /// # Arguments
    ///
    /// * `user_id` - The ID of the user to ignore.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task IgnoreUser(string @userId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task InviteUserById(string @userId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public ulong InvitedMembersCount()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterUInt64.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(thisPtr, ref _status)
                )
            )
        );
    }

    public async Task<bool> IsDirect()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_is_direct(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    public bool IsPublic()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_is_public(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Returns whether the send queue for that particular room is enabled or
    /// not.
    /// </summary>
    public bool IsSendQueueEnabled()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(thisPtr, ref _status)
                )
            )
        );
    }

    public bool IsSpace()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_is_space(thisPtr, ref _status)
                )
            )
        );
    }

    public bool IsTombstoned()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Join this room.
    ///
    /// Only invited and left rooms can be joined via this method.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Join()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_join(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public ulong JoinedMembersCount()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterUInt64.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task KickUser(string @userId, string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<EncryptionState> LatestEncryptionState()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeEncryptionState.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Leave this room.
    ///
    /// Only invited and joined rooms can be left.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Leave()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_leave(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Retrieve the `ComposerDraft` stored in the state store for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<ComposerDraft?> LoadComposerDraft()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeComposerDraft.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Mark a room as read, by attaching a read receipt on the latest event.
    ///
    /// Note: this does NOT unset the unread flag; it's the caller's
    /// responsibility to do so, if needs be.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task MarkAsRead(ReceiptType @receiptType)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
                    thisPtr,
                    FfiConverterTypeReceiptType.INSTANCE.Lower(@receiptType)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string> MatrixToEventPermalink(string @eventId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string> MatrixToPermalink()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomMember> Member(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_member(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomMember.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string?> MemberAvatarUrl(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<string?> MemberDisplayName(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomMembersIterator> Members()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_members(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoomMembersIterator.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomMembersIterator> MembersNoSync()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoomMembersIterator.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public Membership Membership()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeMembership.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_membership(thisPtr, ref _status)
                )
            )
        );
    }

    public string OwnUserId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Publish a new room alias for this room in the room directory.
    ///
    /// Returns:
    /// - `true` if the room alias didn't exist and it's now published.
    /// - `false` if the room alias was already present so it couldn't be
    /// published.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> PublishRoomAliasInRoomDirectory(string @alias)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@alias)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// The raw name as present in the room state event.
    /// </summary>
    public string? RawName()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_raw_name(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Redacts an event from the room.
    ///
    /// # Arguments
    ///
    /// * `event_id` - The ID of the event to redact
    ///
    /// * `reason` - The reason for the event being redacted (optional). its
    /// transaction ID (optional). If not given one is created.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Redact(string @eventId, string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_redact(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Removes the current room avatar
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task RemoveAvatar()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Remove an existing room alias for this room in the room directory.
    ///
    /// Returns:
    /// - `true` if the room alias was present and it's now removed from the
    /// room directory.
    /// - `false` if the room alias didn't exist so it couldn't be removed.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> RemoveRoomAliasFromRoomDirectory(string @alias)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@alias)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Reports an event from the room.
    ///
    /// # Arguments
    ///
    /// * `event_id` - The ID of the event to report
    ///
    /// * `reason` - The reason for the event being reported (optional).
    ///
    /// * `score` - The score to rate this content as where -100 is most
    /// offensive and 0 is inoffensive (optional).
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ReportContent(string @eventId, int? @score, string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_report_content(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId),
                    FfiConverterOptionalInt32.INSTANCE.Lower(@score),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Reports a room as inappropriate to the server.
    /// The caller is not required to be joined to the room to report it.
    ///
    /// # Arguments
    ///
    /// * `reason` - The reason the room is being reported.
    ///
    /// # Errors
    ///
    /// Returns an error if the room is not found or on rate limit
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ReportRoom(string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_report_room(
                    thisPtr,
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomPowerLevels> ResetPowerLevels()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomPowerLevels.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Return a debug representation for the internal room events data
    /// structure, one line per entry in the resulting vector.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<List<string>> RoomEventsDebugString()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterSequenceString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomInfo> RoomInfo()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_room_info(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomInfo.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Store the given `ComposerDraft` in the state store using the current
    /// room id, as identifier.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SaveComposerDraft(ComposerDraft @draft)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
                    thisPtr,
                    FfiConverterTypeComposerDraft.INSTANCE.Lower(@draft)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Send a call notification event in the current room.
    ///
    /// This is only supposed to be used in **custom** situations where the user
    /// explicitly chooses to send a `m.call.notify` event to invite/notify
    /// someone explicitly in unusual conditions. The default should be to
    /// use `send_call_notification_if_necessary` just before a new room call is
    /// created/joined.
    ///
    /// One example could be that the UI allows to start a call with a subset of
    /// users of the room members first. And then later on the user can
    /// invite more users to the call.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SendCallNotification(
        string @callId,
        RtcApplicationType @application,
        NotifyType @notifyType,
        Mentions @mentions
    )
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@callId),
                    FfiConverterTypeRtcApplicationType.INSTANCE.Lower(@application),
                    FfiConverterTypeNotifyType.INSTANCE.Lower(@notifyType),
                    FfiConverterTypeMentions.INSTANCE.Lower(@mentions)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// This will only send a call notification event if appropriate.
    ///
    /// This function is supposed to be called whenever the user creates a room
    /// call. It will send a `m.call.notify` event if:
    /// - there is not yet a running call.
    ///
    /// It will configure the notify type: ring or notify based on:
    /// - is this a DM room -> ring
    /// - is this a group with more than one other member -> notify
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SendCallNotificationIfNeeded()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Send the current users live location beacon in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SendLiveLocation(string @geoUri)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@geoUri)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Send a raw event to the room.
    ///
    /// # Arguments
    ///
    /// * `event_type` - The type of the event to send.
    ///
    /// * `content` - The content of the event to send encoded as JSON string.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SendRaw(string @eventType, string @content)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventType),
                    FfiConverterString.INSTANCE.Lower(@content)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task SetIsFavourite(bool @isFavourite, double? @tagOrder)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@isFavourite),
                    FfiConverterOptionalDouble.INSTANCE.Lower(@tagOrder)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task SetIsLowPriority(bool @isLowPriority, double? @tagOrder)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@isLowPriority),
                    FfiConverterOptionalDouble.INSTANCE.Lower(@tagOrder)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Sets a new name to the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SetName(string @name)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_set_name(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@name)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Sets a new topic in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SetTopic(string @topic)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@topic)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Set (or unset) a flag on the room to indicate that the user has
    /// explicitly marked it as unread.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SetUnreadFlag(bool @newValue)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@newValue)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Start the current users live location share in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task StartLiveLocationShare(ulong @durationMillis)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(
                    thisPtr,
                    FfiConverterUInt64.INSTANCE.Lower(@durationMillis)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Stop the current users live location share in the room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task StopLiveLocationShare()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<TaskHandle> SubscribeToIdentityStatusChanges(IdentityStatusChangeListener @listener)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
                    thisPtr,
                    FfiConverterTypeIdentityStatusChangeListener.INSTANCE.Lower(@listener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTaskHandle.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Subscribes to requests to join this room (knock member events), using a
    /// `listener` to be notified of the changes.
    ///
    /// The current requests to join the room will be emitted immediately
    /// when subscribing, along with a [`TaskHandle`] to cancel the
    /// subscription.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<TaskHandle> SubscribeToKnockRequests(KnockRequestsListener @listener)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
                    thisPtr,
                    FfiConverterTypeKnockRequestsListener.INSTANCE.Lower(@listener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTaskHandle.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Subscribes to live location shares in this room, using a `listener` to
    /// be notified of the changes.
    ///
    /// The current live location shares will be emitted immediately when
    /// subscribing, along with a [`TaskHandle`] to cancel the subscription.
    /// </summary>
    public TaskHandle SubscribeToLiveLocationShares(LiveLocationShareListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(
                            thisPtr,
                            FfiConverterTypeLiveLocationShareListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    public TaskHandle SubscribeToRoomInfoUpdates(RoomInfoListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
                            thisPtr,
                            FfiConverterTypeRoomInfoListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    public TaskHandle SubscribeToTypingNotifications(TypingNotificationsListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
                            thisPtr,
                            FfiConverterTypeTypingNotificationsListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomMemberRole> SuggestedRoleForUser(string @userId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomMemberRole.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<Timeline> Timeline()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_timeline(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTimeline.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Build a new timeline instance with the given configuration.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<Timeline> TimelineWithConfiguration(TimelineConfiguration @configuration)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(
                    thisPtr,
                    FfiConverterTypeTimelineConfiguration.INSTANCE.Lower(@configuration)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTimeline.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public string? Topic()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_topic(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task TypingNotice(bool @isTyping)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
                    thisPtr,
                    FfiConverterBoolean.INSTANCE.Lower(@isTyping)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task UnbanUser(string @userId, string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Update the canonical alias of the room.
    ///
    /// Note that publishing the alias in the room directory is done separately.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task UpdateCanonicalAlias(string? @alias, List<string> @altAliases)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(
                    thisPtr,
                    FfiConverterOptionalString.INSTANCE.Lower(@alias),
                    FfiConverterSequenceString.INSTANCE.Lower(@altAliases)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Update room history visibility for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task UpdateHistoryVisibility(RoomHistoryVisibility @visibility)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(
                    thisPtr,
                    FfiConverterTypeRoomHistoryVisibility.INSTANCE.Lower(@visibility)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Update the join rule for this room.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task UpdateJoinRules(JoinRule @newRule)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(
                    thisPtr,
                    FfiConverterTypeJoinRule.INSTANCE.Lower(@newRule)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task UpdatePowerLevelsForUsers(List<UserPowerLevelUpdate> @updates)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
                    thisPtr,
                    FfiConverterSequenceTypeUserPowerLevelUpdate.INSTANCE.Lower(@updates)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Update the room's visibility in the room directory.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task UpdateRoomVisibility(RoomVisibility @visibility)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(
                    thisPtr,
                    FfiConverterTypeRoomVisibility.INSTANCE.Lower(@visibility)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Upload and set the room's avatar.
    ///
    /// This will upload the data produced by the reader to the homeserver's
    /// content repository, and set the room's avatar to the MXC URI for the
    /// uploaded file.
    ///
    /// # Arguments
    ///
    /// * `mime_type` - The mime description of the avatar, for example
    /// image/jpeg
    /// * `data` - The raw data that will be uploaded to the homeserver's
    /// content repository
    /// * `media_info` - The media info used as avatar image info.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task UploadAvatar(string @mimeType, byte[] @data, ImageInfo? @mediaInfo)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@mimeType),
                    FfiConverterByteArray.INSTANCE.Lower(@data),
                    FfiConverterOptionalTypeImageInfo.INSTANCE.Lower(@mediaInfo)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Remove verification requirements for the given users and
    /// resend messages that failed to send because their identities were no
    /// longer verified (in response to
    /// `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
    ///
    /// # Arguments
    ///
    /// * `user_ids` - The list of users identifiers received in the error
    /// * `transaction_id` - The send queue transaction identifier of the local
    /// echo the send error applies to
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task WithdrawVerificationAndResend(List<string> @userIds, SendHandle @sendHandle)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
                    thisPtr,
                    FfiConverterSequenceString.INSTANCE.Lower(@userIds),
                    FfiConverterTypeSendHandle.INSTANCE.Lower(@sendHandle)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeRoom : FfiConverter<Room, IntPtr>
{
    public static FfiConverterTypeRoom INSTANCE = new FfiConverterTypeRoom();

    public override IntPtr Lower(Room value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Room Lift(IntPtr value)
    {
        return new Room(value);
    }

    public override Room Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Room value)
    {
        return 8;
    }

    public override void Write(Room value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A helper for performing room searches in the room directory.
/// The way this is intended to be used is:
///
/// 1. Register a callback using [`RoomDirectorySearch::results`].
/// 2. Start the room search with [`RoomDirectorySearch::search`].
/// 3. To get more results, use [`RoomDirectorySearch::next_page`].
/// </summary>
internal interface IRoomDirectorySearch
{
    /// <summary>
    /// Get whether the search is at the last page.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> IsAtLastPage();

    /// <summary>
    /// Get the number of pages that have been loaded so far.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<uint> LoadedPages();

    /// <summary>
    /// Asks the server for the next page of the current search.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task NextPage();

    /// <summary>
    /// Registers a callback to receive new search results when starting a
    /// search or getting new paginated results.
    /// </summary>
    Task<TaskHandle> Results(RoomDirectorySearchEntriesListener @listener);

    /// <summary>
    /// Starts a filtered search for the server.
    ///
    /// If the `filter` is not provided it will search for all the rooms.
    /// You can specify a `batch_size` to control the number of rooms to fetch
    /// per request.
    ///
    /// If the `via_server` is not provided it will search in the current
    /// homeserver by default.
    ///
    /// This method will clear the current search results and start a new one.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Search(string? @filter, uint @batchSize, string? @viaServerName);
}

/// <summary>
/// A helper for performing room searches in the room directory.
/// The way this is intended to be used is:
///
/// 1. Register a callback using [`RoomDirectorySearch::results`].
/// 2. Start the room search with [`RoomDirectorySearch::search`].
/// 3. To get more results, use [`RoomDirectorySearch::next_page`].
/// </summary>
internal class RoomDirectorySearch : IRoomDirectorySearch, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomDirectorySearch(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomDirectorySearch()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Get whether the search is at the last page.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> IsAtLastPage()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Get the number of pages that have been loaded so far.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<uint> LoadedPages()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_u32(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_u32(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_u32(future),
            // Lift
            (result) => FfiConverterUInt32.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Asks the server for the next page of the current search.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task NextPage()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Registers a callback to receive new search results when starting a
    /// search or getting new paginated results.
    /// </summary>
    public async Task<TaskHandle> Results(RoomDirectorySearchEntriesListener @listener)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
                    thisPtr,
                    FfiConverterTypeRoomDirectorySearchEntriesListener.INSTANCE.Lower(@listener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTaskHandle.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Starts a filtered search for the server.
    ///
    /// If the `filter` is not provided it will search for all the rooms.
    /// You can specify a `batch_size` to control the number of rooms to fetch
    /// per request.
    ///
    /// If the `via_server` is not provided it will search in the current
    /// homeserver by default.
    ///
    /// This method will clear the current search results and start a new one.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Search(string? @filter, uint @batchSize, string? @viaServerName)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
                    thisPtr,
                    FfiConverterOptionalString.INSTANCE.Lower(@filter),
                    FfiConverterUInt32.INSTANCE.Lower(@batchSize),
                    FfiConverterOptionalString.INSTANCE.Lower(@viaServerName)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeRoomDirectorySearch : FfiConverter<RoomDirectorySearch, IntPtr>
{
    public static FfiConverterTypeRoomDirectorySearch INSTANCE = new FfiConverterTypeRoomDirectorySearch();

    public override IntPtr Lower(RoomDirectorySearch value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomDirectorySearch Lift(IntPtr value)
    {
        return new RoomDirectorySearch(value);
    }

    public override RoomDirectorySearch Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomDirectorySearch value)
    {
        return 8;
    }

    public override void Write(RoomDirectorySearch value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomList
{
    RoomListEntriesWithDynamicAdaptersResult EntriesWithDynamicAdapters(
        uint @pageSize,
        RoomListEntriesListener @listener
    );

    /// <exception cref="RoomListException"></exception>
    RoomListLoadingStateResult LoadingState(RoomListLoadingStateListener @listener);

    /// <exception cref="RoomListException"></exception>
    RoomListItem Room(string @roomId);
}

internal class RoomList : IRoomList, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomList(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomList()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roomlist(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roomlist(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public RoomListEntriesWithDynamicAdaptersResult EntriesWithDynamicAdapters(
        uint @pageSize,
        RoomListEntriesListener @listener
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
                            thisPtr,
                            FfiConverterUInt32.INSTANCE.Lower(@pageSize),
                            FfiConverterTypeRoomListEntriesListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="RoomListException"></exception>
    public RoomListLoadingStateResult LoadingState(RoomListLoadingStateListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomListLoadingStateResult.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomListError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
                            thisPtr,
                            FfiConverterTypeRoomListLoadingStateListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="RoomListException"></exception>
    public RoomListItem Room(string @roomId)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomListItem.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomListError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@roomId),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRoomList : FfiConverter<RoomList, IntPtr>
{
    public static FfiConverterTypeRoomList INSTANCE = new FfiConverterTypeRoomList();

    public override IntPtr Lower(RoomList value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomList Lift(IntPtr value)
    {
        return new RoomList(value);
    }

    public override RoomList Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomList value)
    {
        return 8;
    }

    public override void Write(RoomList value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomListDynamicEntriesController
{
    void AddOnePage();
    void ResetToOnePage();
    bool SetFilter(RoomListEntriesDynamicFilterKind @kind);
}

internal class RoomListDynamicEntriesController : IRoomListDynamicEntriesController, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomListDynamicEntriesController(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomListDynamicEntriesController()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public void AddOnePage()
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
                        thisPtr,
                        ref _status
                    )
            )
        );
    }

    public void ResetToOnePage()
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
                        thisPtr,
                        ref _status
                    )
            )
        );
    }

    public bool SetFilter(RoomListEntriesDynamicFilterKind @kind)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
                            thisPtr,
                            FfiConverterTypeRoomListEntriesDynamicFilterKind.INSTANCE.Lower(@kind),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRoomListDynamicEntriesController : FfiConverter<RoomListDynamicEntriesController, IntPtr>
{
    public static FfiConverterTypeRoomListDynamicEntriesController INSTANCE =
        new FfiConverterTypeRoomListDynamicEntriesController();

    public override IntPtr Lower(RoomListDynamicEntriesController value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomListDynamicEntriesController Lift(IntPtr value)
    {
        return new RoomListDynamicEntriesController(value);
    }

    public override RoomListDynamicEntriesController Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomListDynamicEntriesController value)
    {
        return 8;
    }

    public override void Write(RoomListDynamicEntriesController value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomListEntriesWithDynamicAdaptersResult
{
    RoomListDynamicEntriesController Controller();
    TaskHandle EntriesStream();
}

internal class RoomListEntriesWithDynamicAdaptersResult : IRoomListEntriesWithDynamicAdaptersResult, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomListEntriesWithDynamicAdaptersResult(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomListEntriesWithDynamicAdaptersResult()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public RoomListDynamicEntriesController Controller()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomListDynamicEntriesController.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public TaskHandle EntriesStream()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult
    : FfiConverter<RoomListEntriesWithDynamicAdaptersResult, IntPtr>
{
    public static FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult INSTANCE =
        new FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult();

    public override IntPtr Lower(RoomListEntriesWithDynamicAdaptersResult value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomListEntriesWithDynamicAdaptersResult Lift(IntPtr value)
    {
        return new RoomListEntriesWithDynamicAdaptersResult(value);
    }

    public override RoomListEntriesWithDynamicAdaptersResult Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomListEntriesWithDynamicAdaptersResult value)
    {
        return 8;
    }

    public override void Write(RoomListEntriesWithDynamicAdaptersResult value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomListItem
{
    string? AvatarUrl();
    string? CanonicalAlias();

    /// <summary>
    /// Returns the room's name from the state event if available, otherwise
    /// compute a room name based on the room's nature (DM or not) and number of
    /// members.
    /// </summary>
    string? DisplayName();

    /// <summary>
    /// Build a full `Room` FFI object, filling its associated timeline.
    ///
    /// An error will be returned if the room is a state different than joined
    /// or if its internal timeline hasn't been initialized.
    /// </summary>
    /// <exception cref="RoomListException"></exception>
    Room FullRoom();
    string Id();

    /// <summary>
    /// Initializes the timeline for this room using the provided parameters.
    ///
    /// * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
    /// used to filter timeline events besides the default timeline filter. If
    /// `None` is passed, only the default timeline filter will be used.
    /// * `internal_id_prefix` - An optional String that will be prepended to
    /// all the timeline item's internal IDs, making it possible to
    /// distinguish different timeline instances from each other.
    /// </summary>
    /// <exception cref="RoomListException"></exception>
    Task InitTimeline(TimelineEventTypeFilter? @eventTypeFilter, string? @internalIdPrefix);
    Task<bool> IsDirect();

    /// <summary>
    /// Checks whether the room is encrypted or not.
    ///
    /// **Note**: this info may not be reliable if you don't set up
    /// `m.room.encryption` as required state.
    /// </summary>
    Task<bool> IsEncrypted();

    /// <summary>
    /// Checks whether the Room's timeline has been initialized before.
    /// </summary>
    bool IsTimelineInitialized();
    Task<EventTimelineItem?> LatestEvent();

    /// <summary>
    /// The room's current membership state.
    /// </summary>
    Membership Membership();

    /// <summary>
    /// Builds a `RoomPreview` from a room list item. This is intended for
    /// invited, knocked or banned rooms.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<RoomPreview> PreviewRoom(List<string> @via);

    /// <exception cref="ClientException"></exception>
    Task<RoomInfo> RoomInfo();
}

internal class RoomListItem : IRoomListItem, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomListItem(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomListItem()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roomlistitem(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roomlistitem(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public string? AvatarUrl()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_avatar_url(thisPtr, ref _status)
                )
            )
        );
    }

    public string? CanonicalAlias()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_canonical_alias(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Returns the room's name from the state event if available, otherwise
    /// compute a room name based on the room's nature (DM or not) and number of
    /// members.
    /// </summary>
    public string? DisplayName()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_display_name(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Build a full `Room` FFI object, filling its associated timeline.
    ///
    /// An error will be returned if the room is a state different than joined
    /// or if its internal timeline hasn't been initialized.
    /// </summary>
    /// <exception cref="RoomListException"></exception>
    public Room FullRoom()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoom.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomListError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_full_room(thisPtr, ref _status)
                )
            )
        );
    }

    public string Id()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_id(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Initializes the timeline for this room using the provided parameters.
    ///
    /// * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
    /// used to filter timeline events besides the default timeline filter. If
    /// `None` is passed, only the default timeline filter will be used.
    /// * `internal_id_prefix` - An optional String that will be prepended to
    /// all the timeline item's internal IDs, making it possible to
    /// distinguish different timeline instances from each other.
    /// </summary>
    /// <exception cref="RoomListException"></exception>
    public async Task InitTimeline(TimelineEventTypeFilter? @eventTypeFilter, string? @internalIdPrefix)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_init_timeline(
                    thisPtr,
                    FfiConverterOptionalTypeTimelineEventTypeFilter.INSTANCE.Lower(@eventTypeFilter),
                    FfiConverterOptionalString.INSTANCE.Lower(@internalIdPrefix)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeRoomListError.INSTANCE
        );
    }

    public async Task<bool> IsDirect()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_direct(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Checks whether the room is encrypted or not.
    ///
    /// **Note**: this info may not be reliable if you don't set up
    /// `m.room.encryption` as required state.
    /// </summary>
    public async Task<bool> IsEncrypted()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_encrypted(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Checks whether the Room's timeline has been initialized before.
    /// </summary>
    public bool IsTimelineInitialized()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_timeline_initialized(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public async Task<EventTimelineItem?> LatestEvent()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_latest_event(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeEventTimelineItem.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// The room's current membership state.
    /// </summary>
    public Membership Membership()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeMembership.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_membership(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Builds a `RoomPreview` from a room list item. This is intended for
    /// invited, knocked or banned rooms.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<RoomPreview> PreviewRoom(List<string> @via)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_preview_room(
                    thisPtr,
                    FfiConverterSequenceString.INSTANCE.Lower(@via)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoomPreview.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<RoomInfo> RoomInfo()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_room_info(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeRoomInfo.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeRoomListItem : FfiConverter<RoomListItem, IntPtr>
{
    public static FfiConverterTypeRoomListItem INSTANCE = new FfiConverterTypeRoomListItem();

    public override IntPtr Lower(RoomListItem value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomListItem Lift(IntPtr value)
    {
        return new RoomListItem(value);
    }

    public override RoomListItem Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomListItem value)
    {
        return 8;
    }

    public override void Write(RoomListItem value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomListService
{
    /// <exception cref="RoomListException"></exception>
    Task<RoomList> AllRooms();

    /// <exception cref="RoomListException"></exception>
    RoomListItem Room(string @roomId);
    TaskHandle State(RoomListServiceStateListener @listener);

    /// <exception cref="RoomListException"></exception>
    void SubscribeToRooms(List<string> @roomIds);
    TaskHandle SyncIndicator(
        uint @delayBeforeShowingInMs,
        uint @delayBeforeHidingInMs,
        RoomListServiceSyncIndicatorListener @listener
    );
}

internal class RoomListService : IRoomListService, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomListService(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomListService()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roomlistservice(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <exception cref="RoomListException"></exception>
    public async Task<RoomList> AllRooms()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeRoomList.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeRoomListError.INSTANCE
        );
    }

    /// <exception cref="RoomListException"></exception>
    public RoomListItem Room(string @roomId)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomListItem.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomListError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
                            thisPtr,
                            FfiConverterString.INSTANCE.Lower(@roomId),
                            ref _status
                        )
                )
            )
        );
    }

    public TaskHandle State(RoomListServiceStateListener @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
                            thisPtr,
                            FfiConverterTypeRoomListServiceStateListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="RoomListException"></exception>
    public void SubscribeToRooms(List<string> @roomIds)
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeRoomListError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
                        thisPtr,
                        FfiConverterSequenceString.INSTANCE.Lower(@roomIds),
                        ref _status
                    )
            )
        );
    }

    public TaskHandle SyncIndicator(
        uint @delayBeforeShowingInMs,
        uint @delayBeforeHidingInMs,
        RoomListServiceSyncIndicatorListener @listener
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
                            thisPtr,
                            FfiConverterUInt32.INSTANCE.Lower(@delayBeforeShowingInMs),
                            FfiConverterUInt32.INSTANCE.Lower(@delayBeforeHidingInMs),
                            FfiConverterTypeRoomListServiceSyncIndicatorListener.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRoomListService : FfiConverter<RoomListService, IntPtr>
{
    public static FfiConverterTypeRoomListService INSTANCE = new FfiConverterTypeRoomListService();

    public override IntPtr Lower(RoomListService value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomListService Lift(IntPtr value)
    {
        return new RoomListService(value);
    }

    public override RoomListService Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomListService value)
    {
        return 8;
    }

    public override void Write(RoomListService value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomMembersIterator
{
    uint Len();
    List<RoomMember>? NextChunk(uint @chunkSize);
}

internal class RoomMembersIterator : IRoomMembersIterator, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomMembersIterator(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomMembersIterator()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public uint Len()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterUInt32.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(thisPtr, ref _status)
                )
            )
        );
    }

    public List<RoomMember>? NextChunk(uint @chunkSize)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalSequenceTypeRoomMember.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
                            thisPtr,
                            FfiConverterUInt32.INSTANCE.Lower(@chunkSize),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRoomMembersIterator : FfiConverter<RoomMembersIterator, IntPtr>
{
    public static FfiConverterTypeRoomMembersIterator INSTANCE = new FfiConverterTypeRoomMembersIterator();

    public override IntPtr Lower(RoomMembersIterator value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomMembersIterator Lift(IntPtr value)
    {
        return new RoomMembersIterator(value);
    }

    public override RoomMembersIterator Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomMembersIterator value)
    {
        return 8;
    }

    public override void Write(RoomMembersIterator value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRoomMessageEventContentWithoutRelation
{
    RoomMessageEventContentWithoutRelation WithMentions(Mentions @mentions);
}

internal class RoomMessageEventContentWithoutRelation : IRoomMessageEventContentWithoutRelation, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomMessageEventContentWithoutRelation(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomMessageEventContentWithoutRelation()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public RoomMessageEventContentWithoutRelation WithMentions(Mentions @mentions)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
                            thisPtr,
                            FfiConverterTypeMentions.INSTANCE.Lower(@mentions),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRoomMessageEventContentWithoutRelation
    : FfiConverter<RoomMessageEventContentWithoutRelation, IntPtr>
{
    public static FfiConverterTypeRoomMessageEventContentWithoutRelation INSTANCE =
        new FfiConverterTypeRoomMessageEventContentWithoutRelation();

    public override IntPtr Lower(RoomMessageEventContentWithoutRelation value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomMessageEventContentWithoutRelation Lift(IntPtr value)
    {
        return new RoomMessageEventContentWithoutRelation(value);
    }

    public override RoomMessageEventContentWithoutRelation Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomMessageEventContentWithoutRelation value)
    {
        return 8;
    }

    public override void Write(RoomMessageEventContentWithoutRelation value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A room preview for a room. It's intended to be used to represent rooms that
/// aren't joined yet.
/// </summary>
internal interface IRoomPreview
{
    /// <summary>
    /// Forget the room if we had access to it, and it was left or banned.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Forget();

    /// <summary>
    /// Returns the room info the preview contains.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    RoomPreviewInfo Info();

    /// <summary>
    /// Get the user who created the invite, if any.
    /// </summary>
    Task<RoomMember?> Inviter();

    /// <summary>
    /// Leave the room if the room preview state is either joined, invited or
    /// knocked.
    ///
    /// If rejecting an invite then also forget it as an extra layer of
    /// protection against spam attacks.
    ///
    /// Will return an error otherwise.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Leave();

    /// <summary>
    /// Get the membership details for the current user.
    /// </summary>
    Task<RoomMembershipDetails?> OwnMembershipDetails();
}

/// <summary>
/// A room preview for a room. It's intended to be used to represent rooms that
/// aren't joined yet.
/// </summary>
internal class RoomPreview : IRoomPreview, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RoomPreview(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~RoomPreview()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_roompreview(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_roompreview(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Forget the room if we had access to it, and it was left or banned.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Forget()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Returns the room info the preview contains.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public RoomPreviewInfo Info()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomPreviewInfo.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roompreview_info(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Get the user who created the invite, if any.
    /// </summary>
    public async Task<RoomMember?> Inviter()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeRoomMember.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Leave the room if the room preview state is either joined, invited or
    /// knocked.
    ///
    /// If rejecting an invite then also forget it as an extra layer of
    /// protection against spam attacks.
    ///
    /// Will return an error otherwise.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Leave()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Get the membership details for the current user.
    /// </summary>
    public async Task<RoomMembershipDetails?> OwnMembershipDetails()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeRoomMembershipDetails.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }
}

class FfiConverterTypeRoomPreview : FfiConverter<RoomPreview, IntPtr>
{
    public static FfiConverterTypeRoomPreview INSTANCE = new FfiConverterTypeRoomPreview();

    public override IntPtr Lower(RoomPreview value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RoomPreview Lift(IntPtr value)
    {
        return new RoomPreview(value);
    }

    public override RoomPreview Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RoomPreview value)
    {
        return 8;
    }

    public override void Write(RoomPreview value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ISendAttachmentJoinHandle
{
    /// <summary>
    /// Cancel the current sending task.
    ///
    /// A subsequent call to [`Self::join`] will return immediately.
    /// </summary>
    void Cancel();

    /// <summary>
    /// Wait until the attachment has been sent.
    ///
    /// If the sending had been cancelled, will return immediately.
    /// </summary>
    /// <exception cref="RoomException"></exception>
    Task Join();
}

internal class SendAttachmentJoinHandle : ISendAttachmentJoinHandle, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SendAttachmentJoinHandle(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SendAttachmentJoinHandle()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Cancel the current sending task.
    ///
    /// A subsequent call to [`Self::join`] will return immediately.
    /// </summary>
    public void Cancel()
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(thisPtr, ref _status)
            )
        );
    }

    /// <summary>
    /// Wait until the attachment has been sent.
    ///
    /// If the sending had been cancelled, will return immediately.
    /// </summary>
    /// <exception cref="RoomException"></exception>
    public async Task Join()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeRoomError.INSTANCE
        );
    }
}

class FfiConverterTypeSendAttachmentJoinHandle : FfiConverter<SendAttachmentJoinHandle, IntPtr>
{
    public static FfiConverterTypeSendAttachmentJoinHandle INSTANCE = new FfiConverterTypeSendAttachmentJoinHandle();

    public override IntPtr Lower(SendAttachmentJoinHandle value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SendAttachmentJoinHandle Lift(IntPtr value)
    {
        return new SendAttachmentJoinHandle(value);
    }

    public override SendAttachmentJoinHandle Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SendAttachmentJoinHandle value)
    {
        return 8;
    }

    public override void Write(SendAttachmentJoinHandle value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A handle to perform actions onto a local echo.
/// </summary>
internal interface ISendHandle
{
    /// <summary>
    /// Try to abort the sending of the current event.
    ///
    /// If this returns `true`, then the sending could be aborted, because the
    /// event hasn't been sent yet. Otherwise, if this returns `false`, the
    /// event had already been sent and could not be aborted.
    ///
    /// This has an effect only on the first call; subsequent calls will always
    /// return `false`.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> Abort();

    /// <summary>
    /// Attempt to manually resend messages that failed to send due to issues
    /// that should now have been fixed.
    ///
    /// This is useful for example, when there's a
    /// `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
    /// the user may have re-verified on a different device and would now
    /// like to send the failed message that's waiting on this device.
    ///
    /// # Arguments
    ///
    /// * `transaction_id` - The send queue transaction identifier of the local
    /// echo that should be unwedged.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task TryResend();
}

/// <summary>
/// A handle to perform actions onto a local echo.
/// </summary>
internal class SendHandle : ISendHandle, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SendHandle(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SendHandle()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_sendhandle(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_sendhandle(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Try to abort the sending of the current event.
    ///
    /// If this returns `true`, then the sending could be aborted, because the
    /// event hasn't been sent yet. Otherwise, if this returns `false`, the
    /// event had already been sent and could not be aborted.
    ///
    /// This has an effect only on the first call; subsequent calls will always
    /// return `false`.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> Abort()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Attempt to manually resend messages that failed to send due to issues
    /// that should now have been fixed.
    ///
    /// This is useful for example, when there's a
    /// `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
    /// the user may have re-verified on a different device and would now
    /// like to send the failed message that's waiting on this device.
    ///
    /// # Arguments
    ///
    /// * `transaction_id` - The send queue transaction identifier of the local
    /// echo that should be unwedged.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task TryResend()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeSendHandle : FfiConverter<SendHandle, IntPtr>
{
    public static FfiConverterTypeSendHandle INSTANCE = new FfiConverterTypeSendHandle();

    public override IntPtr Lower(SendHandle value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SendHandle Lift(IntPtr value)
    {
        return new SendHandle(value);
    }

    public override SendHandle Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SendHandle value)
    {
        return 8;
    }

    public override void Write(SendHandle value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ISessionVerificationController
{
    /// <summary>
    /// Accept the previously acknowledged verification request
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task AcceptVerificationRequest();

    /// <summary>
    /// Set this particular request as the currently active one and register for
    /// events pertaining it.
    /// * `sender_id` - The user requesting verification.
    /// * `flow_id` - - The ID that uniquely identifies the verification flow.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task AcknowledgeVerificationRequest(string @senderId, string @flowId);

    /// <summary>
    /// Confirm that the short auth strings match on both sides.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ApproveVerification();

    /// <summary>
    /// Cancel the current verification request
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task CancelVerification();

    /// <summary>
    /// Reject the short auth string
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task DeclineVerification();

    /// <summary>
    /// Request verification for the current device
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task RequestDeviceVerification();

    /// <summary>
    /// Request verification for the given user
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task RequestUserVerification(string @userId);
    void SetDelegate(SessionVerificationControllerDelegate? @delegate);

    /// <summary>
    /// Transition the current verification request into a SAS verification
    /// flow.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task StartSasVerification();
}

internal class SessionVerificationController : ISessionVerificationController, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SessionVerificationController(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SessionVerificationController()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Accept the previously acknowledged verification request
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task AcceptVerificationRequest()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Set this particular request as the currently active one and register for
    /// events pertaining it.
    /// * `sender_id` - The user requesting verification.
    /// * `flow_id` - - The ID that uniquely identifies the verification flow.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task AcknowledgeVerificationRequest(string @senderId, string @flowId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@senderId),
                    FfiConverterString.INSTANCE.Lower(@flowId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Confirm that the short auth strings match on both sides.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ApproveVerification()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Cancel the current verification request
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task CancelVerification()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Reject the short auth string
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task DeclineVerification()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Request verification for the current device
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task RequestDeviceVerification()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Request verification for the given user
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task RequestUserVerification(string @userId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@userId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public void SetDelegate(SessionVerificationControllerDelegate? @delegate)
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
                        thisPtr,
                        FfiConverterOptionalTypeSessionVerificationControllerDelegate.INSTANCE.Lower(@delegate),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Transition the current verification request into a SAS verification
    /// flow.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task StartSasVerification()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
                    thisPtr
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeSessionVerificationController : FfiConverter<SessionVerificationController, IntPtr>
{
    public static FfiConverterTypeSessionVerificationController INSTANCE =
        new FfiConverterTypeSessionVerificationController();

    public override IntPtr Lower(SessionVerificationController value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SessionVerificationController Lift(IntPtr value)
    {
        return new SessionVerificationController(value);
    }

    public override SessionVerificationController Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SessionVerificationController value)
    {
        return 8;
    }

    public override void Write(SessionVerificationController value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ISessionVerificationEmoji
{
    string Description();
    string Symbol();
}

internal class SessionVerificationEmoji : ISessionVerificationEmoji, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SessionVerificationEmoji(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SessionVerificationEmoji()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public string Description()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public string Symbol()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeSessionVerificationEmoji : FfiConverter<SessionVerificationEmoji, IntPtr>
{
    public static FfiConverterTypeSessionVerificationEmoji INSTANCE = new FfiConverterTypeSessionVerificationEmoji();

    public override IntPtr Lower(SessionVerificationEmoji value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SessionVerificationEmoji Lift(IntPtr value)
    {
        return new SessionVerificationEmoji(value);
    }

    public override SessionVerificationEmoji Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SessionVerificationEmoji value)
    {
        return 8;
    }

    public override void Write(SessionVerificationEmoji value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ISpan
{
    void Enter();
    void Exit();
    bool IsNone();
}

internal class Span : ISpan, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Span(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~Span()
    {
        Destroy();
    }

    /// <summary>
    /// Create a span originating at the given callsite (file, line and column).
    ///
    /// The target should be something like a module path, and can be referenced
    /// in the filter string given to `setup_tracing`. `level` and `target`
    /// for a callsite are fixed at the first creation of a span for that
    /// callsite and can not be changed afterwards, i.e. the level and
    /// target passed for second and following creation of a span with the same
    /// callsite will be ignored.
    ///
    /// This function leaks a little bit of memory for each unique (file +
    /// line + level + target + name) it is called with. Please make sure that
    /// the number of different combinations of those parameters this can be
    /// called with is constant in the final executable.
    ///
    /// For a span to have an effect, you must `.enter()` it at the start of a
    /// logical unit of work and `.exit()` it at the end of the same (including
    /// on failure). Entering registers the span in thread-local storage, so
    /// future calls to `log_event` on the same thread are able to attach the
    /// events they create to the span, exiting unregisters it. For this to
    /// work, exiting a span must be done on the same thread where it was
    /// entered. It is possible to enter a span on multiple threads, in which
    /// case it should also be exited on all of them individually; that is,
    /// unless you *want* the span to be attached to all further events created
    /// on that thread.
    /// </summary>
    public Span(string @file, uint? @line, LogLevel @level, string @target, string @name)
        : this(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_span_new(
                        FfiConverterString.INSTANCE.Lower(@file),
                        FfiConverterOptionalUInt32.INSTANCE.Lower(@line),
                        FfiConverterTypeLogLevel.INSTANCE.Lower(@level),
                        FfiConverterString.INSTANCE.Lower(@target),
                        FfiConverterString.INSTANCE.Lower(@name),
                        ref _status
                    )
            )
        ) { }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_span(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_span(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public void Enter()
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_span_enter(thisPtr, ref _status)
            )
        );
    }

    public void Exit()
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_span_exit(thisPtr, ref _status)
            )
        );
    }

    public bool IsNone()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_span_is_none(thisPtr, ref _status)
                )
            )
        );
    }

    public static Span Current()
    {
        return new Span(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_span_current(ref _status)
            )
        );
    }
}

class FfiConverterTypeSpan : FfiConverter<Span, IntPtr>
{
    public static FfiConverterTypeSpan INSTANCE = new FfiConverterTypeSpan();

    public override IntPtr Lower(Span value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Span Lift(IntPtr value)
    {
        return new Span(value);
    }

    public override Span Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Span value)
    {
        return 8;
    }

    public override void Write(Span value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// An object encapsulating the SSO login flow
/// </summary>
internal interface ISsoHandler
{
    /// <summary>
    /// Completes the SSO login process.
    /// </summary>
    /// <exception cref="SsoException"></exception>
    Task Finish(string @callbackUrl);

    /// <summary>
    /// Returns the URL for starting SSO authentication. The URL should be
    /// opened in a web view. Once the web view succeeds, call `finish` with
    /// the callback URL.
    /// </summary>
    string Url();
}

/// <summary>
/// An object encapsulating the SSO login flow
/// </summary>
internal class SsoHandler : ISsoHandler, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SsoHandler(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SsoHandler()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_ssohandler(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_ssohandler(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Completes the SSO login process.
    /// </summary>
    /// <exception cref="SsoException"></exception>
    public async Task Finish(string @callbackUrl)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@callbackUrl)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeSsoError.INSTANCE
        );
    }

    /// <summary>
    /// Returns the URL for starting SSO authentication. The URL should be
    /// opened in a web view. Once the web view succeeds, call `finish` with
    /// the callback URL.
    /// </summary>
    public string Url()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeSsoHandler : FfiConverter<SsoHandler, IntPtr>
{
    public static FfiConverterTypeSsoHandler INSTANCE = new FfiConverterTypeSsoHandler();

    public override IntPtr Lower(SsoHandler value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SsoHandler Lift(IntPtr value)
    {
        return new SsoHandler(value);
    }

    public override SsoHandler Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SsoHandler value)
    {
        return 8;
    }

    public override void Write(SsoHandler value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ISyncService
{
    RoomListService RoomListService();
    Task Start();
    TaskHandle State(SyncServiceStateObserver @listener);
    Task Stop();
}

internal class SyncService : ISyncService, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SyncService(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SyncService()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_syncservice(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_syncservice(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public RoomListService RoomListService()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRoomListService.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(thisPtr, ref _status)
                )
            )
        );
    }

    public async Task Start()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservice_start(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    public TaskHandle State(SyncServiceStateObserver @listener)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTaskHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
                            thisPtr,
                            FfiConverterTypeSyncServiceStateObserver.INSTANCE.Lower(@listener),
                            ref _status
                        )
                )
            )
        );
    }

    public async Task Stop()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }
}

class FfiConverterTypeSyncService : FfiConverter<SyncService, IntPtr>
{
    public static FfiConverterTypeSyncService INSTANCE = new FfiConverterTypeSyncService();

    public override IntPtr Lower(SyncService value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SyncService Lift(IntPtr value)
    {
        return new SyncService(value);
    }

    public override SyncService Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SyncService value)
    {
        return 8;
    }

    public override void Write(SyncService value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ISyncServiceBuilder
{
    /// <exception cref="ClientException"></exception>
    Task<SyncService> Finish();
    SyncServiceBuilder WithCrossProcessLock();

    /// <summary>
    /// Enable the "offline" mode for the [`SyncService`].
    /// </summary>
    SyncServiceBuilder WithOfflineMode();
    Task<SyncServiceBuilder> WithUtdHook(UnableToDecryptDelegate @delegate);
}

internal class SyncServiceBuilder : ISyncServiceBuilder, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SyncServiceBuilder(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~SyncServiceBuilder()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <exception cref="ClientException"></exception>
    public async Task<SyncService> Finish()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeSyncService.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public SyncServiceBuilder WithCrossProcessLock()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSyncServiceBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Enable the "offline" mode for the [`SyncService`].
    /// </summary>
    public SyncServiceBuilder WithOfflineMode()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSyncServiceBuilder.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public async Task<SyncServiceBuilder> WithUtdHook(UnableToDecryptDelegate @delegate)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_utd_hook(
                    thisPtr,
                    FfiConverterTypeUnableToDecryptDelegate.INSTANCE.Lower(@delegate)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeSyncServiceBuilder.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }
}

class FfiConverterTypeSyncServiceBuilder : FfiConverter<SyncServiceBuilder, IntPtr>
{
    public static FfiConverterTypeSyncServiceBuilder INSTANCE = new FfiConverterTypeSyncServiceBuilder();

    public override IntPtr Lower(SyncServiceBuilder value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SyncServiceBuilder Lift(IntPtr value)
    {
        return new SyncServiceBuilder(value);
    }

    public override SyncServiceBuilder Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SyncServiceBuilder value)
    {
        return 8;
    }

    public override void Write(SyncServiceBuilder value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A task handle is a way to keep the handle a task running by itself in
/// detached mode.
///
/// It's a thin wrapper around [`JoinHandle`].
/// </summary>
internal interface ITaskHandle
{
    void Cancel();

    /// <summary>
    /// Check whether the handle is finished.
    /// </summary>
    bool IsFinished();
}

/// <summary>
/// A task handle is a way to keep the handle a task running by itself in
/// detached mode.
///
/// It's a thin wrapper around [`JoinHandle`].
/// </summary>
internal class TaskHandle : ITaskHandle, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public TaskHandle(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~TaskHandle()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_taskhandle(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_taskhandle(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public void Cancel()
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(thisPtr, ref _status)
            )
        );
    }

    /// <summary>
    /// Check whether the handle is finished.
    /// </summary>
    public bool IsFinished()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeTaskHandle : FfiConverter<TaskHandle, IntPtr>
{
    public static FfiConverterTypeTaskHandle INSTANCE = new FfiConverterTypeTaskHandle();

    public override IntPtr Lower(TaskHandle value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override TaskHandle Lift(IntPtr value)
    {
        return new TaskHandle(value);
    }

    public override TaskHandle Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(TaskHandle value)
    {
        return 8;
    }

    public override void Write(TaskHandle value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ITimeline
{
    Task<TaskHandle> AddListener(TimelineListener @listener);
    RoomMessageEventContentWithoutRelation? CreateMessageContent(MessageType @msgType);

    /// <exception cref="ClientException"></exception>
    Task CreatePoll(string @question, List<string> @answers, byte @maxSelections, PollKind @pollKind);

    /// <summary>
    /// Edits an event from the timeline.
    ///
    /// If it was a local event, this will *try* to edit it, if it was not
    /// being sent already. If the event was a remote event, then it will be
    /// redacted by sending an edit request to the server.
    ///
    /// Returns whether the edit did happen. It can only return false for
    /// local events that are being processed.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Edit(EventOrTransactionId @eventOrTransactionId, EditedContent @newContent);

    /// <exception cref="ClientException"></exception>
    Task EndPoll(string @pollStartEventId, string @text);

    /// <exception cref="ClientException"></exception>
    Task FetchDetailsForEvent(string @eventId);
    Task FetchMembers();

    /// <summary>
    /// Get the current timeline item for the given event ID, if any.
    ///
    /// Will return a remote event, *or* a local echo that has been sent but not
    /// yet replaced by a remote echo.
    ///
    /// It's preferable to store the timeline items in the model for your UI, if
    /// possible, instead of just storing IDs and coming back to the timeline
    /// object to look up items.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<EventTimelineItem> GetEventTimelineItemByEventId(string @eventId);

    /// <summary>
    /// Load the reply details for the given event id.
    ///
    /// This will return an `InReplyToDetails` object that contains the details
    /// which will either be ready or an error.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<InReplyToDetails> LoadReplyDetails(string @eventIdStr);

    /// <summary>
    /// Mark the room as read by trying to attach an *unthreaded* read receipt
    /// to the latest room event.
    ///
    /// This works even if the latest event belongs to a thread, as a threaded
    /// reply also belongs to the unthreaded timeline. No threaded receipt
    /// will be sent here (see also #3123).
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task MarkAsRead(ReceiptType @receiptType);

    /// <summary>
    /// Paginate backwards, whether we are in focused mode or in live mode.
    ///
    /// Returns whether we hit the start of the timeline or not.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> PaginateBackwards(ushort @numEvents);

    /// <summary>
    /// Paginate forwards, whether we are in focused mode or in live mode.
    ///
    /// Returns whether we hit the end of the timeline or not.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> PaginateForwards(ushort @numEvents);

    /// <summary>
    /// Adds a new pinned event by sending an updated `m.room.pinned_events`
    /// event containing the new event id.
    ///
    /// Returns `true` if we sent the request, `false` if the event was already
    /// pinned.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> PinEvent(string @eventId);

    /// <summary>
    /// Redacts an event from the timeline.
    ///
    /// Only works for events that exist as timeline items.
    ///
    /// If it was a local event, this will *try* to cancel it, if it was not
    /// being sent already. If the event was a remote event, then it will be
    /// redacted by sending a redaction request to the server.
    ///
    /// Will return an error if the event couldn't be redacted.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task RedactEvent(EventOrTransactionId @eventOrTransactionId, string? @reason);
    void RetryDecryption(List<string> @sessionIds);

    /// <summary>
    /// Queues an event in the room's send queue so it's processed for
    /// sending later.
    ///
    /// Returns an abort handle that allows to abort sending, if it hasn't
    /// happened yet.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<SendHandle> Send(RoomMessageEventContentWithoutRelation @msg);

    /// <exception cref="RoomException"></exception>
    SendAttachmentJoinHandle SendAudio(
        UploadParameters @params,
        AudioInfo @audioInfo,
        ProgressWatcher? @progressWatcher
    );

    /// <exception cref="RoomException"></exception>
    SendAttachmentJoinHandle SendFile(UploadParameters @params, FileInfo @fileInfo, ProgressWatcher? @progressWatcher);

    /// <exception cref="RoomException"></exception>
    SendAttachmentJoinHandle SendImage(
        UploadParameters @params,
        string? @thumbnailPath,
        ImageInfo @imageInfo,
        ProgressWatcher? @progressWatcher
    );
    Task SendLocation(string @body, string @geoUri, string? @description, byte? @zoomLevel, AssetType? @assetType);

    /// <exception cref="ClientException"></exception>
    Task SendPollResponse(string @pollStartEventId, List<string> @answers);

    /// <exception cref="ClientException"></exception>
    Task SendReadReceipt(ReceiptType @receiptType, string @eventId);

    /// <summary>
    /// Send a reply.
    ///
    /// If the replied to event has a thread relation, it is forwarded on the
    /// reply so that clients that support threads can render the reply
    /// inside the thread.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task SendReply(RoomMessageEventContentWithoutRelation @msg, ReplyParameters @replyParams);

    /// <exception cref="RoomException"></exception>
    SendAttachmentJoinHandle SendVideo(
        UploadParameters @params,
        string? @thumbnailPath,
        VideoInfo @videoInfo,
        ProgressWatcher? @progressWatcher
    );

    /// <exception cref="RoomException"></exception>
    SendAttachmentJoinHandle SendVoiceMessage(
        UploadParameters @params,
        AudioInfo @audioInfo,
        List<ushort> @waveform,
        ProgressWatcher? @progressWatcher
    );

    /// <exception cref="ClientException"></exception>
    Task<TaskHandle> SubscribeToBackPaginationStatus(PaginationStatusListener @listener);

    /// <summary>
    /// Toggle a reaction on an event.
    ///
    /// Adds or redacts a reaction based on the state of the reaction at the
    /// time it is called.
    ///
    /// This method works both on local echoes and remote items.
    ///
    /// When redacting a previous reaction, the redaction reason is not set.
    ///
    /// Ensures that only one reaction is sent at a time to avoid race
    /// conditions and spamming the homeserver with requests.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task ToggleReaction(EventOrTransactionId @itemId, string @key);

    /// <summary>
    /// Adds a new pinned event by sending an updated `m.room.pinned_events`
    /// event without the event id we want to remove.
    ///
    /// Returns `true` if we sent the request, `false` if the event wasn't
    /// pinned
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task<bool> UnpinEvent(string @eventId);
}

internal class Timeline : ITimeline, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Timeline(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~Timeline()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_timeline(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_timeline(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public async Task<TaskHandle> AddListener(TimelineListener @listener)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
                    thisPtr,
                    FfiConverterTypeTimelineListener.INSTANCE.Lower(@listener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTaskHandle.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    public RoomMessageEventContentWithoutRelation? CreateMessageContent(MessageType @msgType)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
                            thisPtr,
                            FfiConverterTypeMessageType.INSTANCE.Lower(@msgType),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task CreatePoll(string @question, List<string> @answers, byte @maxSelections, PollKind @pollKind)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@question),
                    FfiConverterSequenceString.INSTANCE.Lower(@answers),
                    FfiConverterUInt8.INSTANCE.Lower(@maxSelections),
                    FfiConverterTypePollKind.INSTANCE.Lower(@pollKind)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Edits an event from the timeline.
    ///
    /// If it was a local event, this will *try* to edit it, if it was not
    /// being sent already. If the event was a remote event, then it will be
    /// redacted by sending an edit request to the server.
    ///
    /// Returns whether the edit did happen. It can only return false for
    /// local events that are being processed.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Edit(EventOrTransactionId @eventOrTransactionId, EditedContent @newContent)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
                    thisPtr,
                    FfiConverterTypeEventOrTransactionId.INSTANCE.Lower(@eventOrTransactionId),
                    FfiConverterTypeEditedContent.INSTANCE.Lower(@newContent)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task EndPoll(string @pollStartEventId, string @text)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@pollStartEventId),
                    FfiConverterString.INSTANCE.Lower(@text)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task FetchDetailsForEvent(string @eventId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public async Task FetchMembers()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Get the current timeline item for the given event ID, if any.
    ///
    /// Will return a remote event, *or* a local echo that has been sent but not
    /// yet replaced by a remote echo.
    ///
    /// It's preferable to store the timeline items in the model for your UI, if
    /// possible, instead of just storing IDs and coming back to the timeline
    /// object to look up items.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<EventTimelineItem> GetEventTimelineItemByEventId(string @eventId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterTypeEventTimelineItem.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Load the reply details for the given event id.
    ///
    /// This will return an `InReplyToDetails` object that contains the details
    /// which will either be ready or an error.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<InReplyToDetails> LoadReplyDetails(string @eventIdStr)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventIdStr)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeInReplyToDetails.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Mark the room as read by trying to attach an *unthreaded* read receipt
    /// to the latest room event.
    ///
    /// This works even if the latest event belongs to a thread, as a threaded
    /// reply also belongs to the unthreaded timeline. No threaded receipt
    /// will be sent here (see also #3123).
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task MarkAsRead(ReceiptType @receiptType)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
                    thisPtr,
                    FfiConverterTypeReceiptType.INSTANCE.Lower(@receiptType)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Paginate backwards, whether we are in focused mode or in live mode.
    ///
    /// Returns whether we hit the start of the timeline or not.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> PaginateBackwards(ushort @numEvents)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
                    thisPtr,
                    FfiConverterUInt16.INSTANCE.Lower(@numEvents)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Paginate forwards, whether we are in focused mode or in live mode.
    ///
    /// Returns whether we hit the end of the timeline or not.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> PaginateForwards(ushort @numEvents)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(
                    thisPtr,
                    FfiConverterUInt16.INSTANCE.Lower(@numEvents)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Adds a new pinned event by sending an updated `m.room.pinned_events`
    /// event containing the new event id.
    ///
    /// Returns `true` if we sent the request, `false` if the event was already
    /// pinned.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> PinEvent(string @eventId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Redacts an event from the timeline.
    ///
    /// Only works for events that exist as timeline items.
    ///
    /// If it was a local event, this will *try* to cancel it, if it was not
    /// being sent already. If the event was a remote event, then it will be
    /// redacted by sending a redaction request to the server.
    ///
    /// Will return an error if the event couldn't be redacted.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task RedactEvent(EventOrTransactionId @eventOrTransactionId, string? @reason)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
                    thisPtr,
                    FfiConverterTypeEventOrTransactionId.INSTANCE.Lower(@eventOrTransactionId),
                    FfiConverterOptionalString.INSTANCE.Lower(@reason)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    public void RetryDecryption(List<string> @sessionIds)
    {
        CallWithPointer(thisPtr =>
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
                        thisPtr,
                        FfiConverterSequenceString.INSTANCE.Lower(@sessionIds),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Queues an event in the room's send queue so it's processed for
    /// sending later.
    ///
    /// Returns an abort handle that allows to abort sending, if it hasn't
    /// happened yet.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<SendHandle> Send(RoomMessageEventContentWithoutRelation @msg)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send(
                    thisPtr,
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lower(@msg)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeSendHandle.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="RoomException"></exception>
    public SendAttachmentJoinHandle SendAudio(
        UploadParameters @params,
        AudioInfo @audioInfo,
        ProgressWatcher? @progressWatcher
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSendAttachmentJoinHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
                            thisPtr,
                            FfiConverterTypeUploadParameters.INSTANCE.Lower(@params),
                            FfiConverterTypeAudioInfo.INSTANCE.Lower(@audioInfo),
                            FfiConverterOptionalTypeProgressWatcher.INSTANCE.Lower(@progressWatcher),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="RoomException"></exception>
    public SendAttachmentJoinHandle SendFile(
        UploadParameters @params,
        FileInfo @fileInfo,
        ProgressWatcher? @progressWatcher
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSendAttachmentJoinHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
                            thisPtr,
                            FfiConverterTypeUploadParameters.INSTANCE.Lower(@params),
                            FfiConverterTypeFileInfo.INSTANCE.Lower(@fileInfo),
                            FfiConverterOptionalTypeProgressWatcher.INSTANCE.Lower(@progressWatcher),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="RoomException"></exception>
    public SendAttachmentJoinHandle SendImage(
        UploadParameters @params,
        string? @thumbnailPath,
        ImageInfo @imageInfo,
        ProgressWatcher? @progressWatcher
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSendAttachmentJoinHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
                            thisPtr,
                            FfiConverterTypeUploadParameters.INSTANCE.Lower(@params),
                            FfiConverterOptionalString.INSTANCE.Lower(@thumbnailPath),
                            FfiConverterTypeImageInfo.INSTANCE.Lower(@imageInfo),
                            FfiConverterOptionalTypeProgressWatcher.INSTANCE.Lower(@progressWatcher),
                            ref _status
                        )
                )
            )
        );
    }

    public async Task SendLocation(
        string @body,
        string @geoUri,
        string? @description,
        byte? @zoomLevel,
        AssetType? @assetType
    )
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@body),
                    FfiConverterString.INSTANCE.Lower(@geoUri),
                    FfiConverterOptionalString.INSTANCE.Lower(@description),
                    FfiConverterOptionalUInt8.INSTANCE.Lower(@zoomLevel),
                    FfiConverterOptionalTypeAssetType.INSTANCE.Lower(@assetType)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task SendPollResponse(string @pollStartEventId, List<string> @answers)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@pollStartEventId),
                    FfiConverterSequenceString.INSTANCE.Lower(@answers)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task SendReadReceipt(ReceiptType @receiptType, string @eventId)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
                    thisPtr,
                    FfiConverterTypeReceiptType.INSTANCE.Lower(@receiptType),
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Send a reply.
    ///
    /// If the replied to event has a thread relation, it is forwarded on the
    /// reply so that clients that support threads can render the reply
    /// inside the thread.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task SendReply(RoomMessageEventContentWithoutRelation @msg, ReplyParameters @replyParams)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
                    thisPtr,
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lower(@msg),
                    FfiConverterTypeReplyParameters.INSTANCE.Lower(@replyParams)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <exception cref="RoomException"></exception>
    public SendAttachmentJoinHandle SendVideo(
        UploadParameters @params,
        string? @thumbnailPath,
        VideoInfo @videoInfo,
        ProgressWatcher? @progressWatcher
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSendAttachmentJoinHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
                            thisPtr,
                            FfiConverterTypeUploadParameters.INSTANCE.Lower(@params),
                            FfiConverterOptionalString.INSTANCE.Lower(@thumbnailPath),
                            FfiConverterTypeVideoInfo.INSTANCE.Lower(@videoInfo),
                            FfiConverterOptionalTypeProgressWatcher.INSTANCE.Lower(@progressWatcher),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="RoomException"></exception>
    public SendAttachmentJoinHandle SendVoiceMessage(
        UploadParameters @params,
        AudioInfo @audioInfo,
        List<ushort> @waveform,
        ProgressWatcher? @progressWatcher
    )
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeSendAttachmentJoinHandle.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeRoomError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
                            thisPtr,
                            FfiConverterTypeUploadParameters.INSTANCE.Lower(@params),
                            FfiConverterTypeAudioInfo.INSTANCE.Lower(@audioInfo),
                            FfiConverterSequenceUInt16.INSTANCE.Lower(@waveform),
                            FfiConverterOptionalTypeProgressWatcher.INSTANCE.Lower(@progressWatcher),
                            ref _status
                        )
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public async Task<TaskHandle> SubscribeToBackPaginationStatus(PaginationStatusListener @listener)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
                    thisPtr,
                    FfiConverterTypePaginationStatusListener.INSTANCE.Lower(@listener)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_pointer(future),
            // Lift
            (result) => FfiConverterTypeTaskHandle.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Toggle a reaction on an event.
    ///
    /// Adds or redacts a reaction based on the state of the reaction at the
    /// time it is called.
    ///
    /// This method works both on local echoes and remote items.
    ///
    /// When redacting a previous reaction, the redaction reason is not set.
    ///
    /// Ensures that only one reaction is sent at a time to avoid race
    /// conditions and spamming the homeserver with requests.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task ToggleReaction(EventOrTransactionId @itemId, string @key)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
                    thisPtr,
                    FfiConverterTypeEventOrTransactionId.INSTANCE.Lower(@itemId),
                    FfiConverterString.INSTANCE.Lower(@key)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// Adds a new pinned event by sending an updated `m.room.pinned_events`
    /// event without the event id we want to remove.
    ///
    /// Returns `true` if we sent the request, `false` if the event wasn't
    /// pinned
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task<bool> UnpinEvent(string @eventId)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@eventId)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeTimeline : FfiConverter<Timeline, IntPtr>
{
    public static FfiConverterTypeTimeline INSTANCE = new FfiConverterTypeTimeline();

    public override IntPtr Lower(Timeline value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Timeline Lift(IntPtr value)
    {
        return new Timeline(value);
    }

    public override Timeline Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Timeline value)
    {
        return 8;
    }

    public override void Write(Timeline value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ITimelineDiff
{
    List<TimelineItem>? Append();
    TimelineChange Change();
    InsertData? Insert();
    TimelineItem? PushBack();
    TimelineItem? PushFront();
    uint? Remove();
    List<TimelineItem>? Reset();
    SetData? Set();
    uint? Truncate();
}

internal class TimelineDiff : ITimelineDiff, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public TimelineDiff(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~TimelineDiff()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_timelinediff(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_timelinediff(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public List<TimelineItem>? Append()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalSequenceTypeTimelineItem.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(thisPtr, ref _status)
                )
            )
        );
    }

    public TimelineChange Change()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTimelineChange.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(thisPtr, ref _status)
                )
            )
        );
    }

    public InsertData? Insert()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeInsertData.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(thisPtr, ref _status)
                )
            )
        );
    }

    public TimelineItem? PushBack()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeTimelineItem.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(thisPtr, ref _status)
                )
            )
        );
    }

    public TimelineItem? PushFront()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeTimelineItem.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(thisPtr, ref _status)
                )
            )
        );
    }

    public uint? Remove()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalUInt32.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(thisPtr, ref _status)
                )
            )
        );
    }

    public List<TimelineItem>? Reset()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalSequenceTypeTimelineItem.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(thisPtr, ref _status)
                )
            )
        );
    }

    public SetData? Set()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeSetData.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(thisPtr, ref _status)
                )
            )
        );
    }

    public uint? Truncate()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalUInt32.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelinediff_truncate(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeTimelineDiff : FfiConverter<TimelineDiff, IntPtr>
{
    public static FfiConverterTypeTimelineDiff INSTANCE = new FfiConverterTypeTimelineDiff();

    public override IntPtr Lower(TimelineDiff value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override TimelineDiff Lift(IntPtr value)
    {
        return new TimelineDiff(value);
    }

    public override TimelineDiff Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(TimelineDiff value)
    {
        return 8;
    }

    public override void Write(TimelineDiff value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ITimelineEvent
{
    string EventId();

    /// <exception cref="ClientException"></exception>
    TimelineEventType EventType();
    string SenderId();
    Timestamp Timestamp();
}

internal class TimelineEvent : ITimelineEvent, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public TimelineEvent(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~TimelineEvent()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_timelineevent(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_timelineevent(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public string EventId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(thisPtr, ref _status)
                )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public TimelineEventType EventType()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTimelineEventType.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeClientError.INSTANCE,
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(thisPtr, ref _status)
                )
            )
        );
    }

    public string SenderId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(thisPtr, ref _status)
                )
            )
        );
    }

    public Timestamp Timestamp()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTimestamp.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeTimelineEvent : FfiConverter<TimelineEvent, IntPtr>
{
    public static FfiConverterTypeTimelineEvent INSTANCE = new FfiConverterTypeTimelineEvent();

    public override IntPtr Lower(TimelineEvent value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override TimelineEvent Lift(IntPtr value)
    {
        return new TimelineEvent(value);
    }

    public override TimelineEvent Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(TimelineEvent value)
    {
        return 8;
    }

    public override void Write(TimelineEvent value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ITimelineEventTypeFilter { }

internal class TimelineEventTypeFilter : ITimelineEventTypeFilter, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public TimelineEventTypeFilter(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~TimelineEventTypeFilter()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public static TimelineEventTypeFilter Exclude(List<FilterTimelineEventType> @eventTypes)
    {
        return new TimelineEventTypeFilter(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
                        FfiConverterSequenceTypeFilterTimelineEventType.INSTANCE.Lower(@eventTypes),
                        ref _status
                    )
            )
        );
    }

    public static TimelineEventTypeFilter Include(List<FilterTimelineEventType> @eventTypes)
    {
        return new TimelineEventTypeFilter(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
                        FfiConverterSequenceTypeFilterTimelineEventType.INSTANCE.Lower(@eventTypes),
                        ref _status
                    )
            )
        );
    }
}

class FfiConverterTypeTimelineEventTypeFilter : FfiConverter<TimelineEventTypeFilter, IntPtr>
{
    public static FfiConverterTypeTimelineEventTypeFilter INSTANCE = new FfiConverterTypeTimelineEventTypeFilter();

    public override IntPtr Lower(TimelineEventTypeFilter value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override TimelineEventTypeFilter Lift(IntPtr value)
    {
        return new TimelineEventTypeFilter(value);
    }

    public override TimelineEventTypeFilter Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(TimelineEventTypeFilter value)
    {
        return 8;
    }

    public override void Write(TimelineEventTypeFilter value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface ITimelineItem
{
    EventTimelineItem? AsEvent();
    VirtualTimelineItem? AsVirtual();
    string FmtDebug();

    /// <summary>
    /// An opaque unique identifier for this timeline item.
    /// </summary>
    TimelineUniqueId UniqueId();
}

internal class TimelineItem : ITimelineItem, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public TimelineItem(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~TimelineItem()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_timelineitem(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_timelineitem(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public EventTimelineItem? AsEvent()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeEventTimelineItem.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(thisPtr, ref _status)
                )
            )
        );
    }

    public VirtualTimelineItem? AsVirtual()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalTypeVirtualTimelineItem.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(thisPtr, ref _status)
                )
            )
        );
    }

    public string FmtDebug()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// An opaque unique identifier for this timeline item.
    /// </summary>
    public TimelineUniqueId UniqueId()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeTimelineUniqueId.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(thisPtr, ref _status)
                )
            )
        );
    }
}

class FfiConverterTypeTimelineItem : FfiConverter<TimelineItem, IntPtr>
{
    public static FfiConverterTypeTimelineItem INSTANCE = new FfiConverterTypeTimelineItem();

    public override IntPtr Lower(TimelineItem value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override TimelineItem Lift(IntPtr value)
    {
        return new TimelineItem(value);
    }

    public override TimelineItem Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(TimelineItem value)
    {
        return 8;
    }

    public override void Write(TimelineItem value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IUnreadNotificationsCount
{
    bool HasNotifications();
    uint HighlightCount();
    uint NotificationCount();
}

internal class UnreadNotificationsCount : IUnreadNotificationsCount, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public UnreadNotificationsCount(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~UnreadNotificationsCount()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public bool HasNotifications()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public uint HighlightCount()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterUInt32.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    public uint NotificationCount()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterUInt32.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeUnreadNotificationsCount : FfiConverter<UnreadNotificationsCount, IntPtr>
{
    public static FfiConverterTypeUnreadNotificationsCount INSTANCE = new FfiConverterTypeUnreadNotificationsCount();

    public override IntPtr Lower(UnreadNotificationsCount value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override UnreadNotificationsCount Lift(IntPtr value)
    {
        return new UnreadNotificationsCount(value);
    }

    public override UnreadNotificationsCount Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(UnreadNotificationsCount value)
    {
        return 8;
    }

    public override void Write(UnreadNotificationsCount value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// The E2EE identity of a user.
/// </summary>
internal interface IUserIdentity
{
    /// <summary>
    /// Was this identity previously verified, and is no longer?
    /// </summary>
    bool HasVerificationViolation();

    /// <summary>
    /// Is the user identity considered to be verified.
    ///
    /// If the identity belongs to another user, our own user identity needs to
    /// be verified as well for the identity to be considered to be verified.
    /// </summary>
    bool IsVerified();

    /// <summary>
    /// Get the public part of the Master key of this user identity.
    ///
    /// The public part of the Master key is usually used to uniquely identify
    /// the identity.
    ///
    /// Returns None if the master key does not actually contain any keys.
    /// </summary>
    string? MasterKey();

    /// <summary>
    /// Remember this identity, ensuring it does not result in a pin violation.
    ///
    /// When we first see a user, we assume their cryptographic identity has not
    /// been tampered with by the homeserver or another entity with
    /// man-in-the-middle capabilities. We remember this identity and call this
    /// action "pinning".
    ///
    /// If the identity presented for the user changes later on, the newly
    /// presented identity is considered to be in "pin violation". This
    /// method explicitly accepts the new identity, allowing it to replace
    /// the previously pinned one and bringing it out of pin violation.
    ///
    /// UIs should display a warning to the user when encountering an identity
    /// which is not verified and is in pin violation.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task Pin();

    /// <summary>
    /// True if we verified this identity at some point in the past.
    ///
    /// To reset this latch back to `false`, one must call
    /// [`UserIdentity::withdraw_verification()`].
    /// </summary>
    bool WasPreviouslyVerified();

    /// <summary>
    /// Remove the requirement for this identity to be verified.
    ///
    /// If an identity was previously verified and is not anymore it will be
    /// reported to the user. In order to remove this notice users have to
    /// verify again or to withdraw the verification requirement.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    Task WithdrawVerification();
}

/// <summary>
/// The E2EE identity of a user.
/// </summary>
internal class UserIdentity : IUserIdentity, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public UserIdentity(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~UserIdentity()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_useridentity(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_useridentity(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Was this identity previously verified, and is no longer?
    /// </summary>
    public bool HasVerificationViolation()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Is the user identity considered to be verified.
    ///
    /// If the identity belongs to another user, our own user identity needs to
    /// be verified as well for the identity to be considered to be verified.
    /// </summary>
    public bool IsVerified()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Get the public part of the Master key of this user identity.
    ///
    /// The public part of the Master key is usually used to uniquely identify
    /// the identity.
    ///
    /// Returns None if the master key does not actually contain any keys.
    /// </summary>
    public string? MasterKey()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterOptionalString.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(thisPtr, ref _status)
                )
            )
        );
    }

    /// <summary>
    /// Remember this identity, ensuring it does not result in a pin violation.
    ///
    /// When we first see a user, we assume their cryptographic identity has not
    /// been tampered with by the homeserver or another entity with
    /// man-in-the-middle capabilities. We remember this identity and call this
    /// action "pinning".
    ///
    /// If the identity presented for the user changes later on, the newly
    /// presented identity is considered to be in "pin violation". This
    /// method explicitly accepts the new identity, allowing it to replace
    /// the previously pinned one and bringing it out of pin violation.
    ///
    /// UIs should display a warning to the user when encountering an identity
    /// which is not verified and is in pin violation.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task Pin()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }

    /// <summary>
    /// True if we verified this identity at some point in the past.
    ///
    /// To reset this latch back to `false`, one must call
    /// [`UserIdentity::withdraw_verification()`].
    /// </summary>
    public bool WasPreviouslyVerified()
    {
        return CallWithPointer(thisPtr =>
            FfiConverterBoolean.INSTANCE.Lift(
                _UniffiHelpers.RustCall(
                    (ref UniffiRustCallStatus _status) =>
                        _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(
                            thisPtr,
                            ref _status
                        )
                )
            )
        );
    }

    /// <summary>
    /// Remove the requirement for this identity to be verified.
    ///
    /// If an identity was previously verified and is not anymore it will be
    /// reported to the user. In order to remove this notice users have to
    /// verify again or to withdraw the verification requirement.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public async Task WithdrawVerification()
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
    }
}

class FfiConverterTypeUserIdentity : FfiConverter<UserIdentity, IntPtr>
{
    public static FfiConverterTypeUserIdentity INSTANCE = new FfiConverterTypeUserIdentity();

    public override IntPtr Lower(UserIdentity value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override UserIdentity Lift(IntPtr value)
    {
        return new UserIdentity(value);
    }

    public override UserIdentity Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(UserIdentity value)
    {
        return 8;
    }

    public override void Write(UserIdentity value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// An object that handles all interactions of a widget living inside a webview
/// or IFrame with the Matrix world.
/// </summary>
internal interface IWidgetDriver
{
    Task Run(Room @room, WidgetCapabilitiesProvider @capabilitiesProvider);
}

/// <summary>
/// An object that handles all interactions of a widget living inside a webview
/// or IFrame with the Matrix world.
/// </summary>
internal class WidgetDriver : IWidgetDriver, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public WidgetDriver(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~WidgetDriver()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_widgetdriver(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    public async Task Run(Room @room, WidgetCapabilitiesProvider @capabilitiesProvider)
    {
        await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
                    thisPtr,
                    FfiConverterTypeRoom.INSTANCE.Lower(@room),
                    FfiConverterTypeWidgetCapabilitiesProvider.INSTANCE.Lower(@capabilitiesProvider)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_void(future),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }
}

class FfiConverterTypeWidgetDriver : FfiConverter<WidgetDriver, IntPtr>
{
    public static FfiConverterTypeWidgetDriver INSTANCE = new FfiConverterTypeWidgetDriver();

    public override IntPtr Lower(WidgetDriver value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override WidgetDriver Lift(IntPtr value)
    {
        return new WidgetDriver(value);
    }

    public override WidgetDriver Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(WidgetDriver value)
    {
        return 8;
    }

    public override void Write(WidgetDriver value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

/// <summary>
/// A handle that encapsulates the communication between a widget driver and the
/// corresponding widget (inside a webview or IFrame).
/// </summary>
internal interface IWidgetDriverHandle
{
    /// <summary>
    /// Receive a message from the widget driver.
    ///
    /// The message must be passed on to the widget.
    ///
    /// Returns `None` if the widget driver is no longer running.
    /// </summary>
    Task<string?> Recv();

    /// <summary>
    ///
    /// Returns `false` if the widget driver is no longer running.
    /// </summary>
    Task<bool> Send(string @msg);
}

/// <summary>
/// A handle that encapsulates the communication between a widget driver and the
/// corresponding widget (inside a webview or IFrame).
/// </summary>
internal class WidgetDriverHandle : IWidgetDriverHandle, IDisposable
{
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public WidgetDriverHandle(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    ~WidgetDriverHandle()
    {
        Destroy();
    }

    protected void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(this.pointer, ref status);
            }
        );
    }

    protected IntPtr CloneRustArcPtr()
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(this.pointer, ref status);
            }
        );
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format("'{0}' object has already been destroyed", this.GetType().Name)
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format("'{0}' call counter would overflow", this.GetType().Name)
                );
        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(CloneRustArcPtr());
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    /// <summary>
    /// Receive a message from the widget driver.
    ///
    /// The message must be passed on to the widget.
    ///
    /// Returns `None` if the widget driver is no longer running.
    /// </summary>
    public async Task<string?> Recv()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(thisPtr);
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    ///
    /// Returns `false` if the widget driver is no longer running.
    /// </summary>
    public async Task<bool> Send(string @msg)
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
                    thisPtr,
                    FfiConverterString.INSTANCE.Lower(@msg)
                );
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_i8(future),
            // Lift
            (result) => FfiConverterBoolean.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }
}

class FfiConverterTypeWidgetDriverHandle : FfiConverter<WidgetDriverHandle, IntPtr>
{
    public static FfiConverterTypeWidgetDriverHandle INSTANCE = new FfiConverterTypeWidgetDriverHandle();

    public override IntPtr Lower(WidgetDriverHandle value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override WidgetDriverHandle Lift(IntPtr value)
    {
        return new WidgetDriverHandle(value);
    }

    public override WidgetDriverHandle Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(WidgetDriverHandle value)
    {
        return 8;
    }

    public override void Write(WidgetDriverHandle value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal record AudioInfo(TimeSpan? @duration, ulong? @size, string? @mimetype) { }

class FfiConverterTypeAudioInfo : FfiConverterRustBuffer<AudioInfo>
{
    public static FfiConverterTypeAudioInfo INSTANCE = new FfiConverterTypeAudioInfo();

    public override AudioInfo Read(BigEndianStream stream)
    {
        return new AudioInfo(
            @duration: FfiConverterOptionalDuration.INSTANCE.Read(stream),
            @size: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @mimetype: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AudioInfo value)
    {
        return 0
            + FfiConverterOptionalDuration.INSTANCE.AllocationSize(value.@duration)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@size)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@mimetype);
    }

    public override void Write(AudioInfo value, BigEndianStream stream)
    {
        FfiConverterOptionalDuration.INSTANCE.Write(value.@duration, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@size, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@mimetype, stream);
    }
}

/// <param name="filename">
/// The computed filename, for use in a client.
/// </param>
internal record AudioMessageContent(
    /// <summary>
    /// The computed filename, for use in a client.
    /// </summary>
    string @filename,
    string? @caption,
    FormattedBody? @formattedCaption,
    MediaSource @source,
    AudioInfo? @info,
    UnstableAudioDetailsContent? @audio,
    UnstableVoiceContent? @voice
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@filename,
            this.@caption,
            this.@formattedCaption,
            this.@source,
            this.@info,
            this.@audio,
            this.@voice
        );
    }
}

class FfiConverterTypeAudioMessageContent : FfiConverterRustBuffer<AudioMessageContent>
{
    public static FfiConverterTypeAudioMessageContent INSTANCE = new FfiConverterTypeAudioMessageContent();

    public override AudioMessageContent Read(BigEndianStream stream)
    {
        return new AudioMessageContent(
            @filename: FfiConverterString.INSTANCE.Read(stream),
            @caption: FfiConverterOptionalString.INSTANCE.Read(stream),
            @formattedCaption: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream),
            @source: FfiConverterTypeMediaSource.INSTANCE.Read(stream),
            @info: FfiConverterOptionalTypeAudioInfo.INSTANCE.Read(stream),
            @audio: FfiConverterOptionalTypeUnstableAudioDetailsContent.INSTANCE.Read(stream),
            @voice: FfiConverterOptionalTypeUnstableVoiceContent.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AudioMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@filename)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@caption)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formattedCaption)
            + FfiConverterTypeMediaSource.INSTANCE.AllocationSize(value.@source)
            + FfiConverterOptionalTypeAudioInfo.INSTANCE.AllocationSize(value.@info)
            + FfiConverterOptionalTypeUnstableAudioDetailsContent.INSTANCE.AllocationSize(value.@audio)
            + FfiConverterOptionalTypeUnstableVoiceContent.INSTANCE.AllocationSize(value.@voice);
    }

    public override void Write(AudioMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@filename, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@caption, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formattedCaption, stream);
        FfiConverterTypeMediaSource.INSTANCE.Write(value.@source, stream);
        FfiConverterOptionalTypeAudioInfo.INSTANCE.Write(value.@info, stream);
        FfiConverterOptionalTypeUnstableAudioDetailsContent.INSTANCE.Write(value.@audio, stream);
        FfiConverterOptionalTypeUnstableVoiceContent.INSTANCE.Write(value.@voice, stream);
    }
}

/// <param name="identifier">
/// One of the user's identifiers.
/// </param>
/// <param name="password">
/// The plaintext password.
/// </param>
internal record AuthDataPasswordDetails(
    /// <summary>
    /// One of the user's identifiers.
    /// </summary>
    string @identifier,
    /// <summary>
    /// The plaintext password.
    /// </summary>
    string @password
) { }

class FfiConverterTypeAuthDataPasswordDetails : FfiConverterRustBuffer<AuthDataPasswordDetails>
{
    public static FfiConverterTypeAuthDataPasswordDetails INSTANCE = new FfiConverterTypeAuthDataPasswordDetails();

    public override AuthDataPasswordDetails Read(BigEndianStream stream)
    {
        return new AuthDataPasswordDetails(
            @identifier: FfiConverterString.INSTANCE.Read(stream),
            @password: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AuthDataPasswordDetails value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@identifier)
            + FfiConverterString.INSTANCE.AllocationSize(value.@password);
    }

    public override void Write(AuthDataPasswordDetails value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@identifier, stream);
        FfiConverterString.INSTANCE.Write(value.@password, stream);
    }
}

/// <param name="client_id">
/// The client_id provides the widget with the option to behave differently
/// for different clients. e.g org.example.ios.
/// </param>
/// <param name="language_tag">
/// The language tag the client is set to e.g. en-us. (Undefined and invalid
/// becomes: `en-US`)
/// </param>
/// <param name="theme">
/// A string describing the theme (dark, light) or org.example.dark.
/// (default: `light`)
/// </param>
internal record ClientProperties(
    /// <summary>
    /// The client_id provides the widget with the option to behave differently
    /// for different clients. e.g org.example.ios.
    /// </summary>
    string @clientId,
    /// <summary>
    /// The language tag the client is set to e.g. en-us. (Undefined and invalid
    /// becomes: `en-US`)
    /// </summary>
    string? @languageTag,
    /// <summary>
    /// A string describing the theme (dark, light) or org.example.dark.
    /// (default: `light`)
    /// </summary>
    string? @theme
) { }

class FfiConverterTypeClientProperties : FfiConverterRustBuffer<ClientProperties>
{
    public static FfiConverterTypeClientProperties INSTANCE = new FfiConverterTypeClientProperties();

    public override ClientProperties Read(BigEndianStream stream)
    {
        return new ClientProperties(
            @clientId: FfiConverterString.INSTANCE.Read(stream),
            @languageTag: FfiConverterOptionalString.INSTANCE.Read(stream),
            @theme: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ClientProperties value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@clientId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@languageTag)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@theme);
    }

    public override void Write(ClientProperties value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@clientId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@languageTag, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@theme, stream);
    }
}

/// <summary>
/// Current draft of the composer for the room.
/// </summary>
/// <param name="plain_text">
/// The draft content in plain text.
/// </param>
/// <param name="html_text">
/// If the message is formatted in HTML, the HTML representation of the
/// message.
/// </param>
/// <param name="draft_type">
/// The type of draft.
/// </param>
internal record ComposerDraft(
    /// <summary>
    /// The draft content in plain text.
    /// </summary>
    string @plainText,
    /// <summary>
    /// If the message is formatted in HTML, the HTML representation of the
    /// message.
    /// </summary>
    string? @htmlText,
    /// <summary>
    /// The type of draft.
    /// </summary>
    ComposerDraftType @draftType
) { }

class FfiConverterTypeComposerDraft : FfiConverterRustBuffer<ComposerDraft>
{
    public static FfiConverterTypeComposerDraft INSTANCE = new FfiConverterTypeComposerDraft();

    public override ComposerDraft Read(BigEndianStream stream)
    {
        return new ComposerDraft(
            @plainText: FfiConverterString.INSTANCE.Read(stream),
            @htmlText: FfiConverterOptionalString.INSTANCE.Read(stream),
            @draftType: FfiConverterTypeComposerDraftType.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ComposerDraft value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@plainText)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@htmlText)
            + FfiConverterTypeComposerDraftType.INSTANCE.AllocationSize(value.@draftType);
    }

    public override void Write(ComposerDraft value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@plainText, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@htmlText, stream);
        FfiConverterTypeComposerDraftType.INSTANCE.Write(value.@draftType, stream);
    }
}

/// <remarks>
/// <b>UniFFI Warning:</b> Optional parameters have been reordered because
/// of a C# syntax limitation. Use named parameters for compatibility with
/// future ordering changes.
/// </remarks>
internal record CreateRoomParameters(
    string? @name,
    bool @isEncrypted,
    RoomVisibility @visibility,
    RoomPreset @preset,
    string? @topic = null,
    bool @isDirect = false,
    List<string>? @invite = null,
    string? @avatar = null,
    PowerLevels? @powerLevelContentOverride = null,
    JoinRule? @joinRuleOverride = null,
    RoomHistoryVisibility? @historyVisibilityOverride = null,
    string? @canonicalAlias = null
) { }

class FfiConverterTypeCreateRoomParameters : FfiConverterRustBuffer<CreateRoomParameters>
{
    public static FfiConverterTypeCreateRoomParameters INSTANCE = new FfiConverterTypeCreateRoomParameters();

    public override CreateRoomParameters Read(BigEndianStream stream)
    {
        return new CreateRoomParameters(
            @name: FfiConverterOptionalString.INSTANCE.Read(stream),
            @topic: FfiConverterOptionalString.INSTANCE.Read(stream),
            @isEncrypted: FfiConverterBoolean.INSTANCE.Read(stream),
            @isDirect: FfiConverterBoolean.INSTANCE.Read(stream),
            @visibility: FfiConverterTypeRoomVisibility.INSTANCE.Read(stream),
            @preset: FfiConverterTypeRoomPreset.INSTANCE.Read(stream),
            @invite: FfiConverterOptionalSequenceString.INSTANCE.Read(stream),
            @avatar: FfiConverterOptionalString.INSTANCE.Read(stream),
            @powerLevelContentOverride: FfiConverterOptionalTypePowerLevels.INSTANCE.Read(stream),
            @joinRuleOverride: FfiConverterOptionalTypeJoinRule.INSTANCE.Read(stream),
            @historyVisibilityOverride: FfiConverterOptionalTypeRoomHistoryVisibility.INSTANCE.Read(stream),
            @canonicalAlias: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CreateRoomParameters value)
    {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@topic)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isEncrypted)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isDirect)
            + FfiConverterTypeRoomVisibility.INSTANCE.AllocationSize(value.@visibility)
            + FfiConverterTypeRoomPreset.INSTANCE.AllocationSize(value.@preset)
            + FfiConverterOptionalSequenceString.INSTANCE.AllocationSize(value.@invite)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatar)
            + FfiConverterOptionalTypePowerLevels.INSTANCE.AllocationSize(value.@powerLevelContentOverride)
            + FfiConverterOptionalTypeJoinRule.INSTANCE.AllocationSize(value.@joinRuleOverride)
            + FfiConverterOptionalTypeRoomHistoryVisibility.INSTANCE.AllocationSize(value.@historyVisibilityOverride)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@canonicalAlias);
    }

    public override void Write(CreateRoomParameters value, BigEndianStream stream)
    {
        FfiConverterOptionalString.INSTANCE.Write(value.@name, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@topic, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isEncrypted, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isDirect, stream);
        FfiConverterTypeRoomVisibility.INSTANCE.Write(value.@visibility, stream);
        FfiConverterTypeRoomPreset.INSTANCE.Write(value.@preset, stream);
        FfiConverterOptionalSequenceString.INSTANCE.Write(value.@invite, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatar, stream);
        FfiConverterOptionalTypePowerLevels.INSTANCE.Write(value.@powerLevelContentOverride, stream);
        FfiConverterOptionalTypeJoinRule.INSTANCE.Write(value.@joinRuleOverride, stream);
        FfiConverterOptionalTypeRoomHistoryVisibility.INSTANCE.Write(value.@historyVisibilityOverride, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@canonicalAlias, stream);
    }
}

/// <summary>
/// Well-known settings specific to ElementCall
/// </summary>
internal record ElementCallWellKnown(string @widgetUrl) { }

class FfiConverterTypeElementCallWellKnown : FfiConverterRustBuffer<ElementCallWellKnown>
{
    public static FfiConverterTypeElementCallWellKnown INSTANCE = new FfiConverterTypeElementCallWellKnown();

    public override ElementCallWellKnown Read(BigEndianStream stream)
    {
        return new ElementCallWellKnown(@widgetUrl: FfiConverterString.INSTANCE.Read(stream));
    }

    public override int AllocationSize(ElementCallWellKnown value)
    {
        return 0 + FfiConverterString.INSTANCE.AllocationSize(value.@widgetUrl);
    }

    public override void Write(ElementCallWellKnown value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@widgetUrl, stream);
    }
}

/// <summary>
/// Element specific well-known settings
/// </summary>
internal record ElementWellKnown(ElementCallWellKnown? @call, string? @registrationHelperUrl) { }

class FfiConverterTypeElementWellKnown : FfiConverterRustBuffer<ElementWellKnown>
{
    public static FfiConverterTypeElementWellKnown INSTANCE = new FfiConverterTypeElementWellKnown();

    public override ElementWellKnown Read(BigEndianStream stream)
    {
        return new ElementWellKnown(
            @call: FfiConverterOptionalTypeElementCallWellKnown.INSTANCE.Read(stream),
            @registrationHelperUrl: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ElementWellKnown value)
    {
        return 0
            + FfiConverterOptionalTypeElementCallWellKnown.INSTANCE.AllocationSize(value.@call)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@registrationHelperUrl);
    }

    public override void Write(ElementWellKnown value, BigEndianStream stream)
    {
        FfiConverterOptionalTypeElementCallWellKnown.INSTANCE.Write(value.@call, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@registrationHelperUrl, stream);
    }
}

internal record EmoteMessageContent(string @body, FormattedBody? @formatted) { }

class FfiConverterTypeEmoteMessageContent : FfiConverterRustBuffer<EmoteMessageContent>
{
    public static FfiConverterTypeEmoteMessageContent INSTANCE = new FfiConverterTypeEmoteMessageContent();

    public override EmoteMessageContent Read(BigEndianStream stream)
    {
        return new EmoteMessageContent(
            @body: FfiConverterString.INSTANCE.Read(stream),
            @formatted: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(EmoteMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@body)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formatted);
    }

    public override void Write(EmoteMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@body, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formatted, stream);
    }
}

/// <param name="is_remote">
/// Indicates that an event is remote.
/// </param>
internal record EventTimelineItem(
    /// <summary>
    /// Indicates that an event is remote.
    /// </summary>
    bool @isRemote,
    EventOrTransactionId @eventOrTransactionId,
    string @sender,
    ProfileDetails @senderProfile,
    bool @isOwn,
    bool @isEditable,
    TimelineItemContent @content,
    Timestamp @timestamp,
    EventSendState? @localSendState,
    ulong? @localCreatedAt,
    Dictionary<string, Receipt> @readReceipts,
    EventItemOrigin? @origin,
    bool @canBeRepliedTo,
    LazyTimelineItemProvider @lazyProvider
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@isRemote,
            this.@eventOrTransactionId,
            this.@sender,
            this.@senderProfile,
            this.@isOwn,
            this.@isEditable,
            this.@content,
            this.@timestamp,
            this.@localSendState,
            this.@localCreatedAt,
            this.@readReceipts,
            this.@origin,
            this.@canBeRepliedTo,
            this.@lazyProvider
        );
    }
}

class FfiConverterTypeEventTimelineItem : FfiConverterRustBuffer<EventTimelineItem>
{
    public static FfiConverterTypeEventTimelineItem INSTANCE = new FfiConverterTypeEventTimelineItem();

    public override EventTimelineItem Read(BigEndianStream stream)
    {
        return new EventTimelineItem(
            @isRemote: FfiConverterBoolean.INSTANCE.Read(stream),
            @eventOrTransactionId: FfiConverterTypeEventOrTransactionId.INSTANCE.Read(stream),
            @sender: FfiConverterString.INSTANCE.Read(stream),
            @senderProfile: FfiConverterTypeProfileDetails.INSTANCE.Read(stream),
            @isOwn: FfiConverterBoolean.INSTANCE.Read(stream),
            @isEditable: FfiConverterBoolean.INSTANCE.Read(stream),
            @content: FfiConverterTypeTimelineItemContent.INSTANCE.Read(stream),
            @timestamp: FfiConverterTypeTimestamp.INSTANCE.Read(stream),
            @localSendState: FfiConverterOptionalTypeEventSendState.INSTANCE.Read(stream),
            @localCreatedAt: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @readReceipts: FfiConverterDictionaryStringTypeReceipt.INSTANCE.Read(stream),
            @origin: FfiConverterOptionalTypeEventItemOrigin.INSTANCE.Read(stream),
            @canBeRepliedTo: FfiConverterBoolean.INSTANCE.Read(stream),
            @lazyProvider: FfiConverterTypeLazyTimelineItemProvider.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(EventTimelineItem value)
    {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isRemote)
            + FfiConverterTypeEventOrTransactionId.INSTANCE.AllocationSize(value.@eventOrTransactionId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@sender)
            + FfiConverterTypeProfileDetails.INSTANCE.AllocationSize(value.@senderProfile)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isOwn)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isEditable)
            + FfiConverterTypeTimelineItemContent.INSTANCE.AllocationSize(value.@content)
            + FfiConverterTypeTimestamp.INSTANCE.AllocationSize(value.@timestamp)
            + FfiConverterOptionalTypeEventSendState.INSTANCE.AllocationSize(value.@localSendState)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@localCreatedAt)
            + FfiConverterDictionaryStringTypeReceipt.INSTANCE.AllocationSize(value.@readReceipts)
            + FfiConverterOptionalTypeEventItemOrigin.INSTANCE.AllocationSize(value.@origin)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@canBeRepliedTo)
            + FfiConverterTypeLazyTimelineItemProvider.INSTANCE.AllocationSize(value.@lazyProvider);
    }

    public override void Write(EventTimelineItem value, BigEndianStream stream)
    {
        FfiConverterBoolean.INSTANCE.Write(value.@isRemote, stream);
        FfiConverterTypeEventOrTransactionId.INSTANCE.Write(value.@eventOrTransactionId, stream);
        FfiConverterString.INSTANCE.Write(value.@sender, stream);
        FfiConverterTypeProfileDetails.INSTANCE.Write(value.@senderProfile, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isOwn, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isEditable, stream);
        FfiConverterTypeTimelineItemContent.INSTANCE.Write(value.@content, stream);
        FfiConverterTypeTimestamp.INSTANCE.Write(value.@timestamp, stream);
        FfiConverterOptionalTypeEventSendState.INSTANCE.Write(value.@localSendState, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@localCreatedAt, stream);
        FfiConverterDictionaryStringTypeReceipt.INSTANCE.Write(value.@readReceipts, stream);
        FfiConverterOptionalTypeEventItemOrigin.INSTANCE.Write(value.@origin, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@canBeRepliedTo, stream);
        FfiConverterTypeLazyTimelineItemProvider.INSTANCE.Write(value.@lazyProvider, stream);
    }
}

internal record EventTimelineItemDebugInfo(string @model, string? @originalJson, string? @latestEditJson) { }

class FfiConverterTypeEventTimelineItemDebugInfo : FfiConverterRustBuffer<EventTimelineItemDebugInfo>
{
    public static FfiConverterTypeEventTimelineItemDebugInfo INSTANCE =
        new FfiConverterTypeEventTimelineItemDebugInfo();

    public override EventTimelineItemDebugInfo Read(BigEndianStream stream)
    {
        return new EventTimelineItemDebugInfo(
            @model: FfiConverterString.INSTANCE.Read(stream),
            @originalJson: FfiConverterOptionalString.INSTANCE.Read(stream),
            @latestEditJson: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(EventTimelineItemDebugInfo value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@model)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@originalJson)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@latestEditJson);
    }

    public override void Write(EventTimelineItemDebugInfo value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@model, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@originalJson, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@latestEditJson, stream);
    }
}

internal record FileInfo(string? @mimetype, ulong? @size, ThumbnailInfo? @thumbnailInfo, MediaSource? @thumbnailSource)
    : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@mimetype, this.@size, this.@thumbnailInfo, this.@thumbnailSource);
    }
}

class FfiConverterTypeFileInfo : FfiConverterRustBuffer<FileInfo>
{
    public static FfiConverterTypeFileInfo INSTANCE = new FfiConverterTypeFileInfo();

    public override FileInfo Read(BigEndianStream stream)
    {
        return new FileInfo(
            @mimetype: FfiConverterOptionalString.INSTANCE.Read(stream),
            @size: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.INSTANCE.Read(stream),
            @thumbnailSource: FfiConverterOptionalTypeMediaSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(FileInfo value)
    {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@mimetype)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@size)
            + FfiConverterOptionalTypeThumbnailInfo.INSTANCE.AllocationSize(value.@thumbnailInfo)
            + FfiConverterOptionalTypeMediaSource.INSTANCE.AllocationSize(value.@thumbnailSource);
    }

    public override void Write(FileInfo value, BigEndianStream stream)
    {
        FfiConverterOptionalString.INSTANCE.Write(value.@mimetype, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@size, stream);
        FfiConverterOptionalTypeThumbnailInfo.INSTANCE.Write(value.@thumbnailInfo, stream);
        FfiConverterOptionalTypeMediaSource.INSTANCE.Write(value.@thumbnailSource, stream);
    }
}

/// <param name="filename">
/// The computed filename, for use in a client.
/// </param>
internal record FileMessageContent(
    /// <summary>
    /// The computed filename, for use in a client.
    /// </summary>
    string @filename,
    string? @caption,
    FormattedBody? @formattedCaption,
    MediaSource @source,
    FileInfo? @info
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@filename, this.@caption, this.@formattedCaption, this.@source, this.@info);
    }
}

class FfiConverterTypeFileMessageContent : FfiConverterRustBuffer<FileMessageContent>
{
    public static FfiConverterTypeFileMessageContent INSTANCE = new FfiConverterTypeFileMessageContent();

    public override FileMessageContent Read(BigEndianStream stream)
    {
        return new FileMessageContent(
            @filename: FfiConverterString.INSTANCE.Read(stream),
            @caption: FfiConverterOptionalString.INSTANCE.Read(stream),
            @formattedCaption: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream),
            @source: FfiConverterTypeMediaSource.INSTANCE.Read(stream),
            @info: FfiConverterOptionalTypeFileInfo.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(FileMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@filename)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@caption)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formattedCaption)
            + FfiConverterTypeMediaSource.INSTANCE.AllocationSize(value.@source)
            + FfiConverterOptionalTypeFileInfo.INSTANCE.AllocationSize(value.@info);
    }

    public override void Write(FileMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@filename, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@caption, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formattedCaption, stream);
        FfiConverterTypeMediaSource.INSTANCE.Write(value.@source, stream);
        FfiConverterOptionalTypeFileInfo.INSTANCE.Write(value.@info, stream);
    }
}

internal record FormattedBody(MessageFormat @format, string @body) { }

class FfiConverterTypeFormattedBody : FfiConverterRustBuffer<FormattedBody>
{
    public static FfiConverterTypeFormattedBody INSTANCE = new FfiConverterTypeFormattedBody();

    public override FormattedBody Read(BigEndianStream stream)
    {
        return new FormattedBody(
            @format: FfiConverterTypeMessageFormat.INSTANCE.Read(stream),
            @body: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(FormattedBody value)
    {
        return 0
            + FfiConverterTypeMessageFormat.INSTANCE.AllocationSize(value.@format)
            + FfiConverterString.INSTANCE.AllocationSize(value.@body);
    }

    public override void Write(FormattedBody value, BigEndianStream stream)
    {
        FfiConverterTypeMessageFormat.INSTANCE.Write(value.@format, stream);
        FfiConverterString.INSTANCE.Write(value.@body, stream);
    }
}

internal record HttpPusherData(string @url, PushFormat? @format, string? @defaultPayload) { }

class FfiConverterTypeHttpPusherData : FfiConverterRustBuffer<HttpPusherData>
{
    public static FfiConverterTypeHttpPusherData INSTANCE = new FfiConverterTypeHttpPusherData();

    public override HttpPusherData Read(BigEndianStream stream)
    {
        return new HttpPusherData(
            @url: FfiConverterString.INSTANCE.Read(stream),
            @format: FfiConverterOptionalTypePushFormat.INSTANCE.Read(stream),
            @defaultPayload: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(HttpPusherData value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@url)
            + FfiConverterOptionalTypePushFormat.INSTANCE.AllocationSize(value.@format)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@defaultPayload);
    }

    public override void Write(HttpPusherData value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@url, stream);
        FfiConverterOptionalTypePushFormat.INSTANCE.Write(value.@format, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@defaultPayload, stream);
    }
}

/// <param name="user_id">
/// The user ID of the user whose identity status changed
/// </param>
/// <param name="changed_to">
/// The new state of the identity of the user.
/// </param>
internal record IdentityStatusChange(
    /// <summary>
    /// The user ID of the user whose identity status changed
    /// </summary>
    string @userId,
    /// <summary>
    /// The new state of the identity of the user.
    /// </summary>
    IdentityState @changedTo
) { }

class FfiConverterTypeIdentityStatusChange : FfiConverterRustBuffer<IdentityStatusChange>
{
    public static FfiConverterTypeIdentityStatusChange INSTANCE = new FfiConverterTypeIdentityStatusChange();

    public override IdentityStatusChange Read(BigEndianStream stream)
    {
        return new IdentityStatusChange(
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @changedTo: FfiConverterTypeIdentityState.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(IdentityStatusChange value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterTypeIdentityState.INSTANCE.AllocationSize(value.@changedTo);
    }

    public override void Write(IdentityStatusChange value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterTypeIdentityState.INSTANCE.Write(value.@changedTo, stream);
    }
}

internal record ImageInfo(
    ulong? @height,
    ulong? @width,
    string? @mimetype,
    ulong? @size,
    ThumbnailInfo? @thumbnailInfo,
    MediaSource? @thumbnailSource,
    string? @blurhash,
    bool? @isAnimated
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@height,
            this.@width,
            this.@mimetype,
            this.@size,
            this.@thumbnailInfo,
            this.@thumbnailSource,
            this.@blurhash,
            this.@isAnimated
        );
    }
}

class FfiConverterTypeImageInfo : FfiConverterRustBuffer<ImageInfo>
{
    public static FfiConverterTypeImageInfo INSTANCE = new FfiConverterTypeImageInfo();

    public override ImageInfo Read(BigEndianStream stream)
    {
        return new ImageInfo(
            @height: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @width: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @mimetype: FfiConverterOptionalString.INSTANCE.Read(stream),
            @size: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.INSTANCE.Read(stream),
            @thumbnailSource: FfiConverterOptionalTypeMediaSource.INSTANCE.Read(stream),
            @blurhash: FfiConverterOptionalString.INSTANCE.Read(stream),
            @isAnimated: FfiConverterOptionalBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ImageInfo value)
    {
        return 0
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@height)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@width)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@mimetype)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@size)
            + FfiConverterOptionalTypeThumbnailInfo.INSTANCE.AllocationSize(value.@thumbnailInfo)
            + FfiConverterOptionalTypeMediaSource.INSTANCE.AllocationSize(value.@thumbnailSource)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@blurhash)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isAnimated);
    }

    public override void Write(ImageInfo value, BigEndianStream stream)
    {
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@height, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@width, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@mimetype, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@size, stream);
        FfiConverterOptionalTypeThumbnailInfo.INSTANCE.Write(value.@thumbnailInfo, stream);
        FfiConverterOptionalTypeMediaSource.INSTANCE.Write(value.@thumbnailSource, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@blurhash, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@isAnimated, stream);
    }
}

/// <param name="filename">
/// The computed filename, for use in a client.
/// </param>
internal record ImageMessageContent(
    /// <summary>
    /// The computed filename, for use in a client.
    /// </summary>
    string @filename,
    string? @caption,
    FormattedBody? @formattedCaption,
    MediaSource @source,
    ImageInfo? @info
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@filename, this.@caption, this.@formattedCaption, this.@source, this.@info);
    }
}

class FfiConverterTypeImageMessageContent : FfiConverterRustBuffer<ImageMessageContent>
{
    public static FfiConverterTypeImageMessageContent INSTANCE = new FfiConverterTypeImageMessageContent();

    public override ImageMessageContent Read(BigEndianStream stream)
    {
        return new ImageMessageContent(
            @filename: FfiConverterString.INSTANCE.Read(stream),
            @caption: FfiConverterOptionalString.INSTANCE.Read(stream),
            @formattedCaption: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream),
            @source: FfiConverterTypeMediaSource.INSTANCE.Read(stream),
            @info: FfiConverterOptionalTypeImageInfo.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ImageMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@filename)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@caption)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formattedCaption)
            + FfiConverterTypeMediaSource.INSTANCE.AllocationSize(value.@source)
            + FfiConverterOptionalTypeImageInfo.INSTANCE.AllocationSize(value.@info);
    }

    public override void Write(ImageMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@filename, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@caption, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formattedCaption, stream);
        FfiConverterTypeMediaSource.INSTANCE.Write(value.@source, stream);
        FfiConverterOptionalTypeImageInfo.INSTANCE.Write(value.@info, stream);
    }
}

internal record InsertData(uint @index, TimelineItem @item) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@index, this.@item);
    }
}

class FfiConverterTypeInsertData : FfiConverterRustBuffer<InsertData>
{
    public static FfiConverterTypeInsertData INSTANCE = new FfiConverterTypeInsertData();

    public override InsertData Read(BigEndianStream stream)
    {
        return new InsertData(
            @index: FfiConverterUInt32.INSTANCE.Read(stream),
            @item: FfiConverterTypeTimelineItem.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(InsertData value)
    {
        return 0
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@index)
            + FfiConverterTypeTimelineItem.INSTANCE.AllocationSize(value.@item);
    }

    public override void Write(InsertData value, BigEndianStream stream)
    {
        FfiConverterUInt32.INSTANCE.Write(value.@index, stream);
        FfiConverterTypeTimelineItem.INSTANCE.Write(value.@item, stream);
    }
}

/// <summary>
/// An FFI representation of a request to join a room.
/// </summary>
/// <param name="event_id">
/// The event id of the event that contains the `knock` membership change.
/// </param>
/// <param name="user_id">
/// The user id of the user who's requesting to join the room.
/// </param>
/// <param name="room_id">
/// The room id of the room whose access was requested.
/// </param>
/// <param name="display_name">
/// The optional display name of the user who's requesting to join the room.
/// </param>
/// <param name="avatar_url">
/// The optional avatar url of the user who's requesting to join the room.
/// </param>
/// <param name="reason">
/// An optional reason why the user wants join the room.
/// </param>
/// <param name="timestamp">
/// The timestamp when this request was created.
/// </param>
/// <param name="is_seen">
/// Whether the knock request has been marked as `seen` so it can be
/// filtered by the client.
/// </param>
/// <param name="actions">
/// A set of actions to perform for this knock request.
/// </param>
internal record KnockRequest(
    /// <summary>
    /// The event id of the event that contains the `knock` membership change.
    /// </summary>
    string @eventId,
    /// <summary>
    /// The user id of the user who's requesting to join the room.
    /// </summary>
    string @userId,
    /// <summary>
    /// The room id of the room whose access was requested.
    /// </summary>
    string @roomId,
    /// <summary>
    /// The optional display name of the user who's requesting to join the room.
    /// </summary>
    string? @displayName,
    /// <summary>
    /// The optional avatar url of the user who's requesting to join the room.
    /// </summary>
    string? @avatarUrl,
    /// <summary>
    /// An optional reason why the user wants join the room.
    /// </summary>
    string? @reason,
    /// <summary>
    /// The timestamp when this request was created.
    /// </summary>
    ulong? @timestamp,
    /// <summary>
    /// Whether the knock request has been marked as `seen` so it can be
    /// filtered by the client.
    /// </summary>
    bool @isSeen,
    /// <summary>
    /// A set of actions to perform for this knock request.
    /// </summary>
    KnockRequestActions @actions
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@eventId,
            this.@userId,
            this.@roomId,
            this.@displayName,
            this.@avatarUrl,
            this.@reason,
            this.@timestamp,
            this.@isSeen,
            this.@actions
        );
    }
}

class FfiConverterTypeKnockRequest : FfiConverterRustBuffer<KnockRequest>
{
    public static FfiConverterTypeKnockRequest INSTANCE = new FfiConverterTypeKnockRequest();

    public override KnockRequest Read(BigEndianStream stream)
    {
        return new KnockRequest(
            @eventId: FfiConverterString.INSTANCE.Read(stream),
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @roomId: FfiConverterString.INSTANCE.Read(stream),
            @displayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @reason: FfiConverterOptionalString.INSTANCE.Read(stream),
            @timestamp: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @isSeen: FfiConverterBoolean.INSTANCE.Read(stream),
            @actions: FfiConverterTypeKnockRequestActions.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(KnockRequest value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@eventId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@roomId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@reason)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@timestamp)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isSeen)
            + FfiConverterTypeKnockRequestActions.INSTANCE.AllocationSize(value.@actions);
    }

    public override void Write(KnockRequest value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@eventId, stream);
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterString.INSTANCE.Write(value.@roomId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@reason, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@timestamp, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isSeen, stream);
        FfiConverterTypeKnockRequestActions.INSTANCE.Write(value.@actions, stream);
    }
}

/// <param name="location">
/// The most recent location content of the user.
/// </param>
/// <param name="ts">
/// A timestamp in milliseconds since Unix Epoch on that day in local
/// time.
/// </param>
internal record LastLocation(
    /// <summary>
    /// The most recent location content of the user.
    /// </summary>
    LocationContent @location,
    /// <summary>
    /// A timestamp in milliseconds since Unix Epoch on that day in local
    /// time.
    /// </summary>
    ulong @ts
) { }

class FfiConverterTypeLastLocation : FfiConverterRustBuffer<LastLocation>
{
    public static FfiConverterTypeLastLocation INSTANCE = new FfiConverterTypeLastLocation();

    public override LastLocation Read(BigEndianStream stream)
    {
        return new LastLocation(
            @location: FfiConverterTypeLocationContent.INSTANCE.Read(stream),
            @ts: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LastLocation value)
    {
        return 0
            + FfiConverterTypeLocationContent.INSTANCE.AllocationSize(value.@location)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@ts);
    }

    public override void Write(LastLocation value, BigEndianStream stream)
    {
        FfiConverterTypeLocationContent.INSTANCE.Write(value.@location, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@ts, stream);
    }
}

/// <summary>
/// Details of a users live location share.
/// </summary>
/// <param name="last_location">
/// The user's last known location.
/// </param>
/// <param name="is_live">
/// The live status of the live location share.
/// </param>
/// <param name="user_id">
/// The user ID of the person sharing their live location.
/// </param>
internal record LiveLocationShare(
    /// <summary>
    /// The user's last known location.
    /// </summary>
    LastLocation @lastLocation,
    /// <summary>
    /// The live status of the live location share.
    /// </summary>
    bool @isLive,
    /// <summary>
    /// The user ID of the person sharing their live location.
    /// </summary>
    string @userId
) { }

class FfiConverterTypeLiveLocationShare : FfiConverterRustBuffer<LiveLocationShare>
{
    public static FfiConverterTypeLiveLocationShare INSTANCE = new FfiConverterTypeLiveLocationShare();

    public override LiveLocationShare Read(BigEndianStream stream)
    {
        return new LiveLocationShare(
            @lastLocation: FfiConverterTypeLastLocation.INSTANCE.Read(stream),
            @isLive: FfiConverterBoolean.INSTANCE.Read(stream),
            @userId: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LiveLocationShare value)
    {
        return 0
            + FfiConverterTypeLastLocation.INSTANCE.AllocationSize(value.@lastLocation)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isLive)
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId);
    }

    public override void Write(LiveLocationShare value, BigEndianStream stream)
    {
        FfiConverterTypeLastLocation.INSTANCE.Write(value.@lastLocation, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isLive, stream);
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
    }
}

internal record LocationContent(
    string @body,
    string @geoUri,
    string? @description,
    byte? @zoomLevel,
    AssetType? @asset
) { }

class FfiConverterTypeLocationContent : FfiConverterRustBuffer<LocationContent>
{
    public static FfiConverterTypeLocationContent INSTANCE = new FfiConverterTypeLocationContent();

    public override LocationContent Read(BigEndianStream stream)
    {
        return new LocationContent(
            @body: FfiConverterString.INSTANCE.Read(stream),
            @geoUri: FfiConverterString.INSTANCE.Read(stream),
            @description: FfiConverterOptionalString.INSTANCE.Read(stream),
            @zoomLevel: FfiConverterOptionalUInt8.INSTANCE.Read(stream),
            @asset: FfiConverterOptionalTypeAssetType.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LocationContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@body)
            + FfiConverterString.INSTANCE.AllocationSize(value.@geoUri)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterOptionalUInt8.INSTANCE.AllocationSize(value.@zoomLevel)
            + FfiConverterOptionalTypeAssetType.INSTANCE.AllocationSize(value.@asset);
    }

    public override void Write(LocationContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@body, stream);
        FfiConverterString.INSTANCE.Write(value.@geoUri, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@description, stream);
        FfiConverterOptionalUInt8.INSTANCE.Write(value.@zoomLevel, stream);
        FfiConverterOptionalTypeAssetType.INSTANCE.Write(value.@asset, stream);
    }
}

/// <summary>
/// A Matrix entity that can be a room, room alias, user, or event, and a list
/// of via servers.
/// </summary>
internal record MatrixEntity(MatrixId @id, List<string> @via) { }

class FfiConverterTypeMatrixEntity : FfiConverterRustBuffer<MatrixEntity>
{
    public static FfiConverterTypeMatrixEntity INSTANCE = new FfiConverterTypeMatrixEntity();

    public override MatrixEntity Read(BigEndianStream stream)
    {
        return new MatrixEntity(
            @id: FfiConverterTypeMatrixId.INSTANCE.Read(stream),
            @via: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(MatrixEntity value)
    {
        return 0
            + FfiConverterTypeMatrixId.INSTANCE.AllocationSize(value.@id)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@via);
    }

    public override void Write(MatrixEntity value, BigEndianStream stream)
    {
        FfiConverterTypeMatrixId.INSTANCE.Write(value.@id, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@via, stream);
    }
}

internal record Mentions(List<string> @userIds, bool @room) { }

class FfiConverterTypeMentions : FfiConverterRustBuffer<Mentions>
{
    public static FfiConverterTypeMentions INSTANCE = new FfiConverterTypeMentions();

    public override Mentions Read(BigEndianStream stream)
    {
        return new Mentions(
            @userIds: FfiConverterSequenceString.INSTANCE.Read(stream),
            @room: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Mentions value)
    {
        return 0
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@userIds)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@room);
    }

    public override void Write(Mentions value, BigEndianStream stream)
    {
        FfiConverterSequenceString.INSTANCE.Write(value.@userIds, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@room, stream);
    }
}

internal record MessageContent(MessageType @msgType, string @body, bool @isEdited, Mentions? @mentions) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@msgType, this.@body, this.@isEdited, this.@mentions);
    }
}

class FfiConverterTypeMessageContent : FfiConverterRustBuffer<MessageContent>
{
    public static FfiConverterTypeMessageContent INSTANCE = new FfiConverterTypeMessageContent();

    public override MessageContent Read(BigEndianStream stream)
    {
        return new MessageContent(
            @msgType: FfiConverterTypeMessageType.INSTANCE.Read(stream),
            @body: FfiConverterString.INSTANCE.Read(stream),
            @isEdited: FfiConverterBoolean.INSTANCE.Read(stream),
            @mentions: FfiConverterOptionalTypeMentions.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(MessageContent value)
    {
        return 0
            + FfiConverterTypeMessageType.INSTANCE.AllocationSize(value.@msgType)
            + FfiConverterString.INSTANCE.AllocationSize(value.@body)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isEdited)
            + FfiConverterOptionalTypeMentions.INSTANCE.AllocationSize(value.@mentions);
    }

    public override void Write(MessageContent value, BigEndianStream stream)
    {
        FfiConverterTypeMessageType.INSTANCE.Write(value.@msgType, stream);
        FfiConverterString.INSTANCE.Write(value.@body, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isEdited, stream);
        FfiConverterOptionalTypeMentions.INSTANCE.Write(value.@mentions, stream);
    }
}

/// <summary>
/// A special kind of [`super::TimelineItemContent`] that groups together
/// different room message types with their respective reactions and thread
/// information.
/// </summary>
/// <param name="thread_root">
/// Event ID of the thread root, if this is a threaded message.
/// </param>
/// <param name="in_reply_to">
/// The event this message is replying to, if any.
/// </param>
internal record MsgLikeContent(
    MsgLikeKind @kind,
    List<Reaction> @reactions,
    /// <summary>
    /// Event ID of the thread root, if this is a threaded message.
    /// </summary>
    string? @threadRoot,
    /// <summary>
    /// The event this message is replying to, if any.
    /// </summary>
    InReplyToDetails? @inReplyTo
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@kind, this.@reactions, this.@threadRoot, this.@inReplyTo);
    }
}

class FfiConverterTypeMsgLikeContent : FfiConverterRustBuffer<MsgLikeContent>
{
    public static FfiConverterTypeMsgLikeContent INSTANCE = new FfiConverterTypeMsgLikeContent();

    public override MsgLikeContent Read(BigEndianStream stream)
    {
        return new MsgLikeContent(
            @kind: FfiConverterTypeMsgLikeKind.INSTANCE.Read(stream),
            @reactions: FfiConverterSequenceTypeReaction.INSTANCE.Read(stream),
            @threadRoot: FfiConverterOptionalString.INSTANCE.Read(stream),
            @inReplyTo: FfiConverterOptionalTypeInReplyToDetails.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(MsgLikeContent value)
    {
        return 0
            + FfiConverterTypeMsgLikeKind.INSTANCE.AllocationSize(value.@kind)
            + FfiConverterSequenceTypeReaction.INSTANCE.AllocationSize(value.@reactions)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@threadRoot)
            + FfiConverterOptionalTypeInReplyToDetails.INSTANCE.AllocationSize(value.@inReplyTo);
    }

    public override void Write(MsgLikeContent value, BigEndianStream stream)
    {
        FfiConverterTypeMsgLikeKind.INSTANCE.Write(value.@kind, stream);
        FfiConverterSequenceTypeReaction.INSTANCE.Write(value.@reactions, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@threadRoot, stream);
        FfiConverterOptionalTypeInReplyToDetails.INSTANCE.Write(value.@inReplyTo, stream);
    }
}

internal record NoticeMessageContent(string @body, FormattedBody? @formatted) { }

class FfiConverterTypeNoticeMessageContent : FfiConverterRustBuffer<NoticeMessageContent>
{
    public static FfiConverterTypeNoticeMessageContent INSTANCE = new FfiConverterTypeNoticeMessageContent();

    public override NoticeMessageContent Read(BigEndianStream stream)
    {
        return new NoticeMessageContent(
            @body: FfiConverterString.INSTANCE.Read(stream),
            @formatted: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(NoticeMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@body)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formatted);
    }

    public override void Write(NoticeMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@body, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formatted, stream);
    }
}

/// <param name="is_noisy">
/// Is the notification supposed to be at the "noisy" level?
/// Can be `None` if we couldn't determine this, because we lacked
/// information to create a push context.
/// </param>
internal record NotificationItem(
    NotificationEvent @event,
    NotificationSenderInfo @senderInfo,
    NotificationRoomInfo @roomInfo,
    /// <summary>
    /// Is the notification supposed to be at the "noisy" level?
    /// Can be `None` if we couldn't determine this, because we lacked
    /// information to create a push context.
    /// </summary>
    bool? @isNoisy,
    bool? @hasMention,
    string? @threadId
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@event,
            this.@senderInfo,
            this.@roomInfo,
            this.@isNoisy,
            this.@hasMention,
            this.@threadId
        );
    }
}

class FfiConverterTypeNotificationItem : FfiConverterRustBuffer<NotificationItem>
{
    public static FfiConverterTypeNotificationItem INSTANCE = new FfiConverterTypeNotificationItem();

    public override NotificationItem Read(BigEndianStream stream)
    {
        return new NotificationItem(
            @event: FfiConverterTypeNotificationEvent.INSTANCE.Read(stream),
            @senderInfo: FfiConverterTypeNotificationSenderInfo.INSTANCE.Read(stream),
            @roomInfo: FfiConverterTypeNotificationRoomInfo.INSTANCE.Read(stream),
            @isNoisy: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @hasMention: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @threadId: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(NotificationItem value)
    {
        return 0
            + FfiConverterTypeNotificationEvent.INSTANCE.AllocationSize(value.@event)
            + FfiConverterTypeNotificationSenderInfo.INSTANCE.AllocationSize(value.@senderInfo)
            + FfiConverterTypeNotificationRoomInfo.INSTANCE.AllocationSize(value.@roomInfo)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isNoisy)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@hasMention)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@threadId);
    }

    public override void Write(NotificationItem value, BigEndianStream stream)
    {
        FfiConverterTypeNotificationEvent.INSTANCE.Write(value.@event, stream);
        FfiConverterTypeNotificationSenderInfo.INSTANCE.Write(value.@senderInfo, stream);
        FfiConverterTypeNotificationRoomInfo.INSTANCE.Write(value.@roomInfo, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@isNoisy, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@hasMention, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@threadId, stream);
    }
}

internal record NotificationPowerLevels(int @room) { }

class FfiConverterTypeNotificationPowerLevels : FfiConverterRustBuffer<NotificationPowerLevels>
{
    public static FfiConverterTypeNotificationPowerLevels INSTANCE = new FfiConverterTypeNotificationPowerLevels();

    public override NotificationPowerLevels Read(BigEndianStream stream)
    {
        return new NotificationPowerLevels(@room: FfiConverterInt32.INSTANCE.Read(stream));
    }

    public override int AllocationSize(NotificationPowerLevels value)
    {
        return 0 + FfiConverterInt32.INSTANCE.AllocationSize(value.@room);
    }

    public override void Write(NotificationPowerLevels value, BigEndianStream stream)
    {
        FfiConverterInt32.INSTANCE.Write(value.@room, stream);
    }
}

internal record NotificationRoomInfo(
    string @displayName,
    string? @avatarUrl,
    string? @canonicalAlias,
    ulong @joinedMembersCount,
    bool? @isEncrypted,
    bool @isDirect
) { }

class FfiConverterTypeNotificationRoomInfo : FfiConverterRustBuffer<NotificationRoomInfo>
{
    public static FfiConverterTypeNotificationRoomInfo INSTANCE = new FfiConverterTypeNotificationRoomInfo();

    public override NotificationRoomInfo Read(BigEndianStream stream)
    {
        return new NotificationRoomInfo(
            @displayName: FfiConverterString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @canonicalAlias: FfiConverterOptionalString.INSTANCE.Read(stream),
            @joinedMembersCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @isEncrypted: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @isDirect: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(NotificationRoomInfo value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@canonicalAlias)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@joinedMembersCount)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isEncrypted)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isDirect);
    }

    public override void Write(NotificationRoomInfo value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@canonicalAlias, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@joinedMembersCount, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@isEncrypted, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isDirect, stream);
    }
}

internal record NotificationSenderInfo(string? @displayName, string? @avatarUrl, bool @isNameAmbiguous) { }

class FfiConverterTypeNotificationSenderInfo : FfiConverterRustBuffer<NotificationSenderInfo>
{
    public static FfiConverterTypeNotificationSenderInfo INSTANCE = new FfiConverterTypeNotificationSenderInfo();

    public override NotificationSenderInfo Read(BigEndianStream stream)
    {
        return new NotificationSenderInfo(
            @displayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @isNameAmbiguous: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(NotificationSenderInfo value)
    {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isNameAmbiguous);
    }

    public override void Write(NotificationSenderInfo value, BigEndianStream stream)
    {
        FfiConverterOptionalString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isNameAmbiguous, stream);
    }
}

/// <summary>
/// The configuration to use when authenticating with OIDC.
/// </summary>
/// <param name="client_name">
/// The name of the client that will be shown during OIDC authentication.
/// </param>
/// <param name="redirect_uri">
/// The redirect URI that will be used when OIDC authentication is
/// successful.
/// </param>
/// <param name="client_uri">
/// A URI that contains information about the client.
/// </param>
/// <param name="logo_uri">
/// A URI that contains the client's logo.
/// </param>
/// <param name="tos_uri">
/// A URI that contains the client's terms of service.
/// </param>
/// <param name="policy_uri">
/// A URI that contains the client's privacy policy.
/// </param>
/// <param name="contacts">
/// An array of e-mail addresses of people responsible for this client.
/// </param>
/// <param name="static_registrations">
/// Pre-configured registrations for use with homeservers that don't support
/// dynamic client registration.
///
/// The keys of the map should be the URLs of the homeservers, but keys
/// using `issuer` URLs are also supported.
/// </param>
internal record OidcConfiguration(
    /// <summary>
    /// The name of the client that will be shown during OIDC authentication.
    /// </summary>
    string? @clientName,
    /// <summary>
    /// The redirect URI that will be used when OIDC authentication is
    /// successful.
    /// </summary>
    string @redirectUri,
    /// <summary>
    /// A URI that contains information about the client.
    /// </summary>
    string @clientUri,
    /// <summary>
    /// A URI that contains the client's logo.
    /// </summary>
    string? @logoUri,
    /// <summary>
    /// A URI that contains the client's terms of service.
    /// </summary>
    string? @tosUri,
    /// <summary>
    /// A URI that contains the client's privacy policy.
    /// </summary>
    string? @policyUri,
    /// <summary>
    /// An array of e-mail addresses of people responsible for this client.
    /// </summary>
    List<string>? @contacts,
    /// <summary>
    /// Pre-configured registrations for use with homeservers that don't support
    /// dynamic client registration.
    ///
    /// The keys of the map should be the URLs of the homeservers, but keys
    /// using `issuer` URLs are also supported.
    /// </summary>
    Dictionary<string, string> @staticRegistrations
) { }

class FfiConverterTypeOidcConfiguration : FfiConverterRustBuffer<OidcConfiguration>
{
    public static FfiConverterTypeOidcConfiguration INSTANCE = new FfiConverterTypeOidcConfiguration();

    public override OidcConfiguration Read(BigEndianStream stream)
    {
        return new OidcConfiguration(
            @clientName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @redirectUri: FfiConverterString.INSTANCE.Read(stream),
            @clientUri: FfiConverterString.INSTANCE.Read(stream),
            @logoUri: FfiConverterOptionalString.INSTANCE.Read(stream),
            @tosUri: FfiConverterOptionalString.INSTANCE.Read(stream),
            @policyUri: FfiConverterOptionalString.INSTANCE.Read(stream),
            @contacts: FfiConverterOptionalSequenceString.INSTANCE.Read(stream),
            @staticRegistrations: FfiConverterDictionaryStringString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(OidcConfiguration value)
    {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@clientName)
            + FfiConverterString.INSTANCE.AllocationSize(value.@redirectUri)
            + FfiConverterString.INSTANCE.AllocationSize(value.@clientUri)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@logoUri)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@tosUri)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@policyUri)
            + FfiConverterOptionalSequenceString.INSTANCE.AllocationSize(value.@contacts)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@staticRegistrations);
    }

    public override void Write(OidcConfiguration value, BigEndianStream stream)
    {
        FfiConverterOptionalString.INSTANCE.Write(value.@clientName, stream);
        FfiConverterString.INSTANCE.Write(value.@redirectUri, stream);
        FfiConverterString.INSTANCE.Write(value.@clientUri, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@logoUri, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@tosUri, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@policyUri, stream);
        FfiConverterOptionalSequenceString.INSTANCE.Write(value.@contacts, stream);
        FfiConverterDictionaryStringString.INSTANCE.Write(value.@staticRegistrations, stream);
    }
}

/// <param name="approval_url">
/// The URL where the user can approve the reset of the cross-signing keys.
/// </param>
internal record OidcCrossSigningResetInfo(
    /// <summary>
    /// The URL where the user can approve the reset of the cross-signing keys.
    /// </summary>
    string @approvalUrl
) { }

class FfiConverterTypeOidcCrossSigningResetInfo : FfiConverterRustBuffer<OidcCrossSigningResetInfo>
{
    public static FfiConverterTypeOidcCrossSigningResetInfo INSTANCE = new FfiConverterTypeOidcCrossSigningResetInfo();

    public override OidcCrossSigningResetInfo Read(BigEndianStream stream)
    {
        return new OidcCrossSigningResetInfo(@approvalUrl: FfiConverterString.INSTANCE.Read(stream));
    }

    public override int AllocationSize(OidcCrossSigningResetInfo value)
    {
        return 0 + FfiConverterString.INSTANCE.AllocationSize(value.@approvalUrl);
    }

    public override void Write(OidcCrossSigningResetInfo value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@approvalUrl, stream);
    }
}

internal record PollAnswer(string @id, string @text) { }

class FfiConverterTypePollAnswer : FfiConverterRustBuffer<PollAnswer>
{
    public static FfiConverterTypePollAnswer INSTANCE = new FfiConverterTypePollAnswer();

    public override PollAnswer Read(BigEndianStream stream)
    {
        return new PollAnswer(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @text: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PollAnswer value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@text);
    }

    public override void Write(PollAnswer value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@id, stream);
        FfiConverterString.INSTANCE.Write(value.@text, stream);
    }
}

internal record PollData(string @question, List<string> @answers, byte @maxSelections, PollKind @pollKind) { }

class FfiConverterTypePollData : FfiConverterRustBuffer<PollData>
{
    public static FfiConverterTypePollData INSTANCE = new FfiConverterTypePollData();

    public override PollData Read(BigEndianStream stream)
    {
        return new PollData(
            @question: FfiConverterString.INSTANCE.Read(stream),
            @answers: FfiConverterSequenceString.INSTANCE.Read(stream),
            @maxSelections: FfiConverterUInt8.INSTANCE.Read(stream),
            @pollKind: FfiConverterTypePollKind.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PollData value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@question)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@answers)
            + FfiConverterUInt8.INSTANCE.AllocationSize(value.@maxSelections)
            + FfiConverterTypePollKind.INSTANCE.AllocationSize(value.@pollKind);
    }

    public override void Write(PollData value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@question, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@answers, stream);
        FfiConverterUInt8.INSTANCE.Write(value.@maxSelections, stream);
        FfiConverterTypePollKind.INSTANCE.Write(value.@pollKind, stream);
    }
}

internal record PowerLevels(
    int? @usersDefault,
    int? @eventsDefault,
    int? @stateDefault,
    int? @ban,
    int? @kick,
    int? @redact,
    int? @invite,
    NotificationPowerLevels? @notifications,
    Dictionary<string, int> @users,
    Dictionary<string, int> @events
) { }

class FfiConverterTypePowerLevels : FfiConverterRustBuffer<PowerLevels>
{
    public static FfiConverterTypePowerLevels INSTANCE = new FfiConverterTypePowerLevels();

    public override PowerLevels Read(BigEndianStream stream)
    {
        return new PowerLevels(
            @usersDefault: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @eventsDefault: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @stateDefault: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @ban: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @kick: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @redact: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @invite: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @notifications: FfiConverterOptionalTypeNotificationPowerLevels.INSTANCE.Read(stream),
            @users: FfiConverterDictionaryStringInt32.INSTANCE.Read(stream),
            @events: FfiConverterDictionaryStringInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PowerLevels value)
    {
        return 0
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@usersDefault)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@eventsDefault)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@stateDefault)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@ban)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@kick)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@redact)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@invite)
            + FfiConverterOptionalTypeNotificationPowerLevels.INSTANCE.AllocationSize(value.@notifications)
            + FfiConverterDictionaryStringInt32.INSTANCE.AllocationSize(value.@users)
            + FfiConverterDictionaryStringInt32.INSTANCE.AllocationSize(value.@events);
    }

    public override void Write(PowerLevels value, BigEndianStream stream)
    {
        FfiConverterOptionalInt32.INSTANCE.Write(value.@usersDefault, stream);
        FfiConverterOptionalInt32.INSTANCE.Write(value.@eventsDefault, stream);
        FfiConverterOptionalInt32.INSTANCE.Write(value.@stateDefault, stream);
        FfiConverterOptionalInt32.INSTANCE.Write(value.@ban, stream);
        FfiConverterOptionalInt32.INSTANCE.Write(value.@kick, stream);
        FfiConverterOptionalInt32.INSTANCE.Write(value.@redact, stream);
        FfiConverterOptionalInt32.INSTANCE.Write(value.@invite, stream);
        FfiConverterOptionalTypeNotificationPowerLevels.INSTANCE.Write(value.@notifications, stream);
        FfiConverterDictionaryStringInt32.INSTANCE.Write(value.@users, stream);
        FfiConverterDictionaryStringInt32.INSTANCE.Write(value.@events, stream);
    }
}

internal record PusherIdentifiers(string @pushkey, string @appId) { }

class FfiConverterTypePusherIdentifiers : FfiConverterRustBuffer<PusherIdentifiers>
{
    public static FfiConverterTypePusherIdentifiers INSTANCE = new FfiConverterTypePusherIdentifiers();

    public override PusherIdentifiers Read(BigEndianStream stream)
    {
        return new PusherIdentifiers(
            @pushkey: FfiConverterString.INSTANCE.Read(stream),
            @appId: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PusherIdentifiers value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@pushkey)
            + FfiConverterString.INSTANCE.AllocationSize(value.@appId);
    }

    public override void Write(PusherIdentifiers value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@pushkey, stream);
        FfiConverterString.INSTANCE.Write(value.@appId, stream);
    }
}

internal record Reaction(string @key, List<ReactionSenderData> @senders) { }

class FfiConverterTypeReaction : FfiConverterRustBuffer<Reaction>
{
    public static FfiConverterTypeReaction INSTANCE = new FfiConverterTypeReaction();

    public override Reaction Read(BigEndianStream stream)
    {
        return new Reaction(
            @key: FfiConverterString.INSTANCE.Read(stream),
            @senders: FfiConverterSequenceTypeReactionSenderData.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Reaction value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@key)
            + FfiConverterSequenceTypeReactionSenderData.INSTANCE.AllocationSize(value.@senders);
    }

    public override void Write(Reaction value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@key, stream);
        FfiConverterSequenceTypeReactionSenderData.INSTANCE.Write(value.@senders, stream);
    }
}

internal record ReactionSenderData(string @senderId, Timestamp @timestamp) { }

class FfiConverterTypeReactionSenderData : FfiConverterRustBuffer<ReactionSenderData>
{
    public static FfiConverterTypeReactionSenderData INSTANCE = new FfiConverterTypeReactionSenderData();

    public override ReactionSenderData Read(BigEndianStream stream)
    {
        return new ReactionSenderData(
            @senderId: FfiConverterString.INSTANCE.Read(stream),
            @timestamp: FfiConverterTypeTimestamp.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ReactionSenderData value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@senderId)
            + FfiConverterTypeTimestamp.INSTANCE.AllocationSize(value.@timestamp);
    }

    public override void Write(ReactionSenderData value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@senderId, stream);
        FfiConverterTypeTimestamp.INSTANCE.Write(value.@timestamp, stream);
    }
}

internal record Receipt(Timestamp? @timestamp) { }

class FfiConverterTypeReceipt : FfiConverterRustBuffer<Receipt>
{
    public static FfiConverterTypeReceipt INSTANCE = new FfiConverterTypeReceipt();

    public override Receipt Read(BigEndianStream stream)
    {
        return new Receipt(@timestamp: FfiConverterOptionalTypeTimestamp.INSTANCE.Read(stream));
    }

    public override int AllocationSize(Receipt value)
    {
        return 0 + FfiConverterOptionalTypeTimestamp.INSTANCE.AllocationSize(value.@timestamp);
    }

    public override void Write(Receipt value, BigEndianStream stream)
    {
        FfiConverterOptionalTypeTimestamp.INSTANCE.Write(value.@timestamp, stream);
    }
}

/// <param name="event_id">
/// The ID of the event to reply to.
/// </param>
/// <param name="enforce_thread">
/// Whether to enforce a thread relation.
/// </param>
/// <param name="reply_within_thread">
/// If enforcing a threaded relation, whether the message is a reply on a
/// thread.
/// </param>
internal record ReplyParameters(
    /// <summary>
    /// The ID of the event to reply to.
    /// </summary>
    string @eventId,
    /// <summary>
    /// Whether to enforce a thread relation.
    /// </summary>
    bool @enforceThread,
    /// <summary>
    /// If enforcing a threaded relation, whether the message is a reply on a
    /// thread.
    /// </summary>
    bool @replyWithinThread
) { }

class FfiConverterTypeReplyParameters : FfiConverterRustBuffer<ReplyParameters>
{
    public static FfiConverterTypeReplyParameters INSTANCE = new FfiConverterTypeReplyParameters();

    public override ReplyParameters Read(BigEndianStream stream)
    {
        return new ReplyParameters(
            @eventId: FfiConverterString.INSTANCE.Read(stream),
            @enforceThread: FfiConverterBoolean.INSTANCE.Read(stream),
            @replyWithinThread: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ReplyParameters value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@eventId)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@enforceThread)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@replyWithinThread);
    }

    public override void Write(ReplyParameters value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@eventId, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@enforceThread, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@replyWithinThread, stream);
    }
}

/// <summary>
/// The config to use for HTTP requests by default in this client.
/// </summary>
/// <param name="retry_limit">
/// Max number of retries.
/// </param>
/// <param name="timeout">
/// Timeout for a request in milliseconds.
/// </param>
/// <param name="max_concurrent_requests">
/// Max number of concurrent requests. No value means no limits.
/// </param>
/// <param name="retry_timeout">
/// Base delay between retries.
/// </param>
internal record RequestConfig(
    /// <summary>
    /// Max number of retries.
    /// </summary>
    ulong? @retryLimit,
    /// <summary>
    /// Timeout for a request in milliseconds.
    /// </summary>
    ulong? @timeout,
    /// <summary>
    /// Max number of concurrent requests. No value means no limits.
    /// </summary>
    ulong? @maxConcurrentRequests,
    /// <summary>
    /// Base delay between retries.
    /// </summary>
    ulong? @retryTimeout
) { }

class FfiConverterTypeRequestConfig : FfiConverterRustBuffer<RequestConfig>
{
    public static FfiConverterTypeRequestConfig INSTANCE = new FfiConverterTypeRequestConfig();

    public override RequestConfig Read(BigEndianStream stream)
    {
        return new RequestConfig(
            @retryLimit: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @timeout: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @maxConcurrentRequests: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @retryTimeout: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RequestConfig value)
    {
        return 0
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@retryLimit)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@timeout)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@maxConcurrentRequests)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@retryTimeout);
    }

    public override void Write(RequestConfig value, BigEndianStream stream)
    {
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@retryLimit, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@timeout, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@maxConcurrentRequests, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@retryTimeout, stream);
    }
}

/// <summary>
/// Information about a room, that was resolved from a room alias.
/// </summary>
/// <param name="room_id">
/// The room ID that the alias resolved to.
/// </param>
/// <param name="servers">
/// A list of servers that can be used to find the room by its room ID.
/// </param>
internal record ResolvedRoomAlias(
    /// <summary>
    /// The room ID that the alias resolved to.
    /// </summary>
    string @roomId,
    /// <summary>
    /// A list of servers that can be used to find the room by its room ID.
    /// </summary>
    List<string> @servers
) { }

class FfiConverterTypeResolvedRoomAlias : FfiConverterRustBuffer<ResolvedRoomAlias>
{
    public static FfiConverterTypeResolvedRoomAlias INSTANCE = new FfiConverterTypeResolvedRoomAlias();

    public override ResolvedRoomAlias Read(BigEndianStream stream)
    {
        return new ResolvedRoomAlias(
            @roomId: FfiConverterString.INSTANCE.Read(stream),
            @servers: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ResolvedRoomAlias value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@roomId)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@servers);
    }

    public override void Write(ResolvedRoomAlias value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@roomId, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@servers, stream);
    }
}

internal record RoomDescription(
    string @roomId,
    string? @name,
    string? @topic,
    string? @alias,
    string? @avatarUrl,
    PublicRoomJoinRule? @joinRule,
    bool @isWorldReadable,
    ulong @joinedMembers
) { }

class FfiConverterTypeRoomDescription : FfiConverterRustBuffer<RoomDescription>
{
    public static FfiConverterTypeRoomDescription INSTANCE = new FfiConverterTypeRoomDescription();

    public override RoomDescription Read(BigEndianStream stream)
    {
        return new RoomDescription(
            @roomId: FfiConverterString.INSTANCE.Read(stream),
            @name: FfiConverterOptionalString.INSTANCE.Read(stream),
            @topic: FfiConverterOptionalString.INSTANCE.Read(stream),
            @alias: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @joinRule: FfiConverterOptionalTypePublicRoomJoinRule.INSTANCE.Read(stream),
            @isWorldReadable: FfiConverterBoolean.INSTANCE.Read(stream),
            @joinedMembers: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomDescription value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@roomId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@topic)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@alias)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterOptionalTypePublicRoomJoinRule.INSTANCE.AllocationSize(value.@joinRule)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isWorldReadable)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@joinedMembers);
    }

    public override void Write(RoomDescription value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@roomId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@name, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@topic, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@alias, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterOptionalTypePublicRoomJoinRule.INSTANCE.Write(value.@joinRule, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isWorldReadable, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@joinedMembers, stream);
    }
}

internal record RoomDirectorySearchEntriesResult(TaskHandle @entriesStream) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@entriesStream);
    }
}

class FfiConverterTypeRoomDirectorySearchEntriesResult : FfiConverterRustBuffer<RoomDirectorySearchEntriesResult>
{
    public static FfiConverterTypeRoomDirectorySearchEntriesResult INSTANCE =
        new FfiConverterTypeRoomDirectorySearchEntriesResult();

    public override RoomDirectorySearchEntriesResult Read(BigEndianStream stream)
    {
        return new RoomDirectorySearchEntriesResult(@entriesStream: FfiConverterTypeTaskHandle.INSTANCE.Read(stream));
    }

    public override int AllocationSize(RoomDirectorySearchEntriesResult value)
    {
        return 0 + FfiConverterTypeTaskHandle.INSTANCE.AllocationSize(value.@entriesStream);
    }

    public override void Write(RoomDirectorySearchEntriesResult value, BigEndianStream stream)
    {
        FfiConverterTypeTaskHandle.INSTANCE.Write(value.@entriesStream, stream);
    }
}

/// <summary>
/// Information about a member considered to be a room hero.
/// </summary>
/// <param name="user_id">
/// The user ID of the hero.
/// </param>
/// <param name="display_name">
/// The display name of the hero.
/// </param>
/// <param name="avatar_url">
/// The avatar URL of the hero.
/// </param>
internal record RoomHero(
    /// <summary>
    /// The user ID of the hero.
    /// </summary>
    string @userId,
    /// <summary>
    /// The display name of the hero.
    /// </summary>
    string? @displayName,
    /// <summary>
    /// The avatar URL of the hero.
    /// </summary>
    string? @avatarUrl
) { }

class FfiConverterTypeRoomHero : FfiConverterRustBuffer<RoomHero>
{
    public static FfiConverterTypeRoomHero INSTANCE = new FfiConverterTypeRoomHero();

    public override RoomHero Read(BigEndianStream stream)
    {
        return new RoomHero(
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @displayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomHero value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl);
    }

    public override void Write(RoomHero value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
    }
}

/// <param name="display_name">
/// The room's name from the room state event if received from sync, or one
/// that's been computed otherwise.
/// </param>
/// <param name="raw_name">
/// Room name as defined by the room state event only.
/// </param>
/// <param name="inviter">
/// Member who invited the current user to a room that's in the invited
/// state.
///
/// Can be missing if the room membership invite event is missing from the
/// store.
/// </param>
/// <param name="is_marked_unread">
/// Whether this room has been explicitly marked as unread
/// </param>
/// <param name="num_unread_messages">
/// "Interesting" messages received in that room, independently of the
/// notification settings.
/// </param>
/// <param name="num_unread_notifications">
/// Events that will notify the user, according to their
/// notification settings.
/// </param>
/// <param name="num_unread_mentions">
/// Events causing mentions/highlights for the user, according to their
/// notification settings.
/// </param>
/// <param name="pinned_event_ids">
/// The currently pinned event ids.
/// </param>
/// <param name="join_rule">
/// The join rule for this room, if known.
/// </param>
/// <param name="history_visibility">
/// The history visibility for this room, if known.
/// </param>
internal record RoomInfo(
    string @id,
    EncryptionState @encryptionState,
    string? @creator,
    /// <summary>
    /// The room's name from the room state event if received from sync, or one
    /// that's been computed otherwise.
    /// </summary>
    string? @displayName,
    /// <summary>
    /// Room name as defined by the room state event only.
    /// </summary>
    string? @rawName,
    string? @topic,
    string? @avatarUrl,
    bool @isDirect,
    bool @isPublic,
    bool @isSpace,
    bool @isTombstoned,
    bool @isFavourite,
    string? @canonicalAlias,
    List<string> @alternativeAliases,
    Membership @membership,
    /// <summary>
    /// Member who invited the current user to a room that's in the invited
    /// state.
    ///
    /// Can be missing if the room membership invite event is missing from the
    /// store.
    /// </summary>
    RoomMember? @inviter,
    List<RoomHero> @heroes,
    ulong @activeMembersCount,
    ulong @invitedMembersCount,
    ulong @joinedMembersCount,
    Dictionary<string, long> @userPowerLevels,
    ulong @highlightCount,
    ulong @notificationCount,
    RoomNotificationMode? @cachedUserDefinedNotificationMode,
    bool @hasRoomCall,
    List<string> @activeRoomCallParticipants,
    /// <summary>
    /// Whether this room has been explicitly marked as unread
    /// </summary>
    bool @isMarkedUnread,
    /// <summary>
    /// "Interesting" messages received in that room, independently of the
    /// notification settings.
    /// </summary>
    ulong @numUnreadMessages,
    /// <summary>
    /// Events that will notify the user, according to their
    /// notification settings.
    /// </summary>
    ulong @numUnreadNotifications,
    /// <summary>
    /// Events causing mentions/highlights for the user, according to their
    /// notification settings.
    /// </summary>
    ulong @numUnreadMentions,
    /// <summary>
    /// The currently pinned event ids.
    /// </summary>
    List<string> @pinnedEventIds,
    /// <summary>
    /// The join rule for this room, if known.
    /// </summary>
    JoinRule? @joinRule,
    /// <summary>
    /// The history visibility for this room, if known.
    /// </summary>
    RoomHistoryVisibility @historyVisibility
) { }

class FfiConverterTypeRoomInfo : FfiConverterRustBuffer<RoomInfo>
{
    public static FfiConverterTypeRoomInfo INSTANCE = new FfiConverterTypeRoomInfo();

    public override RoomInfo Read(BigEndianStream stream)
    {
        return new RoomInfo(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @encryptionState: FfiConverterTypeEncryptionState.INSTANCE.Read(stream),
            @creator: FfiConverterOptionalString.INSTANCE.Read(stream),
            @displayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @rawName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @topic: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @isDirect: FfiConverterBoolean.INSTANCE.Read(stream),
            @isPublic: FfiConverterBoolean.INSTANCE.Read(stream),
            @isSpace: FfiConverterBoolean.INSTANCE.Read(stream),
            @isTombstoned: FfiConverterBoolean.INSTANCE.Read(stream),
            @isFavourite: FfiConverterBoolean.INSTANCE.Read(stream),
            @canonicalAlias: FfiConverterOptionalString.INSTANCE.Read(stream),
            @alternativeAliases: FfiConverterSequenceString.INSTANCE.Read(stream),
            @membership: FfiConverterTypeMembership.INSTANCE.Read(stream),
            @inviter: FfiConverterOptionalTypeRoomMember.INSTANCE.Read(stream),
            @heroes: FfiConverterSequenceTypeRoomHero.INSTANCE.Read(stream),
            @activeMembersCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @invitedMembersCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @joinedMembersCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @userPowerLevels: FfiConverterDictionaryStringInt64.INSTANCE.Read(stream),
            @highlightCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @notificationCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @cachedUserDefinedNotificationMode: FfiConverterOptionalTypeRoomNotificationMode.INSTANCE.Read(stream),
            @hasRoomCall: FfiConverterBoolean.INSTANCE.Read(stream),
            @activeRoomCallParticipants: FfiConverterSequenceString.INSTANCE.Read(stream),
            @isMarkedUnread: FfiConverterBoolean.INSTANCE.Read(stream),
            @numUnreadMessages: FfiConverterUInt64.INSTANCE.Read(stream),
            @numUnreadNotifications: FfiConverterUInt64.INSTANCE.Read(stream),
            @numUnreadMentions: FfiConverterUInt64.INSTANCE.Read(stream),
            @pinnedEventIds: FfiConverterSequenceString.INSTANCE.Read(stream),
            @joinRule: FfiConverterOptionalTypeJoinRule.INSTANCE.Read(stream),
            @historyVisibility: FfiConverterTypeRoomHistoryVisibility.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomInfo value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterTypeEncryptionState.INSTANCE.AllocationSize(value.@encryptionState)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@creator)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@rawName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@topic)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isDirect)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isPublic)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isSpace)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isTombstoned)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isFavourite)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@canonicalAlias)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@alternativeAliases)
            + FfiConverterTypeMembership.INSTANCE.AllocationSize(value.@membership)
            + FfiConverterOptionalTypeRoomMember.INSTANCE.AllocationSize(value.@inviter)
            + FfiConverterSequenceTypeRoomHero.INSTANCE.AllocationSize(value.@heroes)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@activeMembersCount)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@invitedMembersCount)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@joinedMembersCount)
            + FfiConverterDictionaryStringInt64.INSTANCE.AllocationSize(value.@userPowerLevels)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@highlightCount)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@notificationCount)
            + FfiConverterOptionalTypeRoomNotificationMode.INSTANCE.AllocationSize(
                value.@cachedUserDefinedNotificationMode
            )
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@hasRoomCall)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@activeRoomCallParticipants)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isMarkedUnread)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@numUnreadMessages)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@numUnreadNotifications)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@numUnreadMentions)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@pinnedEventIds)
            + FfiConverterOptionalTypeJoinRule.INSTANCE.AllocationSize(value.@joinRule)
            + FfiConverterTypeRoomHistoryVisibility.INSTANCE.AllocationSize(value.@historyVisibility);
    }

    public override void Write(RoomInfo value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@id, stream);
        FfiConverterTypeEncryptionState.INSTANCE.Write(value.@encryptionState, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@creator, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@rawName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@topic, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isDirect, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isPublic, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isSpace, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isTombstoned, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isFavourite, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@canonicalAlias, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@alternativeAliases, stream);
        FfiConverterTypeMembership.INSTANCE.Write(value.@membership, stream);
        FfiConverterOptionalTypeRoomMember.INSTANCE.Write(value.@inviter, stream);
        FfiConverterSequenceTypeRoomHero.INSTANCE.Write(value.@heroes, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@activeMembersCount, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@invitedMembersCount, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@joinedMembersCount, stream);
        FfiConverterDictionaryStringInt64.INSTANCE.Write(value.@userPowerLevels, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@highlightCount, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@notificationCount, stream);
        FfiConverterOptionalTypeRoomNotificationMode.INSTANCE.Write(value.@cachedUserDefinedNotificationMode, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@hasRoomCall, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@activeRoomCallParticipants, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isMarkedUnread, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@numUnreadMessages, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@numUnreadNotifications, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@numUnreadMentions, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@pinnedEventIds, stream);
        FfiConverterOptionalTypeJoinRule.INSTANCE.Write(value.@joinRule, stream);
        FfiConverterTypeRoomHistoryVisibility.INSTANCE.Write(value.@historyVisibility, stream);
    }
}

internal record RoomListLoadingStateResult(RoomListLoadingState @state, TaskHandle @stateStream) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@state, this.@stateStream);
    }
}

class FfiConverterTypeRoomListLoadingStateResult : FfiConverterRustBuffer<RoomListLoadingStateResult>
{
    public static FfiConverterTypeRoomListLoadingStateResult INSTANCE =
        new FfiConverterTypeRoomListLoadingStateResult();

    public override RoomListLoadingStateResult Read(BigEndianStream stream)
    {
        return new RoomListLoadingStateResult(
            @state: FfiConverterTypeRoomListLoadingState.INSTANCE.Read(stream),
            @stateStream: FfiConverterTypeTaskHandle.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomListLoadingStateResult value)
    {
        return 0
            + FfiConverterTypeRoomListLoadingState.INSTANCE.AllocationSize(value.@state)
            + FfiConverterTypeTaskHandle.INSTANCE.AllocationSize(value.@stateStream);
    }

    public override void Write(RoomListLoadingStateResult value, BigEndianStream stream)
    {
        FfiConverterTypeRoomListLoadingState.INSTANCE.Write(value.@state, stream);
        FfiConverterTypeTaskHandle.INSTANCE.Write(value.@stateStream, stream);
    }
}

internal record RoomMember(
    string @userId,
    string? @displayName,
    string? @avatarUrl,
    MembershipState @membership,
    bool @isNameAmbiguous,
    long @powerLevel,
    long @normalizedPowerLevel,
    bool @isIgnored,
    RoomMemberRole @suggestedRoleForPowerLevel,
    string? @membershipChangeReason
) { }

class FfiConverterTypeRoomMember : FfiConverterRustBuffer<RoomMember>
{
    public static FfiConverterTypeRoomMember INSTANCE = new FfiConverterTypeRoomMember();

    public override RoomMember Read(BigEndianStream stream)
    {
        return new RoomMember(
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @displayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @membership: FfiConverterTypeMembershipState.INSTANCE.Read(stream),
            @isNameAmbiguous: FfiConverterBoolean.INSTANCE.Read(stream),
            @powerLevel: FfiConverterInt64.INSTANCE.Read(stream),
            @normalizedPowerLevel: FfiConverterInt64.INSTANCE.Read(stream),
            @isIgnored: FfiConverterBoolean.INSTANCE.Read(stream),
            @suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.INSTANCE.Read(stream),
            @membershipChangeReason: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomMember value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterTypeMembershipState.INSTANCE.AllocationSize(value.@membership)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isNameAmbiguous)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@powerLevel)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@normalizedPowerLevel)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isIgnored)
            + FfiConverterTypeRoomMemberRole.INSTANCE.AllocationSize(value.@suggestedRoleForPowerLevel)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@membershipChangeReason);
    }

    public override void Write(RoomMember value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterTypeMembershipState.INSTANCE.Write(value.@membership, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isNameAmbiguous, stream);
        FfiConverterInt64.INSTANCE.Write(value.@powerLevel, stream);
        FfiConverterInt64.INSTANCE.Write(value.@normalizedPowerLevel, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isIgnored, stream);
        FfiConverterTypeRoomMemberRole.INSTANCE.Write(value.@suggestedRoleForPowerLevel, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@membershipChangeReason, stream);
    }
}

/// <summary>
/// Contains the current user's room member info and the optional room member
/// info of the sender of the `m.room.member` event that this info represents.
/// </summary>
internal record RoomMembershipDetails(RoomMember @ownRoomMember, RoomMember? @senderRoomMember) { }

class FfiConverterTypeRoomMembershipDetails : FfiConverterRustBuffer<RoomMembershipDetails>
{
    public static FfiConverterTypeRoomMembershipDetails INSTANCE = new FfiConverterTypeRoomMembershipDetails();

    public override RoomMembershipDetails Read(BigEndianStream stream)
    {
        return new RoomMembershipDetails(
            @ownRoomMember: FfiConverterTypeRoomMember.INSTANCE.Read(stream),
            @senderRoomMember: FfiConverterOptionalTypeRoomMember.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomMembershipDetails value)
    {
        return 0
            + FfiConverterTypeRoomMember.INSTANCE.AllocationSize(value.@ownRoomMember)
            + FfiConverterOptionalTypeRoomMember.INSTANCE.AllocationSize(value.@senderRoomMember);
    }

    public override void Write(RoomMembershipDetails value, BigEndianStream stream)
    {
        FfiConverterTypeRoomMember.INSTANCE.Write(value.@ownRoomMember, stream);
        FfiConverterOptionalTypeRoomMember.INSTANCE.Write(value.@senderRoomMember, stream);
    }
}

/// <summary>
/// `RoomNotificationSettings` represents the current settings for a `Room`
/// </summary>
/// <param name="mode">
/// The room notification mode
/// </param>
/// <param name="is_default">
/// Whether the mode is the default one
/// </param>
internal record RoomNotificationSettings(
    /// <summary>
    /// The room notification mode
    /// </summary>
    RoomNotificationMode @mode,
    /// <summary>
    /// Whether the mode is the default one
    /// </summary>
    bool @isDefault
) { }

class FfiConverterTypeRoomNotificationSettings : FfiConverterRustBuffer<RoomNotificationSettings>
{
    public static FfiConverterTypeRoomNotificationSettings INSTANCE = new FfiConverterTypeRoomNotificationSettings();

    public override RoomNotificationSettings Read(BigEndianStream stream)
    {
        return new RoomNotificationSettings(
            @mode: FfiConverterTypeRoomNotificationMode.INSTANCE.Read(stream),
            @isDefault: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomNotificationSettings value)
    {
        return 0
            + FfiConverterTypeRoomNotificationMode.INSTANCE.AllocationSize(value.@mode)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isDefault);
    }

    public override void Write(RoomNotificationSettings value, BigEndianStream stream)
    {
        FfiConverterTypeRoomNotificationMode.INSTANCE.Write(value.@mode, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@isDefault, stream);
    }
}

/// <param name="ban">
/// The level required to ban a user.
/// </param>
/// <param name="invite">
/// The level required to invite a user.
/// </param>
/// <param name="kick">
/// The level required to kick a user.
/// </param>
/// <param name="redact">
/// The level required to redact an event.
/// </param>
/// <param name="events_default">
/// The default level required to send message events.
/// </param>
/// <param name="state_default">
/// The default level required to send state events.
/// </param>
/// <param name="users_default">
/// The default power level for every user in the room.
/// </param>
/// <param name="room_name">
/// The level required to change the room's name.
/// </param>
/// <param name="room_avatar">
/// The level required to change the room's avatar.
/// </param>
/// <param name="room_topic">
/// The level required to change the room's topic.
/// </param>
internal record RoomPowerLevels(
    /// <summary>
    /// The level required to ban a user.
    /// </summary>
    long @ban,
    /// <summary>
    /// The level required to invite a user.
    /// </summary>
    long @invite,
    /// <summary>
    /// The level required to kick a user.
    /// </summary>
    long @kick,
    /// <summary>
    /// The level required to redact an event.
    /// </summary>
    long @redact,
    /// <summary>
    /// The default level required to send message events.
    /// </summary>
    long @eventsDefault,
    /// <summary>
    /// The default level required to send state events.
    /// </summary>
    long @stateDefault,
    /// <summary>
    /// The default power level for every user in the room.
    /// </summary>
    long @usersDefault,
    /// <summary>
    /// The level required to change the room's name.
    /// </summary>
    long @roomName,
    /// <summary>
    /// The level required to change the room's avatar.
    /// </summary>
    long @roomAvatar,
    /// <summary>
    /// The level required to change the room's topic.
    /// </summary>
    long @roomTopic
) { }

class FfiConverterTypeRoomPowerLevels : FfiConverterRustBuffer<RoomPowerLevels>
{
    public static FfiConverterTypeRoomPowerLevels INSTANCE = new FfiConverterTypeRoomPowerLevels();

    public override RoomPowerLevels Read(BigEndianStream stream)
    {
        return new RoomPowerLevels(
            @ban: FfiConverterInt64.INSTANCE.Read(stream),
            @invite: FfiConverterInt64.INSTANCE.Read(stream),
            @kick: FfiConverterInt64.INSTANCE.Read(stream),
            @redact: FfiConverterInt64.INSTANCE.Read(stream),
            @eventsDefault: FfiConverterInt64.INSTANCE.Read(stream),
            @stateDefault: FfiConverterInt64.INSTANCE.Read(stream),
            @usersDefault: FfiConverterInt64.INSTANCE.Read(stream),
            @roomName: FfiConverterInt64.INSTANCE.Read(stream),
            @roomAvatar: FfiConverterInt64.INSTANCE.Read(stream),
            @roomTopic: FfiConverterInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomPowerLevels value)
    {
        return 0
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@ban)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@invite)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@kick)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@redact)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@eventsDefault)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@stateDefault)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@usersDefault)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@roomName)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@roomAvatar)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@roomTopic);
    }

    public override void Write(RoomPowerLevels value, BigEndianStream stream)
    {
        FfiConverterInt64.INSTANCE.Write(value.@ban, stream);
        FfiConverterInt64.INSTANCE.Write(value.@invite, stream);
        FfiConverterInt64.INSTANCE.Write(value.@kick, stream);
        FfiConverterInt64.INSTANCE.Write(value.@redact, stream);
        FfiConverterInt64.INSTANCE.Write(value.@eventsDefault, stream);
        FfiConverterInt64.INSTANCE.Write(value.@stateDefault, stream);
        FfiConverterInt64.INSTANCE.Write(value.@usersDefault, stream);
        FfiConverterInt64.INSTANCE.Write(value.@roomName, stream);
        FfiConverterInt64.INSTANCE.Write(value.@roomAvatar, stream);
        FfiConverterInt64.INSTANCE.Write(value.@roomTopic, stream);
    }
}

/// <summary>
/// The preview of a room, be it invited/joined/left, or not.
/// </summary>
/// <param name="room_id">
/// The room id for this room.
/// </param>
/// <param name="canonical_alias">
/// The canonical alias for the room.
/// </param>
/// <param name="name">
/// The room's name, if set.
/// </param>
/// <param name="topic">
/// The room's topic, if set.
/// </param>
/// <param name="avatar_url">
/// The MXC URI to the room's avatar, if set.
/// </param>
/// <param name="num_joined_members">
/// The number of joined members.
/// </param>
/// <param name="num_active_members">
/// The number of active members, if known (joined + invited).
/// </param>
/// <param name="room_type">
/// The room type (space, custom) or nothing, if it's a regular room.
/// </param>
/// <param name="is_history_world_readable">
/// Is the history world-readable for this room?
/// </param>
/// <param name="membership">
/// The membership state for the current user, if known.
/// </param>
/// <param name="join_rule">
/// The join rule for this room (private, public, knock, etc.).
/// </param>
/// <param name="is_direct">
/// Whether the room is direct or not, if known.
/// </param>
/// <param name="heroes">
/// Room heroes.
/// </param>
internal record RoomPreviewInfo(
    /// <summary>
    /// The room id for this room.
    /// </summary>
    string @roomId,
    /// <summary>
    /// The canonical alias for the room.
    /// </summary>
    string? @canonicalAlias,
    /// <summary>
    /// The room's name, if set.
    /// </summary>
    string? @name,
    /// <summary>
    /// The room's topic, if set.
    /// </summary>
    string? @topic,
    /// <summary>
    /// The MXC URI to the room's avatar, if set.
    /// </summary>
    string? @avatarUrl,
    /// <summary>
    /// The number of joined members.
    /// </summary>
    ulong @numJoinedMembers,
    /// <summary>
    /// The number of active members, if known (joined + invited).
    /// </summary>
    ulong? @numActiveMembers,
    /// <summary>
    /// The room type (space, custom) or nothing, if it's a regular room.
    /// </summary>
    RoomType @roomType,
    /// <summary>
    /// Is the history world-readable for this room?
    /// </summary>
    bool? @isHistoryWorldReadable,
    /// <summary>
    /// The membership state for the current user, if known.
    /// </summary>
    Membership? @membership,
    /// <summary>
    /// The join rule for this room (private, public, knock, etc.).
    /// </summary>
    JoinRule @joinRule,
    /// <summary>
    /// Whether the room is direct or not, if known.
    /// </summary>
    bool? @isDirect,
    /// <summary>
    /// Room heroes.
    /// </summary>
    List<RoomHero>? @heroes
) { }

class FfiConverterTypeRoomPreviewInfo : FfiConverterRustBuffer<RoomPreviewInfo>
{
    public static FfiConverterTypeRoomPreviewInfo INSTANCE = new FfiConverterTypeRoomPreviewInfo();

    public override RoomPreviewInfo Read(BigEndianStream stream)
    {
        return new RoomPreviewInfo(
            @roomId: FfiConverterString.INSTANCE.Read(stream),
            @canonicalAlias: FfiConverterOptionalString.INSTANCE.Read(stream),
            @name: FfiConverterOptionalString.INSTANCE.Read(stream),
            @topic: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @numJoinedMembers: FfiConverterUInt64.INSTANCE.Read(stream),
            @numActiveMembers: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @roomType: FfiConverterTypeRoomType.INSTANCE.Read(stream),
            @isHistoryWorldReadable: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @membership: FfiConverterOptionalTypeMembership.INSTANCE.Read(stream),
            @joinRule: FfiConverterTypeJoinRule.INSTANCE.Read(stream),
            @isDirect: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @heroes: FfiConverterOptionalSequenceTypeRoomHero.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomPreviewInfo value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@roomId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@canonicalAlias)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@topic)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@numJoinedMembers)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@numActiveMembers)
            + FfiConverterTypeRoomType.INSTANCE.AllocationSize(value.@roomType)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isHistoryWorldReadable)
            + FfiConverterOptionalTypeMembership.INSTANCE.AllocationSize(value.@membership)
            + FfiConverterTypeJoinRule.INSTANCE.AllocationSize(value.@joinRule)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isDirect)
            + FfiConverterOptionalSequenceTypeRoomHero.INSTANCE.AllocationSize(value.@heroes);
    }

    public override void Write(RoomPreviewInfo value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@roomId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@canonicalAlias, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@name, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@topic, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@numJoinedMembers, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@numActiveMembers, stream);
        FfiConverterTypeRoomType.INSTANCE.Write(value.@roomType, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@isHistoryWorldReadable, stream);
        FfiConverterOptionalTypeMembership.INSTANCE.Write(value.@membership, stream);
        FfiConverterTypeJoinRule.INSTANCE.Write(value.@joinRule, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@isDirect, stream);
        FfiConverterOptionalSequenceTypeRoomHero.INSTANCE.Write(value.@heroes, stream);
    }
}

internal record SearchUsersResults(List<UserProfile> @results, bool @limited) { }

class FfiConverterTypeSearchUsersResults : FfiConverterRustBuffer<SearchUsersResults>
{
    public static FfiConverterTypeSearchUsersResults INSTANCE = new FfiConverterTypeSearchUsersResults();

    public override SearchUsersResults Read(BigEndianStream stream)
    {
        return new SearchUsersResults(
            @results: FfiConverterSequenceTypeUserProfile.INSTANCE.Read(stream),
            @limited: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SearchUsersResults value)
    {
        return 0
            + FfiConverterSequenceTypeUserProfile.INSTANCE.AllocationSize(value.@results)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@limited);
    }

    public override void Write(SearchUsersResults value, BigEndianStream stream)
    {
        FfiConverterSequenceTypeUserProfile.INSTANCE.Write(value.@results, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@limited, stream);
    }
}

/// <param name="access_token">
/// The access token used for this session.
/// </param>
/// <param name="refresh_token">
/// The token used for [refreshing the access token], if any.
///
/// [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
/// </param>
/// <param name="user_id">
/// The user the access token was issued for.
/// </param>
/// <param name="device_id">
/// The ID of the client device.
/// </param>
/// <param name="homeserver_url">
/// The URL for the homeserver used for this session.
/// </param>
/// <param name="oidc_data">
/// Additional data for this session if OpenID Connect was used for
/// authentication.
/// </param>
/// <param name="sliding_sync_version">
/// The sliding sync version used for this session.
/// </param>
internal record Session(
    /// <summary>
    /// The access token used for this session.
    /// </summary>
    string @accessToken,
    /// <summary>
    /// The token used for [refreshing the access token], if any.
    ///
    /// [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
    /// </summary>
    string? @refreshToken,
    /// <summary>
    /// The user the access token was issued for.
    /// </summary>
    string @userId,
    /// <summary>
    /// The ID of the client device.
    /// </summary>
    string @deviceId,
    /// <summary>
    /// The URL for the homeserver used for this session.
    /// </summary>
    string @homeserverUrl,
    /// <summary>
    /// Additional data for this session if OpenID Connect was used for
    /// authentication.
    /// </summary>
    string? @oidcData,
    /// <summary>
    /// The sliding sync version used for this session.
    /// </summary>
    SlidingSyncVersion @slidingSyncVersion
) { }

class FfiConverterTypeSession : FfiConverterRustBuffer<Session>
{
    public static FfiConverterTypeSession INSTANCE = new FfiConverterTypeSession();

    public override Session Read(BigEndianStream stream)
    {
        return new Session(
            @accessToken: FfiConverterString.INSTANCE.Read(stream),
            @refreshToken: FfiConverterOptionalString.INSTANCE.Read(stream),
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @deviceId: FfiConverterString.INSTANCE.Read(stream),
            @homeserverUrl: FfiConverterString.INSTANCE.Read(stream),
            @oidcData: FfiConverterOptionalString.INSTANCE.Read(stream),
            @slidingSyncVersion: FfiConverterTypeSlidingSyncVersion.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Session value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@accessToken)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@refreshToken)
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@deviceId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@homeserverUrl)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@oidcData)
            + FfiConverterTypeSlidingSyncVersion.INSTANCE.AllocationSize(value.@slidingSyncVersion);
    }

    public override void Write(Session value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@accessToken, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@refreshToken, stream);
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterString.INSTANCE.Write(value.@deviceId, stream);
        FfiConverterString.INSTANCE.Write(value.@homeserverUrl, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@oidcData, stream);
        FfiConverterTypeSlidingSyncVersion.INSTANCE.Write(value.@slidingSyncVersion, stream);
    }
}

/// <summary>
/// Details about the incoming verification request
/// </summary>
/// <param name="first_seen_timestamp">
/// First time this device was seen in milliseconds since epoch.
/// </param>
internal record SessionVerificationRequestDetails(
    UserProfile @senderProfile,
    string @flowId,
    string @deviceId,
    string? @deviceDisplayName,
    /// <summary>
    /// First time this device was seen in milliseconds since epoch.
    /// </summary>
    Timestamp @firstSeenTimestamp
) { }

class FfiConverterTypeSessionVerificationRequestDetails : FfiConverterRustBuffer<SessionVerificationRequestDetails>
{
    public static FfiConverterTypeSessionVerificationRequestDetails INSTANCE =
        new FfiConverterTypeSessionVerificationRequestDetails();

    public override SessionVerificationRequestDetails Read(BigEndianStream stream)
    {
        return new SessionVerificationRequestDetails(
            @senderProfile: FfiConverterTypeUserProfile.INSTANCE.Read(stream),
            @flowId: FfiConverterString.INSTANCE.Read(stream),
            @deviceId: FfiConverterString.INSTANCE.Read(stream),
            @deviceDisplayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @firstSeenTimestamp: FfiConverterTypeTimestamp.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SessionVerificationRequestDetails value)
    {
        return 0
            + FfiConverterTypeUserProfile.INSTANCE.AllocationSize(value.@senderProfile)
            + FfiConverterString.INSTANCE.AllocationSize(value.@flowId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@deviceId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@deviceDisplayName)
            + FfiConverterTypeTimestamp.INSTANCE.AllocationSize(value.@firstSeenTimestamp);
    }

    public override void Write(SessionVerificationRequestDetails value, BigEndianStream stream)
    {
        FfiConverterTypeUserProfile.INSTANCE.Write(value.@senderProfile, stream);
        FfiConverterString.INSTANCE.Write(value.@flowId, stream);
        FfiConverterString.INSTANCE.Write(value.@deviceId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@deviceDisplayName, stream);
        FfiConverterTypeTimestamp.INSTANCE.Write(value.@firstSeenTimestamp, stream);
    }
}

internal record SetData(uint @index, TimelineItem @item) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@index, this.@item);
    }
}

class FfiConverterTypeSetData : FfiConverterRustBuffer<SetData>
{
    public static FfiConverterTypeSetData INSTANCE = new FfiConverterTypeSetData();

    public override SetData Read(BigEndianStream stream)
    {
        return new SetData(
            @index: FfiConverterUInt32.INSTANCE.Read(stream),
            @item: FfiConverterTypeTimelineItem.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SetData value)
    {
        return 0
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@index)
            + FfiConverterTypeTimelineItem.INSTANCE.AllocationSize(value.@item);
    }

    public override void Write(SetData value, BigEndianStream stream)
    {
        FfiConverterUInt32.INSTANCE.Write(value.@index, stream);
        FfiConverterTypeTimelineItem.INSTANCE.Write(value.@item, stream);
    }
}

internal record TextMessageContent(string @body, FormattedBody? @formatted) { }

class FfiConverterTypeTextMessageContent : FfiConverterRustBuffer<TextMessageContent>
{
    public static FfiConverterTypeTextMessageContent INSTANCE = new FfiConverterTypeTextMessageContent();

    public override TextMessageContent Read(BigEndianStream stream)
    {
        return new TextMessageContent(
            @body: FfiConverterString.INSTANCE.Read(stream),
            @formatted: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TextMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@body)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formatted);
    }

    public override void Write(TextMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@body, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formatted, stream);
    }
}

internal record ThumbnailInfo(ulong? @height, ulong? @width, string? @mimetype, ulong? @size) { }

class FfiConverterTypeThumbnailInfo : FfiConverterRustBuffer<ThumbnailInfo>
{
    public static FfiConverterTypeThumbnailInfo INSTANCE = new FfiConverterTypeThumbnailInfo();

    public override ThumbnailInfo Read(BigEndianStream stream)
    {
        return new ThumbnailInfo(
            @height: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @width: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @mimetype: FfiConverterOptionalString.INSTANCE.Read(stream),
            @size: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ThumbnailInfo value)
    {
        return 0
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@height)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@width)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@mimetype)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@size);
    }

    public override void Write(ThumbnailInfo value, BigEndianStream stream)
    {
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@height, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@width, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@mimetype, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@size, stream);
    }
}

/// <summary>
/// Various options used to configure the timeline's behavior.
/// </summary>
/// <param name="focus">
/// What should the timeline focus on?
/// </param>
/// <param name="filter">
/// How should we filter out events from the timeline?
/// </param>
/// <param name="internal_id_prefix">
/// An optional String that will be prepended to
/// all the timeline item's internal IDs, making it possible to
/// distinguish different timeline instances from each other.
/// </param>
/// <param name="date_divider_mode">
/// How often to insert date dividers
/// </param>
/// <param name="track_read_receipts">
/// Should the read receipts and read markers be tracked for the timeline
/// items in this instance?
///
/// As this has a non negligible performance impact, make sure to enable it
/// only when you need it.
/// </param>
internal record TimelineConfiguration(
    /// <summary>
    /// What should the timeline focus on?
    /// </summary>
    TimelineFocus @focus,
    /// <summary>
    /// How should we filter out events from the timeline?
    /// </summary>
    TimelineFilter @filter,
    /// <summary>
    /// An optional String that will be prepended to
    /// all the timeline item's internal IDs, making it possible to
    /// distinguish different timeline instances from each other.
    /// </summary>
    string? @internalIdPrefix,
    /// <summary>
    /// How often to insert date dividers
    /// </summary>
    DateDividerMode @dateDividerMode,
    /// <summary>
    /// Should the read receipts and read markers be tracked for the timeline
    /// items in this instance?
    ///
    /// As this has a non negligible performance impact, make sure to enable it
    /// only when you need it.
    /// </summary>
    bool @trackReadReceipts
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@focus,
            this.@filter,
            this.@internalIdPrefix,
            this.@dateDividerMode,
            this.@trackReadReceipts
        );
    }
}

class FfiConverterTypeTimelineConfiguration : FfiConverterRustBuffer<TimelineConfiguration>
{
    public static FfiConverterTypeTimelineConfiguration INSTANCE = new FfiConverterTypeTimelineConfiguration();

    public override TimelineConfiguration Read(BigEndianStream stream)
    {
        return new TimelineConfiguration(
            @focus: FfiConverterTypeTimelineFocus.INSTANCE.Read(stream),
            @filter: FfiConverterTypeTimelineFilter.INSTANCE.Read(stream),
            @internalIdPrefix: FfiConverterOptionalString.INSTANCE.Read(stream),
            @dateDividerMode: FfiConverterTypeDateDividerMode.INSTANCE.Read(stream),
            @trackReadReceipts: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TimelineConfiguration value)
    {
        return 0
            + FfiConverterTypeTimelineFocus.INSTANCE.AllocationSize(value.@focus)
            + FfiConverterTypeTimelineFilter.INSTANCE.AllocationSize(value.@filter)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@internalIdPrefix)
            + FfiConverterTypeDateDividerMode.INSTANCE.AllocationSize(value.@dateDividerMode)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@trackReadReceipts);
    }

    public override void Write(TimelineConfiguration value, BigEndianStream stream)
    {
        FfiConverterTypeTimelineFocus.INSTANCE.Write(value.@focus, stream);
        FfiConverterTypeTimelineFilter.INSTANCE.Write(value.@filter, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@internalIdPrefix, stream);
        FfiConverterTypeDateDividerMode.INSTANCE.Write(value.@dateDividerMode, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@trackReadReceipts, stream);
    }
}

internal record TimelineUniqueId(string @id) { }

class FfiConverterTypeTimelineUniqueId : FfiConverterRustBuffer<TimelineUniqueId>
{
    public static FfiConverterTypeTimelineUniqueId INSTANCE = new FfiConverterTypeTimelineUniqueId();

    public override TimelineUniqueId Read(BigEndianStream stream)
    {
        return new TimelineUniqueId(@id: FfiConverterString.INSTANCE.Read(stream));
    }

    public override int AllocationSize(TimelineUniqueId value)
    {
        return 0 + FfiConverterString.INSTANCE.AllocationSize(value.@id);
    }

    public override void Write(TimelineUniqueId value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@id, stream);
    }
}

/// <param name="log_level">
/// The desired log level.
/// </param>
/// <param name="trace_log_packs">
/// All the log packs, that will be set to `TRACE` when they're enabled.
/// </param>
/// <param name="extra_targets">
/// Additional targets that the FFI client would like to use.
///
/// This can include, for instance, the target names for created
/// [`crate::tracing::Span`]. These targets will use the global log level by
/// default.
/// </param>
/// <param name="write_to_stdout_or_system">
/// Whether to log to stdout, or in the logcat on Android.
/// </param>
/// <param name="write_to_files">
/// If set, configures rotated log files where to write additional logs.
/// </param>
internal record TracingConfiguration(
    /// <summary>
    /// The desired log level.
    /// </summary>
    LogLevel @logLevel,
    /// <summary>
    /// All the log packs, that will be set to `TRACE` when they're enabled.
    /// </summary>
    List<TraceLogPacks> @traceLogPacks,
    /// <summary>
    /// Additional targets that the FFI client would like to use.
    ///
    /// This can include, for instance, the target names for created
    /// [`crate::tracing::Span`]. These targets will use the global log level by
    /// default.
    /// </summary>
    List<string> @extraTargets,
    /// <summary>
    /// Whether to log to stdout, or in the logcat on Android.
    /// </summary>
    bool @writeToStdoutOrSystem,
    /// <summary>
    /// If set, configures rotated log files where to write additional logs.
    /// </summary>
    TracingFileConfiguration? @writeToFiles
) { }

class FfiConverterTypeTracingConfiguration : FfiConverterRustBuffer<TracingConfiguration>
{
    public static FfiConverterTypeTracingConfiguration INSTANCE = new FfiConverterTypeTracingConfiguration();

    public override TracingConfiguration Read(BigEndianStream stream)
    {
        return new TracingConfiguration(
            @logLevel: FfiConverterTypeLogLevel.INSTANCE.Read(stream),
            @traceLogPacks: FfiConverterSequenceTypeTraceLogPacks.INSTANCE.Read(stream),
            @extraTargets: FfiConverterSequenceString.INSTANCE.Read(stream),
            @writeToStdoutOrSystem: FfiConverterBoolean.INSTANCE.Read(stream),
            @writeToFiles: FfiConverterOptionalTypeTracingFileConfiguration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TracingConfiguration value)
    {
        return 0
            + FfiConverterTypeLogLevel.INSTANCE.AllocationSize(value.@logLevel)
            + FfiConverterSequenceTypeTraceLogPacks.INSTANCE.AllocationSize(value.@traceLogPacks)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@extraTargets)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@writeToStdoutOrSystem)
            + FfiConverterOptionalTypeTracingFileConfiguration.INSTANCE.AllocationSize(value.@writeToFiles);
    }

    public override void Write(TracingConfiguration value, BigEndianStream stream)
    {
        FfiConverterTypeLogLevel.INSTANCE.Write(value.@logLevel, stream);
        FfiConverterSequenceTypeTraceLogPacks.INSTANCE.Write(value.@traceLogPacks, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@extraTargets, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@writeToStdoutOrSystem, stream);
        FfiConverterOptionalTypeTracingFileConfiguration.INSTANCE.Write(value.@writeToFiles, stream);
    }
}

/// <summary>
/// Configuration to save logs to (rotated) log-files.
/// </summary>
/// <param name="path">
/// Base location for all the log files.
/// </param>
/// <param name="file_prefix">
/// Prefix for the log files' names.
/// </param>
/// <param name="file_suffix">
/// Optional suffix for the log file's names.
/// </param>
/// <param name="max_files">
/// Maximum number of rotated files.
///
/// If not set, there's no max limit, i.e. the number of log files is
/// unlimited.
/// </param>
internal record TracingFileConfiguration(
    /// <summary>
    /// Base location for all the log files.
    /// </summary>
    string @path,
    /// <summary>
    /// Prefix for the log files' names.
    /// </summary>
    string @filePrefix,
    /// <summary>
    /// Optional suffix for the log file's names.
    /// </summary>
    string? @fileSuffix,
    /// <summary>
    /// Maximum number of rotated files.
    ///
    /// If not set, there's no max limit, i.e. the number of log files is
    /// unlimited.
    /// </summary>
    ulong? @maxFiles
) { }

class FfiConverterTypeTracingFileConfiguration : FfiConverterRustBuffer<TracingFileConfiguration>
{
    public static FfiConverterTypeTracingFileConfiguration INSTANCE = new FfiConverterTypeTracingFileConfiguration();

    public override TracingFileConfiguration Read(BigEndianStream stream)
    {
        return new TracingFileConfiguration(
            @path: FfiConverterString.INSTANCE.Read(stream),
            @filePrefix: FfiConverterString.INSTANCE.Read(stream),
            @fileSuffix: FfiConverterOptionalString.INSTANCE.Read(stream),
            @maxFiles: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TracingFileConfiguration value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@path)
            + FfiConverterString.INSTANCE.AllocationSize(value.@filePrefix)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@fileSuffix)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@maxFiles);
    }

    public override void Write(TracingFileConfiguration value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@path, stream);
        FfiConverterString.INSTANCE.Write(value.@filePrefix, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@fileSuffix, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@maxFiles, stream);
    }
}

internal record TransmissionProgress(ulong @current, ulong @total) { }

class FfiConverterTypeTransmissionProgress : FfiConverterRustBuffer<TransmissionProgress>
{
    public static FfiConverterTypeTransmissionProgress INSTANCE = new FfiConverterTypeTransmissionProgress();

    public override TransmissionProgress Read(BigEndianStream stream)
    {
        return new TransmissionProgress(
            @current: FfiConverterUInt64.INSTANCE.Read(stream),
            @total: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TransmissionProgress value)
    {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@current)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@total);
    }

    public override void Write(TransmissionProgress value, BigEndianStream stream)
    {
        FfiConverterUInt64.INSTANCE.Write(value.@current, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@total, stream);
    }
}

/// <param name="event_id">
/// The identifier of the event that couldn't get decrypted.
/// </param>
/// <param name="time_to_decrypt_ms">
/// If the event could be decrypted late (that is, the event was encrypted
/// at first, but could be decrypted later on), then this indicates the
/// time it took to decrypt the event. If it is not set, this is
/// considered a definite UTD.
///
/// If set, this is in milliseconds.
/// </param>
/// <param name="cause">
/// What we know about what caused this UTD. E.g. was this event sent when
/// we were not a member of this room?
/// </param>
/// <param name="event_local_age_millis">
/// The difference between the event creation time (`origin_server_ts`) and
/// the time our device was created. If negative, this event was sent
/// *before* our device was created.
/// </param>
/// <param name="user_trusts_own_identity">
/// Whether the user had verified their own identity at the point they
/// received the UTD event.
/// </param>
/// <param name="sender_homeserver">
/// The homeserver of the user that sent the undecryptable event.
/// </param>
/// <param name="own_homeserver">
/// Our local user's own homeserver, or `None` if the client is not logged
/// in.
/// </param>
internal record UnableToDecryptInfo(
    /// <summary>
    /// The identifier of the event that couldn't get decrypted.
    /// </summary>
    string @eventId,
    /// <summary>
    /// If the event could be decrypted late (that is, the event was encrypted
    /// at first, but could be decrypted later on), then this indicates the
    /// time it took to decrypt the event. If it is not set, this is
    /// considered a definite UTD.
    ///
    /// If set, this is in milliseconds.
    /// </summary>
    ulong? @timeToDecryptMs,
    /// <summary>
    /// What we know about what caused this UTD. E.g. was this event sent when
    /// we were not a member of this room?
    /// </summary>
    UtdCause @cause,
    /// <summary>
    /// The difference between the event creation time (`origin_server_ts`) and
    /// the time our device was created. If negative, this event was sent
    /// *before* our device was created.
    /// </summary>
    long @eventLocalAgeMillis,
    /// <summary>
    /// Whether the user had verified their own identity at the point they
    /// received the UTD event.
    /// </summary>
    bool @userTrustsOwnIdentity,
    /// <summary>
    /// The homeserver of the user that sent the undecryptable event.
    /// </summary>
    string @senderHomeserver,
    /// <summary>
    /// Our local user's own homeserver, or `None` if the client is not logged
    /// in.
    /// </summary>
    string? @ownHomeserver
) { }

class FfiConverterTypeUnableToDecryptInfo : FfiConverterRustBuffer<UnableToDecryptInfo>
{
    public static FfiConverterTypeUnableToDecryptInfo INSTANCE = new FfiConverterTypeUnableToDecryptInfo();

    public override UnableToDecryptInfo Read(BigEndianStream stream)
    {
        return new UnableToDecryptInfo(
            @eventId: FfiConverterString.INSTANCE.Read(stream),
            @timeToDecryptMs: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @cause: FfiConverterTypeUtdCause.INSTANCE.Read(stream),
            @eventLocalAgeMillis: FfiConverterInt64.INSTANCE.Read(stream),
            @userTrustsOwnIdentity: FfiConverterBoolean.INSTANCE.Read(stream),
            @senderHomeserver: FfiConverterString.INSTANCE.Read(stream),
            @ownHomeserver: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UnableToDecryptInfo value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@eventId)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@timeToDecryptMs)
            + FfiConverterTypeUtdCause.INSTANCE.AllocationSize(value.@cause)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@eventLocalAgeMillis)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@userTrustsOwnIdentity)
            + FfiConverterString.INSTANCE.AllocationSize(value.@senderHomeserver)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@ownHomeserver);
    }

    public override void Write(UnableToDecryptInfo value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@eventId, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@timeToDecryptMs, stream);
        FfiConverterTypeUtdCause.INSTANCE.Write(value.@cause, stream);
        FfiConverterInt64.INSTANCE.Write(value.@eventLocalAgeMillis, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@userTrustsOwnIdentity, stream);
        FfiConverterString.INSTANCE.Write(value.@senderHomeserver, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@ownHomeserver, stream);
    }
}

internal record UnstableAudioDetailsContent(TimeSpan @duration, List<ushort> @waveform) { }

class FfiConverterTypeUnstableAudioDetailsContent : FfiConverterRustBuffer<UnstableAudioDetailsContent>
{
    public static FfiConverterTypeUnstableAudioDetailsContent INSTANCE =
        new FfiConverterTypeUnstableAudioDetailsContent();

    public override UnstableAudioDetailsContent Read(BigEndianStream stream)
    {
        return new UnstableAudioDetailsContent(
            @duration: FfiConverterDuration.INSTANCE.Read(stream),
            @waveform: FfiConverterSequenceUInt16.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UnstableAudioDetailsContent value)
    {
        return 0
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@duration)
            + FfiConverterSequenceUInt16.INSTANCE.AllocationSize(value.@waveform);
    }

    public override void Write(UnstableAudioDetailsContent value, BigEndianStream stream)
    {
        FfiConverterDuration.INSTANCE.Write(value.@duration, stream);
        FfiConverterSequenceUInt16.INSTANCE.Write(value.@waveform, stream);
    }
}

internal record UnstableVoiceContent() { }

class FfiConverterTypeUnstableVoiceContent : FfiConverterRustBuffer<UnstableVoiceContent>
{
    public static FfiConverterTypeUnstableVoiceContent INSTANCE = new FfiConverterTypeUnstableVoiceContent();

    public override UnstableVoiceContent Read(BigEndianStream stream)
    {
        return new UnstableVoiceContent();
    }

    public override int AllocationSize(UnstableVoiceContent value)
    {
        return 0;
    }

    public override void Write(UnstableVoiceContent value, BigEndianStream stream) { }
}

/// <param name="filename">
/// Filename (previously called "url") for the media to be sent.
/// </param>
/// <param name="caption">
/// Optional non-formatted caption, for clients that support it.
/// </param>
/// <param name="formatted_caption">
/// Optional HTML-formatted caption, for clients that support it.
/// </param>
/// <param name="mentions">
/// Optional intentional mentions to be sent with the media.
/// </param>
/// <param name="reply_params">
/// Optional parameters for sending the media as (threaded) reply.
/// </param>
/// <param name="use_send_queue">
/// Should the media be sent with the send queue, or synchronously?
///
/// Watching progress only works with the synchronous method, at the moment.
/// </param>
internal record UploadParameters(
    /// <summary>
    /// Filename (previously called "url") for the media to be sent.
    /// </summary>
    string @filename,
    /// <summary>
    /// Optional non-formatted caption, for clients that support it.
    /// </summary>
    string? @caption,
    /// <summary>
    /// Optional HTML-formatted caption, for clients that support it.
    /// </summary>
    FormattedBody? @formattedCaption,
    /// <summary>
    /// Optional intentional mentions to be sent with the media.
    /// </summary>
    Mentions? @mentions,
    /// <summary>
    /// Optional parameters for sending the media as (threaded) reply.
    /// </summary>
    ReplyParameters? @replyParams,
    /// <summary>
    /// Should the media be sent with the send queue, or synchronously?
    ///
    /// Watching progress only works with the synchronous method, at the moment.
    /// </summary>
    bool @useSendQueue
) { }

class FfiConverterTypeUploadParameters : FfiConverterRustBuffer<UploadParameters>
{
    public static FfiConverterTypeUploadParameters INSTANCE = new FfiConverterTypeUploadParameters();

    public override UploadParameters Read(BigEndianStream stream)
    {
        return new UploadParameters(
            @filename: FfiConverterString.INSTANCE.Read(stream),
            @caption: FfiConverterOptionalString.INSTANCE.Read(stream),
            @formattedCaption: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream),
            @mentions: FfiConverterOptionalTypeMentions.INSTANCE.Read(stream),
            @replyParams: FfiConverterOptionalTypeReplyParameters.INSTANCE.Read(stream),
            @useSendQueue: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UploadParameters value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@filename)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@caption)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formattedCaption)
            + FfiConverterOptionalTypeMentions.INSTANCE.AllocationSize(value.@mentions)
            + FfiConverterOptionalTypeReplyParameters.INSTANCE.AllocationSize(value.@replyParams)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@useSendQueue);
    }

    public override void Write(UploadParameters value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@filename, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@caption, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formattedCaption, stream);
        FfiConverterOptionalTypeMentions.INSTANCE.Write(value.@mentions, stream);
        FfiConverterOptionalTypeReplyParameters.INSTANCE.Write(value.@replyParams, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@useSendQueue, stream);
    }
}

/// <summary>
/// An update for a particular user's power level within the room.
/// </summary>
/// <param name="user_id">
/// The user ID of the user to update.
/// </param>
/// <param name="power_level">
/// The power level to assign to the user.
/// </param>
internal record UserPowerLevelUpdate(
    /// <summary>
    /// The user ID of the user to update.
    /// </summary>
    string @userId,
    /// <summary>
    /// The power level to assign to the user.
    /// </summary>
    long @powerLevel
) { }

class FfiConverterTypeUserPowerLevelUpdate : FfiConverterRustBuffer<UserPowerLevelUpdate>
{
    public static FfiConverterTypeUserPowerLevelUpdate INSTANCE = new FfiConverterTypeUserPowerLevelUpdate();

    public override UserPowerLevelUpdate Read(BigEndianStream stream)
    {
        return new UserPowerLevelUpdate(
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @powerLevel: FfiConverterInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UserPowerLevelUpdate value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@powerLevel);
    }

    public override void Write(UserPowerLevelUpdate value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterInt64.INSTANCE.Write(value.@powerLevel, stream);
    }
}

internal record UserProfile(string @userId, string? @displayName, string? @avatarUrl) { }

class FfiConverterTypeUserProfile : FfiConverterRustBuffer<UserProfile>
{
    public static FfiConverterTypeUserProfile INSTANCE = new FfiConverterTypeUserProfile();

    public override UserProfile Read(BigEndianStream stream)
    {
        return new UserProfile(
            @userId: FfiConverterString.INSTANCE.Read(stream),
            @displayName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @avatarUrl: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UserProfile value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@userId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@avatarUrl);
    }

    public override void Write(UserProfile value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@userId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@displayName, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@avatarUrl, stream);
    }
}

internal record VideoInfo(
    TimeSpan? @duration,
    ulong? @height,
    ulong? @width,
    string? @mimetype,
    ulong? @size,
    ThumbnailInfo? @thumbnailInfo,
    MediaSource? @thumbnailSource,
    string? @blurhash
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(
            this.@duration,
            this.@height,
            this.@width,
            this.@mimetype,
            this.@size,
            this.@thumbnailInfo,
            this.@thumbnailSource,
            this.@blurhash
        );
    }
}

class FfiConverterTypeVideoInfo : FfiConverterRustBuffer<VideoInfo>
{
    public static FfiConverterTypeVideoInfo INSTANCE = new FfiConverterTypeVideoInfo();

    public override VideoInfo Read(BigEndianStream stream)
    {
        return new VideoInfo(
            @duration: FfiConverterOptionalDuration.INSTANCE.Read(stream),
            @height: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @width: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @mimetype: FfiConverterOptionalString.INSTANCE.Read(stream),
            @size: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.INSTANCE.Read(stream),
            @thumbnailSource: FfiConverterOptionalTypeMediaSource.INSTANCE.Read(stream),
            @blurhash: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(VideoInfo value)
    {
        return 0
            + FfiConverterOptionalDuration.INSTANCE.AllocationSize(value.@duration)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@height)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@width)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@mimetype)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@size)
            + FfiConverterOptionalTypeThumbnailInfo.INSTANCE.AllocationSize(value.@thumbnailInfo)
            + FfiConverterOptionalTypeMediaSource.INSTANCE.AllocationSize(value.@thumbnailSource)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@blurhash);
    }

    public override void Write(VideoInfo value, BigEndianStream stream)
    {
        FfiConverterOptionalDuration.INSTANCE.Write(value.@duration, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@height, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@width, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@mimetype, stream);
        FfiConverterOptionalUInt64.INSTANCE.Write(value.@size, stream);
        FfiConverterOptionalTypeThumbnailInfo.INSTANCE.Write(value.@thumbnailInfo, stream);
        FfiConverterOptionalTypeMediaSource.INSTANCE.Write(value.@thumbnailSource, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@blurhash, stream);
    }
}

/// <param name="filename">
/// The computed filename, for use in a client.
/// </param>
internal record VideoMessageContent(
    /// <summary>
    /// The computed filename, for use in a client.
    /// </summary>
    string @filename,
    string? @caption,
    FormattedBody? @formattedCaption,
    MediaSource @source,
    VideoInfo? @info
) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@filename, this.@caption, this.@formattedCaption, this.@source, this.@info);
    }
}

class FfiConverterTypeVideoMessageContent : FfiConverterRustBuffer<VideoMessageContent>
{
    public static FfiConverterTypeVideoMessageContent INSTANCE = new FfiConverterTypeVideoMessageContent();

    public override VideoMessageContent Read(BigEndianStream stream)
    {
        return new VideoMessageContent(
            @filename: FfiConverterString.INSTANCE.Read(stream),
            @caption: FfiConverterOptionalString.INSTANCE.Read(stream),
            @formattedCaption: FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream),
            @source: FfiConverterTypeMediaSource.INSTANCE.Read(stream),
            @info: FfiConverterOptionalTypeVideoInfo.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(VideoMessageContent value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@filename)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@caption)
            + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(value.@formattedCaption)
            + FfiConverterTypeMediaSource.INSTANCE.AllocationSize(value.@source)
            + FfiConverterOptionalTypeVideoInfo.INSTANCE.AllocationSize(value.@info);
    }

    public override void Write(VideoMessageContent value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@filename, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@caption, stream);
        FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(value.@formattedCaption, stream);
        FfiConverterTypeMediaSource.INSTANCE.Write(value.@source, stream);
        FfiConverterOptionalTypeVideoInfo.INSTANCE.Write(value.@info, stream);
    }
}

/// <summary>
/// Properties to create a new virtual Element Call widget.
/// </summary>
/// <param name="element_call_url">
/// The url to the Element Call app including any `/room` path if required.
///
/// E.g. <https://call.element.io>, <https://call.element.dev>, <https://call.element.dev/room>
/// </param>
/// <param name="widget_id">
/// The widget id.
/// </param>
/// <param name="parent_url">
/// The url that is used as the target for the PostMessages sent
/// by the widget (to the client).
///
/// For a web app client this is the client url. In case of using other
/// platforms the client most likely is setup up to listen to
/// postmessages in the same webview the widget is hosted. In this case
/// the `parent_url` is set to the url of the webview with the widget. Be
/// aware that this means that the widget will receive its own postmessage
/// messages. The `matrix-widget-api` (js) ignores those so this works but
/// it might break custom implementations.
///
/// Defaults to `element_call_url` for the non-iframe (dedicated webview)
/// usecase.
/// </param>
/// <param name="hide_header">
/// Whether the branding header of Element call should be hidden.
///
/// Default: `true`
/// </param>
/// <param name="preload">
/// If set, the lobby will be skipped and the widget will join the
/// call on the `io.element.join` action.
///
/// Default: `false`
/// </param>
/// <param name="font_scale">
/// The font scale which will be used inside element call.
///
/// Default: `1`
/// </param>
/// <param name="app_prompt">
/// Whether element call should prompt the user to open in the browser or
/// the app.
///
/// Default: `false`
/// </param>
/// <param name="confine_to_room">
/// Make it not possible to get to the calls list in the webview.
///
/// Default: `true`
/// </param>
/// <param name="font">
/// The font to use, to adapt to the system font.
/// </param>
/// <param name="encryption">
/// The encryption system to use.
///
/// Use `EncryptionSystem::Unencrypted` to disable encryption.
/// </param>
/// <param name="intent">
/// The intent of showing the call.
/// If the user wants to start a call or join an existing one.
/// Controls if the lobby is skipped or not.
/// </param>
/// <param name="hide_screensharing">
/// Do not show the screenshare button.
/// </param>
/// <param name="posthog_user_id">
/// Can be used to pass a PostHog id to element call.
/// </param>
/// <param name="posthog_api_host">
/// The host of the posthog api.
/// Supported since Element Call v0.9.0. Only used by the embedded package.
/// </param>
/// <param name="posthog_api_key">
/// The key for the posthog api.
/// Supported since Element Call v0.9.0. Only used by the embedded package.
/// </param>
/// <param name="rageshake_submit_url">
/// The url to use for submitting rageshakes.
/// Supported since Element Call v0.9.0. Only used by the embedded package.
/// </param>
/// <param name="sentry_dsn">
/// Sentry [DSN](https://docs.sentry.io/concepts/key-terms/dsn-explainer/)
/// Supported since Element Call v0.9.0. Only used by the embedded package.
/// </param>
/// <param name="sentry_environment">
/// Sentry [environment](https://docs.sentry.io/concepts/key-terms/key-terms/)
/// Supported since Element Call v0.9.0. Only used by the embedded package.
/// </param>
internal record VirtualElementCallWidgetOptions(
    /// <summary>
    /// The url to the Element Call app including any `/room` path if required.
    ///
    /// E.g. <https://call.element.io>, <https://call.element.dev>, <https://call.element.dev/room>
    /// </summary>
    string @elementCallUrl,
    /// <summary>
    /// The widget id.
    /// </summary>
    string @widgetId,
    /// <summary>
    /// The url that is used as the target for the PostMessages sent
    /// by the widget (to the client).
    ///
    /// For a web app client this is the client url. In case of using other
    /// platforms the client most likely is setup up to listen to
    /// postmessages in the same webview the widget is hosted. In this case
    /// the `parent_url` is set to the url of the webview with the widget. Be
    /// aware that this means that the widget will receive its own postmessage
    /// messages. The `matrix-widget-api` (js) ignores those so this works but
    /// it might break custom implementations.
    ///
    /// Defaults to `element_call_url` for the non-iframe (dedicated webview)
    /// usecase.
    /// </summary>
    string? @parentUrl,
    /// <summary>
    /// Whether the branding header of Element call should be hidden.
    ///
    /// Default: `true`
    /// </summary>
    bool? @hideHeader,
    /// <summary>
    /// If set, the lobby will be skipped and the widget will join the
    /// call on the `io.element.join` action.
    ///
    /// Default: `false`
    /// </summary>
    bool? @preload,
    /// <summary>
    /// The font scale which will be used inside element call.
    ///
    /// Default: `1`
    /// </summary>
    double? @fontScale,
    /// <summary>
    /// Whether element call should prompt the user to open in the browser or
    /// the app.
    ///
    /// Default: `false`
    /// </summary>
    bool? @appPrompt,
    /// <summary>
    /// Make it not possible to get to the calls list in the webview.
    ///
    /// Default: `true`
    /// </summary>
    bool? @confineToRoom,
    /// <summary>
    /// The font to use, to adapt to the system font.
    /// </summary>
    string? @font,
    /// <summary>
    /// The encryption system to use.
    ///
    /// Use `EncryptionSystem::Unencrypted` to disable encryption.
    /// </summary>
    EncryptionSystem @encryption,
    /// <summary>
    /// The intent of showing the call.
    /// If the user wants to start a call or join an existing one.
    /// Controls if the lobby is skipped or not.
    /// </summary>
    Intent? @intent,
    /// <summary>
    /// Do not show the screenshare button.
    /// </summary>
    bool @hideScreensharing,
    /// <summary>
    /// Can be used to pass a PostHog id to element call.
    /// </summary>
    string? @posthogUserId,
    /// <summary>
    /// The host of the posthog api.
    /// Supported since Element Call v0.9.0. Only used by the embedded package.
    /// </summary>
    string? @posthogApiHost,
    /// <summary>
    /// The key for the posthog api.
    /// Supported since Element Call v0.9.0. Only used by the embedded package.
    /// </summary>
    string? @posthogApiKey,
    /// <summary>
    /// The url to use for submitting rageshakes.
    /// Supported since Element Call v0.9.0. Only used by the embedded package.
    /// </summary>
    string? @rageshakeSubmitUrl,
    /// <summary>
    /// Sentry [DSN](https://docs.sentry.io/concepts/key-terms/dsn-explainer/)
    /// Supported since Element Call v0.9.0. Only used by the embedded package.
    /// </summary>
    string? @sentryDsn,
    /// <summary>
    /// Sentry [environment](https://docs.sentry.io/concepts/key-terms/key-terms/)
    /// Supported since Element Call v0.9.0. Only used by the embedded package.
    /// </summary>
    string? @sentryEnvironment
) { }

class FfiConverterTypeVirtualElementCallWidgetOptions : FfiConverterRustBuffer<VirtualElementCallWidgetOptions>
{
    public static FfiConverterTypeVirtualElementCallWidgetOptions INSTANCE =
        new FfiConverterTypeVirtualElementCallWidgetOptions();

    public override VirtualElementCallWidgetOptions Read(BigEndianStream stream)
    {
        return new VirtualElementCallWidgetOptions(
            @elementCallUrl: FfiConverterString.INSTANCE.Read(stream),
            @widgetId: FfiConverterString.INSTANCE.Read(stream),
            @parentUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @hideHeader: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @preload: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @fontScale: FfiConverterOptionalDouble.INSTANCE.Read(stream),
            @appPrompt: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @confineToRoom: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @font: FfiConverterOptionalString.INSTANCE.Read(stream),
            @encryption: FfiConverterTypeEncryptionSystem.INSTANCE.Read(stream),
            @intent: FfiConverterOptionalTypeIntent.INSTANCE.Read(stream),
            @hideScreensharing: FfiConverterBoolean.INSTANCE.Read(stream),
            @posthogUserId: FfiConverterOptionalString.INSTANCE.Read(stream),
            @posthogApiHost: FfiConverterOptionalString.INSTANCE.Read(stream),
            @posthogApiKey: FfiConverterOptionalString.INSTANCE.Read(stream),
            @rageshakeSubmitUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @sentryDsn: FfiConverterOptionalString.INSTANCE.Read(stream),
            @sentryEnvironment: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(VirtualElementCallWidgetOptions value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@elementCallUrl)
            + FfiConverterString.INSTANCE.AllocationSize(value.@widgetId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@parentUrl)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@hideHeader)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@preload)
            + FfiConverterOptionalDouble.INSTANCE.AllocationSize(value.@fontScale)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@appPrompt)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@confineToRoom)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@font)
            + FfiConverterTypeEncryptionSystem.INSTANCE.AllocationSize(value.@encryption)
            + FfiConverterOptionalTypeIntent.INSTANCE.AllocationSize(value.@intent)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@hideScreensharing)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@posthogUserId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@posthogApiHost)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@posthogApiKey)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@rageshakeSubmitUrl)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@sentryDsn)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@sentryEnvironment);
    }

    public override void Write(VirtualElementCallWidgetOptions value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@elementCallUrl, stream);
        FfiConverterString.INSTANCE.Write(value.@widgetId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@parentUrl, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@hideHeader, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@preload, stream);
        FfiConverterOptionalDouble.INSTANCE.Write(value.@fontScale, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@appPrompt, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@confineToRoom, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@font, stream);
        FfiConverterTypeEncryptionSystem.INSTANCE.Write(value.@encryption, stream);
        FfiConverterOptionalTypeIntent.INSTANCE.Write(value.@intent, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@hideScreensharing, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@posthogUserId, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@posthogApiHost, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@posthogApiKey, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@rageshakeSubmitUrl, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@sentryDsn, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@sentryEnvironment, stream);
    }
}

/// <summary>
/// Capabilities that a widget can request from a client.
/// </summary>
/// <param name="read">
/// Types of the messages that a widget wants to be able to fetch.
/// </param>
/// <param name="send">
/// Types of the messages that a widget wants to be able to send.
/// </param>
/// <param name="requires_client">
/// If this capability is requested by the widget, it can not operate
/// separately from the matrix client.
///
/// This means clients should not offer to open the widget in a separate
/// browser/tab/webview that is not connected to the postmessage widget-api.
/// </param>
/// <param name="update_delayed_event">
/// This allows the widget to ask the client to update delayed events.
/// </param>
/// <param name="send_delayed_event">
/// This allows the widget to send events with a delay.
/// </param>
internal record WidgetCapabilities(
    /// <summary>
    /// Types of the messages that a widget wants to be able to fetch.
    /// </summary>
    List<WidgetEventFilter> @read,
    /// <summary>
    /// Types of the messages that a widget wants to be able to send.
    /// </summary>
    List<WidgetEventFilter> @send,
    /// <summary>
    /// If this capability is requested by the widget, it can not operate
    /// separately from the matrix client.
    ///
    /// This means clients should not offer to open the widget in a separate
    /// browser/tab/webview that is not connected to the postmessage widget-api.
    /// </summary>
    bool @requiresClient,
    /// <summary>
    /// This allows the widget to ask the client to update delayed events.
    /// </summary>
    bool @updateDelayedEvent,
    /// <summary>
    /// This allows the widget to send events with a delay.
    /// </summary>
    bool @sendDelayedEvent
) { }

class FfiConverterTypeWidgetCapabilities : FfiConverterRustBuffer<WidgetCapabilities>
{
    public static FfiConverterTypeWidgetCapabilities INSTANCE = new FfiConverterTypeWidgetCapabilities();

    public override WidgetCapabilities Read(BigEndianStream stream)
    {
        return new WidgetCapabilities(
            @read: FfiConverterSequenceTypeWidgetEventFilter.INSTANCE.Read(stream),
            @send: FfiConverterSequenceTypeWidgetEventFilter.INSTANCE.Read(stream),
            @requiresClient: FfiConverterBoolean.INSTANCE.Read(stream),
            @updateDelayedEvent: FfiConverterBoolean.INSTANCE.Read(stream),
            @sendDelayedEvent: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(WidgetCapabilities value)
    {
        return 0
            + FfiConverterSequenceTypeWidgetEventFilter.INSTANCE.AllocationSize(value.@read)
            + FfiConverterSequenceTypeWidgetEventFilter.INSTANCE.AllocationSize(value.@send)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@requiresClient)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@updateDelayedEvent)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@sendDelayedEvent);
    }

    public override void Write(WidgetCapabilities value, BigEndianStream stream)
    {
        FfiConverterSequenceTypeWidgetEventFilter.INSTANCE.Write(value.@read, stream);
        FfiConverterSequenceTypeWidgetEventFilter.INSTANCE.Write(value.@send, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@requiresClient, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@updateDelayedEvent, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@sendDelayedEvent, stream);
    }
}

internal record WidgetDriverAndHandle(WidgetDriver @driver, WidgetDriverHandle @handle) : IDisposable
{
    public void Dispose()
    {
        FFIObjectUtil.DisposeAll(this.@driver, this.@handle);
    }
}

class FfiConverterTypeWidgetDriverAndHandle : FfiConverterRustBuffer<WidgetDriverAndHandle>
{
    public static FfiConverterTypeWidgetDriverAndHandle INSTANCE = new FfiConverterTypeWidgetDriverAndHandle();

    public override WidgetDriverAndHandle Read(BigEndianStream stream)
    {
        return new WidgetDriverAndHandle(
            @driver: FfiConverterTypeWidgetDriver.INSTANCE.Read(stream),
            @handle: FfiConverterTypeWidgetDriverHandle.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(WidgetDriverAndHandle value)
    {
        return 0
            + FfiConverterTypeWidgetDriver.INSTANCE.AllocationSize(value.@driver)
            + FfiConverterTypeWidgetDriverHandle.INSTANCE.AllocationSize(value.@handle);
    }

    public override void Write(WidgetDriverAndHandle value, BigEndianStream stream)
    {
        FfiConverterTypeWidgetDriver.INSTANCE.Write(value.@driver, stream);
        FfiConverterTypeWidgetDriverHandle.INSTANCE.Write(value.@handle, stream);
    }
}

/// <summary>
/// Information about a widget.
/// </summary>
/// <param name="widget_id">
/// Widget's unique identifier.
/// </param>
/// <param name="init_after_content_load">
/// Whether or not the widget should be initialized on load message
/// (`ContentLoad` message), or upon creation/attaching of the widget to
/// the SDK's state machine that drives the API.
/// </param>
/// <param name="raw_url">
/// This contains the url from the widget state event.
/// In this url placeholders can be used to pass information from the client
/// to the widget. Possible values are: `$widgetId`, `$parentUrl`,
/// `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
///
/// # Examples
///
/// e.g `http://widget.domain?username=$userId`
/// will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
/// </param>
internal record WidgetSettings(
    /// <summary>
    /// Widget's unique identifier.
    /// </summary>
    string @widgetId,
    /// <summary>
    /// Whether or not the widget should be initialized on load message
    /// (`ContentLoad` message), or upon creation/attaching of the widget to
    /// the SDK's state machine that drives the API.
    /// </summary>
    bool @initAfterContentLoad,
    /// <summary>
    /// This contains the url from the widget state event.
    /// In this url placeholders can be used to pass information from the client
    /// to the widget. Possible values are: `$widgetId`, `$parentUrl`,
    /// `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
    ///
    /// # Examples
    ///
    /// e.g `http://widget.domain?username=$userId`
    /// will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
    /// </summary>
    string @rawUrl
) { }

class FfiConverterTypeWidgetSettings : FfiConverterRustBuffer<WidgetSettings>
{
    public static FfiConverterTypeWidgetSettings INSTANCE = new FfiConverterTypeWidgetSettings();

    public override WidgetSettings Read(BigEndianStream stream)
    {
        return new WidgetSettings(
            @widgetId: FfiConverterString.INSTANCE.Read(stream),
            @initAfterContentLoad: FfiConverterBoolean.INSTANCE.Read(stream),
            @rawUrl: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(WidgetSettings value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@widgetId)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@initAfterContentLoad)
            + FfiConverterString.INSTANCE.AllocationSize(value.@rawUrl);
    }

    public override void Write(WidgetSettings value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@widgetId, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@initAfterContentLoad, stream);
        FfiConverterString.INSTANCE.Write(value.@rawUrl, stream);
    }
}

internal record AccountManagementAction
{
    public record Profile : AccountManagementAction { }

    public record SessionsList : AccountManagementAction { }

    public record SessionView(string @deviceId) : AccountManagementAction { }

    public record SessionEnd(string @deviceId) : AccountManagementAction { }

    public record AccountDeactivate : AccountManagementAction { }

    public record CrossSigningReset : AccountManagementAction { }
}

class FfiConverterTypeAccountManagementAction : FfiConverterRustBuffer<AccountManagementAction>
{
    public static FfiConverterRustBuffer<AccountManagementAction> INSTANCE =
        new FfiConverterTypeAccountManagementAction();

    public override AccountManagementAction Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new AccountManagementAction.Profile();
            case 2:
                return new AccountManagementAction.SessionsList();
            case 3:
                return new AccountManagementAction.SessionView(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new AccountManagementAction.SessionEnd(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new AccountManagementAction.AccountDeactivate();
            case 6:
                return new AccountManagementAction.CrossSigningReset();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAccountManagementAction.Read()", value)
                );
        }
    }

    public override int AllocationSize(AccountManagementAction value)
    {
        switch (value)
        {
            case AccountManagementAction.Profile variant_value:
                return 4;
            case AccountManagementAction.SessionsList variant_value:
                return 4;
            case AccountManagementAction.SessionView variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@deviceId);
            case AccountManagementAction.SessionEnd variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@deviceId);
            case AccountManagementAction.AccountDeactivate variant_value:
                return 4;
            case AccountManagementAction.CrossSigningReset variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeAccountManagementAction.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(AccountManagementAction value, BigEndianStream stream)
    {
        switch (value)
        {
            case AccountManagementAction.Profile variant_value:
                stream.WriteInt(1);
                break;
            case AccountManagementAction.SessionsList variant_value:
                stream.WriteInt(2);
                break;
            case AccountManagementAction.SessionView variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@deviceId, stream);
                break;
            case AccountManagementAction.SessionEnd variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@deviceId, stream);
                break;
            case AccountManagementAction.AccountDeactivate variant_value:
                stream.WriteInt(5);
                break;
            case AccountManagementAction.CrossSigningReset variant_value:
                stream.WriteInt(6);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAccountManagementAction.Write()", value)
                );
        }
    }
}

/// <summary>
/// Enum representing the push notification actions for a rule.
/// </summary>
internal record Action
{
    /// <summary>
    /// Causes matching events to generate a notification.
    /// </summary>
    public record Notify : Action { }

    /// <summary>
    /// Sets an entry in the 'tweaks' dictionary sent to the push gateway.
    /// </summary>
    public record SetTweak(Tweak @value) : Action { }
}

class FfiConverterTypeAction : FfiConverterRustBuffer<Action>
{
    public static FfiConverterRustBuffer<Action> INSTANCE = new FfiConverterTypeAction();

    public override Action Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new Action.Notify();
            case 2:
                return new Action.SetTweak(FfiConverterTypeTweak.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAction.Read()", value)
                );
        }
    }

    public override int AllocationSize(Action value)
    {
        switch (value)
        {
            case Action.Notify variant_value:
                return 4;
            case Action.SetTweak variant_value:
                return 4 + FfiConverterTypeTweak.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAction.AllocationSize()", value)
                );
        }
    }

    public override void Write(Action value, BigEndianStream stream)
    {
        switch (value)
        {
            case Action.Notify variant_value:
                stream.WriteInt(1);
                break;
            case Action.SetTweak variant_value:
                stream.WriteInt(2);
                FfiConverterTypeTweak.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAction.Write()", value)
                );
        }
    }
}

/// <summary>
/// An allow rule which defines a condition that allows joining a room.
/// </summary>
internal record AllowRule
{
    /// <summary>
    /// Only a member of the `room_id` Room can join the one this rule is used
    /// in.
    /// </summary>
    public record RoomMembership(string @roomId) : AllowRule { }

    /// <summary>
    /// A custom allow rule implementation, containing its JSON representation
    /// as a `String`.
    /// </summary>
    public record Custom(string @json) : AllowRule { }
}

class FfiConverterTypeAllowRule : FfiConverterRustBuffer<AllowRule>
{
    public static FfiConverterRustBuffer<AllowRule> INSTANCE = new FfiConverterTypeAllowRule();

    public override AllowRule Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new AllowRule.RoomMembership(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new AllowRule.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAllowRule.Read()", value)
                );
        }
    }

    public override int AllocationSize(AllowRule value)
    {
        switch (value)
        {
            case AllowRule.RoomMembership variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomId);
            case AllowRule.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@json);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAllowRule.AllocationSize()", value)
                );
        }
    }

    public override void Write(AllowRule value, BigEndianStream stream)
    {
        switch (value)
        {
            case AllowRule.RoomMembership variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@roomId, stream);
                break;
            case AllowRule.Custom variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@json, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAllowRule.Write()", value)
                );
        }
    }
}

internal enum AssetType : int
{
    Sender,
    Pin,
}

class FfiConverterTypeAssetType : FfiConverterRustBuffer<AssetType>
{
    public static FfiConverterTypeAssetType INSTANCE = new FfiConverterTypeAssetType();

    public override AssetType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(AssetType), value))
        {
            return (AssetType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeAssetType.Read()", value)
            );
        }
    }

    public override int AllocationSize(AssetType value)
    {
        return 4;
    }

    public override void Write(AssetType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record AuthData
{
    /// <summary>
    /// Password-based authentication (`m.login.password`).
    /// </summary>
    public record Password(AuthDataPasswordDetails @passwordDetails) : AuthData { }
}

class FfiConverterTypeAuthData : FfiConverterRustBuffer<AuthData>
{
    public static FfiConverterRustBuffer<AuthData> INSTANCE = new FfiConverterTypeAuthData();

    public override AuthData Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new AuthData.Password(FfiConverterTypeAuthDataPasswordDetails.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAuthData.Read()", value)
                );
        }
    }

    public override int AllocationSize(AuthData value)
    {
        switch (value)
        {
            case AuthData.Password variant_value:
                return 4
                    + FfiConverterTypeAuthDataPasswordDetails.INSTANCE.AllocationSize(variant_value.@passwordDetails);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAuthData.AllocationSize()", value)
                );
        }
    }

    public override void Write(AuthData value, BigEndianStream stream)
    {
        switch (value)
        {
            case AuthData.Password variant_value:
                stream.WriteInt(1);
                FfiConverterTypeAuthDataPasswordDetails.INSTANCE.Write(variant_value.@passwordDetails, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeAuthData.Write()", value)
                );
        }
    }
}

internal enum BackupState : int
{
    Unknown,
    Creating,
    Enabling,
    Resuming,
    Enabled,
    Downloading,
    Disabling,
}

class FfiConverterTypeBackupState : FfiConverterRustBuffer<BackupState>
{
    public static FfiConverterTypeBackupState INSTANCE = new FfiConverterTypeBackupState();

    public override BackupState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(BackupState), value))
        {
            return (BackupState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeBackupState.Read()", value)
            );
        }
    }

    public override int AllocationSize(BackupState value)
    {
        return 4;
    }

    public override void Write(BackupState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record BackupUploadState
{
    public record Waiting : BackupUploadState { }

    public record Uploading(uint @backedUpCount, uint @totalCount) : BackupUploadState { }

    public record Error : BackupUploadState { }

    public record Done : BackupUploadState { }
}

class FfiConverterTypeBackupUploadState : FfiConverterRustBuffer<BackupUploadState>
{
    public static FfiConverterRustBuffer<BackupUploadState> INSTANCE = new FfiConverterTypeBackupUploadState();

    public override BackupUploadState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new BackupUploadState.Waiting();
            case 2:
                return new BackupUploadState.Uploading(
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterUInt32.INSTANCE.Read(stream)
                );
            case 3:
                return new BackupUploadState.Error();
            case 4:
                return new BackupUploadState.Done();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeBackupUploadState.Read()", value)
                );
        }
    }

    public override int AllocationSize(BackupUploadState value)
    {
        switch (value)
        {
            case BackupUploadState.Waiting variant_value:
                return 4;
            case BackupUploadState.Uploading variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@backedUpCount)
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@totalCount);
            case BackupUploadState.Error variant_value:
                return 4;
            case BackupUploadState.Done variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeBackupUploadState.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(BackupUploadState value, BigEndianStream stream)
    {
        switch (value)
        {
            case BackupUploadState.Waiting variant_value:
                stream.WriteInt(1);
                break;
            case BackupUploadState.Uploading variant_value:
                stream.WriteInt(2);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@backedUpCount, stream);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@totalCount, stream);
                break;
            case BackupUploadState.Error variant_value:
                stream.WriteInt(3);
                break;
            case BackupUploadState.Done variant_value:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeBackupUploadState.Write()", value)
                );
        }
    }
}

internal class ClientBuildException : UniffiException
{
    ClientBuildException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class InvalidServerName : ClientBuildException
    {
        public InvalidServerName(string message)
            : base(message) { }
    }

    public class ServerUnreachable : ClientBuildException
    {
        public ServerUnreachable(string message)
            : base(message) { }
    }

    public class WellKnownLookupFailed : ClientBuildException
    {
        public WellKnownLookupFailed(string message)
            : base(message) { }
    }

    public class WellKnownDeserializationException : ClientBuildException
    {
        public WellKnownDeserializationException(string message)
            : base(message) { }
    }

    public class SlidingSync : ClientBuildException
    {
        public SlidingSync(string message)
            : base(message) { }
    }

    public class SlidingSyncVersion : ClientBuildException
    {
        public SlidingSyncVersion(string message)
            : base(message) { }
    }

    public class Sdk : ClientBuildException
    {
        public Sdk(string message)
            : base(message) { }
    }

    public class EventCache : ClientBuildException
    {
        public EventCache(string message)
            : base(message) { }
    }

    public class Generic : ClientBuildException
    {
        public Generic(string message)
            : base(message) { }
    }
}

class FfiConverterTypeClientBuildError
    : FfiConverterRustBuffer<ClientBuildException>,
        CallStatusErrorHandler<ClientBuildException>
{
    public static FfiConverterTypeClientBuildError INSTANCE = new FfiConverterTypeClientBuildError();

    public override ClientBuildException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ClientBuildException.InvalidServerName(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new ClientBuildException.ServerUnreachable(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new ClientBuildException.WellKnownLookupFailed(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new ClientBuildException.WellKnownDeserializationException(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 5:
                return new ClientBuildException.SlidingSync(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new ClientBuildException.SlidingSyncVersion(FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new ClientBuildException.Sdk(FfiConverterString.INSTANCE.Read(stream));
            case 8:
                return new ClientBuildException.EventCache(FfiConverterString.INSTANCE.Read(stream));
            case 9:
                return new ClientBuildException.Generic(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeClientBuildError.Read()", value)
                );
        }
    }

    public override int AllocationSize(ClientBuildException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(ClientBuildException value, BigEndianStream stream)
    {
        switch (value)
        {
            case ClientBuildException.InvalidServerName:
                stream.WriteInt(1);
                break;
            case ClientBuildException.ServerUnreachable:
                stream.WriteInt(2);
                break;
            case ClientBuildException.WellKnownLookupFailed:
                stream.WriteInt(3);
                break;
            case ClientBuildException.WellKnownDeserializationException:
                stream.WriteInt(4);
                break;
            case ClientBuildException.SlidingSync:
                stream.WriteInt(5);
                break;
            case ClientBuildException.SlidingSyncVersion:
                stream.WriteInt(6);
                break;
            case ClientBuildException.Sdk:
                stream.WriteInt(7);
                break;
            case ClientBuildException.EventCache:
                stream.WriteInt(8);
                break;
            case ClientBuildException.Generic:
                stream.WriteInt(9);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeClientBuildError.Write()", value)
                );
        }
    }
}

internal class ClientException : UniffiException
{
    ClientException()
        : base() { }

    ClientException(String @Message)
        : base(@Message) { }

    // Each variant is a nested class

    public class Generic : ClientException
    {
        // Members
        public string @msg;

        // Constructor
        public Generic(string @msg)
            : base("@msg" + "=" + @msg)
        {
            this.@msg = @msg;
        }
    }

    public class MatrixApi : ClientException
    {
        // Members
        public ErrorKind @kind;
        public string @code;
        public string @msg;

        // Constructor
        public MatrixApi(ErrorKind @kind, string @code, string @msg)
            : base("@kind" + "=" + @kind + ", " + "@code" + "=" + @code + ", " + "@msg" + "=" + @msg)
        {
            this.@kind = @kind;

            this.@code = @code;

            this.@msg = @msg;
        }
    }
}

class FfiConverterTypeClientError : FfiConverterRustBuffer<ClientException>, CallStatusErrorHandler<ClientException>
{
    public static FfiConverterTypeClientError INSTANCE = new FfiConverterTypeClientError();

    public override ClientException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ClientException.Generic(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new ClientException.MatrixApi(
                    FfiConverterTypeErrorKind.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeClientError.Read()", value)
                );
        }
    }

    public override int AllocationSize(ClientException value)
    {
        switch (value)
        {
            case ClientException.Generic variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);

            case ClientException.MatrixApi variant_value:
                return 4
                    + FfiConverterTypeErrorKind.INSTANCE.AllocationSize(variant_value.@kind)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@code)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeClientError.AllocationSize()", value)
                );
        }
    }

    public override void Write(ClientException value, BigEndianStream stream)
    {
        switch (value)
        {
            case ClientException.Generic variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                break;
            case ClientException.MatrixApi variant_value:
                stream.WriteInt(2);
                FfiConverterTypeErrorKind.INSTANCE.Write(variant_value.@kind, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@code, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeClientError.Write()", value)
                );
        }
    }
}

internal enum ComparisonOperator : int
{
    /// <summary>
    /// Equals
    /// </summary>
    Eq,

    /// <summary>
    /// Less than
    /// </summary>
    Lt,

    /// <summary>
    /// Greater than
    /// </summary>
    Gt,

    /// <summary>
    /// Greater or equal
    /// </summary>
    Ge,

    /// <summary>
    /// Less or equal
    /// </summary>
    Le,
}

class FfiConverterTypeComparisonOperator : FfiConverterRustBuffer<ComparisonOperator>
{
    public static FfiConverterTypeComparisonOperator INSTANCE = new FfiConverterTypeComparisonOperator();

    public override ComparisonOperator Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(ComparisonOperator), value))
        {
            return (ComparisonOperator)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeComparisonOperator.Read()", value)
            );
        }
    }

    public override int AllocationSize(ComparisonOperator value)
    {
        return 4;
    }

    public override void Write(ComparisonOperator value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// The type of draft of the composer.
/// </summary>
internal record ComposerDraftType
{
    /// <summary>
    /// The draft is a new message.
    /// </summary>
    public record NewMessage : ComposerDraftType { }

    /// <summary>
    /// The draft is a reply to an event.
    /// </summary>
    public record Reply(string @eventId) : ComposerDraftType { }

    /// <summary>
    /// The draft is an edit of an event.
    /// </summary>
    public record Edit(string @eventId) : ComposerDraftType { }
}

class FfiConverterTypeComposerDraftType : FfiConverterRustBuffer<ComposerDraftType>
{
    public static FfiConverterRustBuffer<ComposerDraftType> INSTANCE = new FfiConverterTypeComposerDraftType();

    public override ComposerDraftType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ComposerDraftType.NewMessage();
            case 2:
                return new ComposerDraftType.Reply(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new ComposerDraftType.Edit(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeComposerDraftType.Read()", value)
                );
        }
    }

    public override int AllocationSize(ComposerDraftType value)
    {
        switch (value)
        {
            case ComposerDraftType.NewMessage variant_value:
                return 4;
            case ComposerDraftType.Reply variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);
            case ComposerDraftType.Edit variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeComposerDraftType.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(ComposerDraftType value, BigEndianStream stream)
    {
        switch (value)
        {
            case ComposerDraftType.NewMessage variant_value:
                stream.WriteInt(1);
                break;
            case ComposerDraftType.Reply variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            case ComposerDraftType.Edit variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeComposerDraftType.Write()", value)
                );
        }
    }
}

internal record CrossSigningResetAuthType
{
    /// <summary>
    /// The homeserver requires user-interactive authentication.
    /// </summary>
    public record Uiaa : CrossSigningResetAuthType { }

    public record Oidc(OidcCrossSigningResetInfo @info) : CrossSigningResetAuthType { }
}

class FfiConverterTypeCrossSigningResetAuthType : FfiConverterRustBuffer<CrossSigningResetAuthType>
{
    public static FfiConverterRustBuffer<CrossSigningResetAuthType> INSTANCE =
        new FfiConverterTypeCrossSigningResetAuthType();

    public override CrossSigningResetAuthType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new CrossSigningResetAuthType.Uiaa();
            case 2:
                return new CrossSigningResetAuthType.Oidc(
                    FfiConverterTypeOidcCrossSigningResetInfo.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeCrossSigningResetAuthType.Read()", value)
                );
        }
    }

    public override int AllocationSize(CrossSigningResetAuthType value)
    {
        switch (value)
        {
            case CrossSigningResetAuthType.Uiaa variant_value:
                return 4;
            case CrossSigningResetAuthType.Oidc variant_value:
                return 4 + FfiConverterTypeOidcCrossSigningResetInfo.INSTANCE.AllocationSize(variant_value.@info);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeCrossSigningResetAuthType.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(CrossSigningResetAuthType value, BigEndianStream stream)
    {
        switch (value)
        {
            case CrossSigningResetAuthType.Uiaa variant_value:
                stream.WriteInt(1);
                break;
            case CrossSigningResetAuthType.Oidc variant_value:
                stream.WriteInt(2);
                FfiConverterTypeOidcCrossSigningResetInfo.INSTANCE.Write(variant_value.@info, stream);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeCrossSigningResetAuthType.Write()",
                        value
                    )
                );
        }
    }
}

/// <summary>
/// Changes how date dividers get inserted, either in between each day or in
/// between each month
/// </summary>
internal enum DateDividerMode : int
{
    Daily,
    Monthly,
}

class FfiConverterTypeDateDividerMode : FfiConverterRustBuffer<DateDividerMode>
{
    public static FfiConverterTypeDateDividerMode INSTANCE = new FfiConverterTypeDateDividerMode();

    public override DateDividerMode Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(DateDividerMode), value))
        {
            return (DateDividerMode)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeDateDividerMode.Read()", value)
            );
        }
    }

    public override int AllocationSize(DateDividerMode value)
    {
        return 4;
    }

    public override void Write(DateDividerMode value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record EditedContent : IDisposable
{
    public record RoomMessage(RoomMessageEventContentWithoutRelation @content) : EditedContent { }

    public record MediaCaption(string? @caption, FormattedBody? @formattedCaption, Mentions? @mentions)
        : EditedContent { }

    public record PollStart(PollData @pollData) : EditedContent { }

    public void Dispose()
    {
        switch (this)
        {
            case EditedContent.RoomMessage variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case EditedContent.MediaCaption variant_value:

                FFIObjectUtil.DisposeAll(
                    variant_value.@caption,
                    variant_value.@formattedCaption,
                    variant_value.@mentions
                );
                break;
            case EditedContent.PollStart variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@pollData);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in EditedContent.Dispose()", this));
        }
    }
}

class FfiConverterTypeEditedContent : FfiConverterRustBuffer<EditedContent>
{
    public static FfiConverterRustBuffer<EditedContent> INSTANCE = new FfiConverterTypeEditedContent();

    public override EditedContent Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new EditedContent.RoomMessage(
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Read(stream)
                );
            case 2:
                return new EditedContent.MediaCaption(
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeFormattedBody.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeMentions.INSTANCE.Read(stream)
                );
            case 3:
                return new EditedContent.PollStart(FfiConverterTypePollData.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEditedContent.Read()", value)
                );
        }
    }

    public override int AllocationSize(EditedContent value)
    {
        switch (value)
        {
            case EditedContent.RoomMessage variant_value:
                return 4
                    + FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.AllocationSize(
                        variant_value.@content
                    );
            case EditedContent.MediaCaption variant_value:
                return 4
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@caption)
                    + FfiConverterOptionalTypeFormattedBody.INSTANCE.AllocationSize(variant_value.@formattedCaption)
                    + FfiConverterOptionalTypeMentions.INSTANCE.AllocationSize(variant_value.@mentions);
            case EditedContent.PollStart variant_value:
                return 4 + FfiConverterTypePollData.INSTANCE.AllocationSize(variant_value.@pollData);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEditedContent.AllocationSize()", value)
                );
        }
    }

    public override void Write(EditedContent value, BigEndianStream stream)
    {
        switch (value)
        {
            case EditedContent.RoomMessage variant_value:
                stream.WriteInt(1);
                FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Write(variant_value.@content, stream);
                break;
            case EditedContent.MediaCaption variant_value:
                stream.WriteInt(2);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@caption, stream);
                FfiConverterOptionalTypeFormattedBody.INSTANCE.Write(variant_value.@formattedCaption, stream);
                FfiConverterOptionalTypeMentions.INSTANCE.Write(variant_value.@mentions, stream);
                break;
            case EditedContent.PollStart variant_value:
                stream.WriteInt(3);
                FfiConverterTypePollData.INSTANCE.Write(variant_value.@pollData, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEditedContent.Write()", value)
                );
        }
    }
}

internal record EnableRecoveryProgress
{
    public record Starting : EnableRecoveryProgress { }

    public record CreatingBackup : EnableRecoveryProgress { }

    public record CreatingRecoveryKey : EnableRecoveryProgress { }

    public record BackingUp(uint @backedUpCount, uint @totalCount) : EnableRecoveryProgress { }

    public record RoomKeyUploadError : EnableRecoveryProgress { }

    public record Done(string @recoveryKey) : EnableRecoveryProgress { }
}

class FfiConverterTypeEnableRecoveryProgress : FfiConverterRustBuffer<EnableRecoveryProgress>
{
    public static FfiConverterRustBuffer<EnableRecoveryProgress> INSTANCE =
        new FfiConverterTypeEnableRecoveryProgress();

    public override EnableRecoveryProgress Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new EnableRecoveryProgress.Starting();
            case 2:
                return new EnableRecoveryProgress.CreatingBackup();
            case 3:
                return new EnableRecoveryProgress.CreatingRecoveryKey();
            case 4:
                return new EnableRecoveryProgress.BackingUp(
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterUInt32.INSTANCE.Read(stream)
                );
            case 5:
                return new EnableRecoveryProgress.RoomKeyUploadError();
            case 6:
                return new EnableRecoveryProgress.Done(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEnableRecoveryProgress.Read()", value)
                );
        }
    }

    public override int AllocationSize(EnableRecoveryProgress value)
    {
        switch (value)
        {
            case EnableRecoveryProgress.Starting variant_value:
                return 4;
            case EnableRecoveryProgress.CreatingBackup variant_value:
                return 4;
            case EnableRecoveryProgress.CreatingRecoveryKey variant_value:
                return 4;
            case EnableRecoveryProgress.BackingUp variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@backedUpCount)
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@totalCount);
            case EnableRecoveryProgress.RoomKeyUploadError variant_value:
                return 4;
            case EnableRecoveryProgress.Done variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@recoveryKey);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeEnableRecoveryProgress.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(EnableRecoveryProgress value, BigEndianStream stream)
    {
        switch (value)
        {
            case EnableRecoveryProgress.Starting variant_value:
                stream.WriteInt(1);
                break;
            case EnableRecoveryProgress.CreatingBackup variant_value:
                stream.WriteInt(2);
                break;
            case EnableRecoveryProgress.CreatingRecoveryKey variant_value:
                stream.WriteInt(3);
                break;
            case EnableRecoveryProgress.BackingUp variant_value:
                stream.WriteInt(4);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@backedUpCount, stream);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@totalCount, stream);
                break;
            case EnableRecoveryProgress.RoomKeyUploadError variant_value:
                stream.WriteInt(5);
                break;
            case EnableRecoveryProgress.Done variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@recoveryKey, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEnableRecoveryProgress.Write()", value)
                );
        }
    }
}

internal record EncryptedMessage
{
    public record OlmV1Curve25519AesSha2(string @senderKey) : EncryptedMessage { }

    public record MegolmV1AesSha2(string @sessionId, UtdCause @cause) : EncryptedMessage { }

    public record Unknown : EncryptedMessage { }
}

class FfiConverterTypeEncryptedMessage : FfiConverterRustBuffer<EncryptedMessage>
{
    public static FfiConverterRustBuffer<EncryptedMessage> INSTANCE = new FfiConverterTypeEncryptedMessage();

    public override EncryptedMessage Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new EncryptedMessage.OlmV1Curve25519AesSha2(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new EncryptedMessage.MegolmV1AesSha2(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeUtdCause.INSTANCE.Read(stream)
                );
            case 3:
                return new EncryptedMessage.Unknown();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEncryptedMessage.Read()", value)
                );
        }
    }

    public override int AllocationSize(EncryptedMessage value)
    {
        switch (value)
        {
            case EncryptedMessage.OlmV1Curve25519AesSha2 variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@senderKey);
            case EncryptedMessage.MegolmV1AesSha2 variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@sessionId)
                    + FfiConverterTypeUtdCause.INSTANCE.AllocationSize(variant_value.@cause);
            case EncryptedMessage.Unknown variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeEncryptedMessage.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(EncryptedMessage value, BigEndianStream stream)
    {
        switch (value)
        {
            case EncryptedMessage.OlmV1Curve25519AesSha2 variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@senderKey, stream);
                break;
            case EncryptedMessage.MegolmV1AesSha2 variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@sessionId, stream);
                FfiConverterTypeUtdCause.INSTANCE.Write(variant_value.@cause, stream);
                break;
            case EncryptedMessage.Unknown variant_value:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEncryptedMessage.Write()", value)
                );
        }
    }
}

/// <summary>
/// Defines if a call is encrypted and which encryption system should be used.
///
/// This controls the url parameters: `perParticipantE2EE`, `password`.
/// </summary>
internal record EncryptionSystem
{
    /// <summary>
    /// Equivalent to the element call url parameter: `enableE2EE=false`
    /// </summary>
    public record Unencrypted : EncryptionSystem { }

    /// <summary>
    /// Equivalent to the element call url parameter:
    /// `perParticipantE2EE=true`
    /// </summary>
    public record PerParticipantKeys : EncryptionSystem { }

    /// <summary>
    /// Equivalent to the element call url parameter:
    /// `password={secret}`
    /// </summary>
    public record SharedSecret(string @secret) : EncryptionSystem { }
}

class FfiConverterTypeEncryptionSystem : FfiConverterRustBuffer<EncryptionSystem>
{
    public static FfiConverterRustBuffer<EncryptionSystem> INSTANCE = new FfiConverterTypeEncryptionSystem();

    public override EncryptionSystem Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new EncryptionSystem.Unencrypted();
            case 2:
                return new EncryptionSystem.PerParticipantKeys();
            case 3:
                return new EncryptionSystem.SharedSecret(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEncryptionSystem.Read()", value)
                );
        }
    }

    public override int AllocationSize(EncryptionSystem value)
    {
        switch (value)
        {
            case EncryptionSystem.Unencrypted variant_value:
                return 4;
            case EncryptionSystem.PerParticipantKeys variant_value:
                return 4;
            case EncryptionSystem.SharedSecret variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@secret);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeEncryptionSystem.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(EncryptionSystem value, BigEndianStream stream)
    {
        switch (value)
        {
            case EncryptionSystem.Unencrypted variant_value:
                stream.WriteInt(1);
                break;
            case EncryptionSystem.PerParticipantKeys variant_value:
                stream.WriteInt(2);
                break;
            case EncryptionSystem.SharedSecret variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@secret, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEncryptionSystem.Write()", value)
                );
        }
    }
}

internal record ErrorKind
{
    /// <summary>
    /// `M_BAD_ALIAS`
    ///
    /// One or more [room aliases] within the `m.room.canonical_alias` event do
    /// not point to the room ID for which the state event is to be sent to.
    ///
    /// [room aliases]: https://spec.matrix.org/latest/client-server-api/#room-aliases
    /// </summary>
    public record BadAlias : ErrorKind { }

    /// <summary>
    /// `M_BAD_JSON`
    ///
    /// The request contained valid JSON, but it was malformed in some way, e.g.
    /// missing required keys, invalid values for keys.
    /// </summary>
    public record BadJson : ErrorKind { }

    /// <summary>
    /// `M_BAD_STATE`
    ///
    /// The state change requested cannot be performed, such as attempting to
    /// unban a user who is not banned.
    /// </summary>
    public record BadState : ErrorKind { }

    /// <summary>
    /// `M_BAD_STATUS`
    ///
    /// The application service returned a bad status.
    /// </summary>
    public record BadStatus(ushort? @status, string? @body) : ErrorKind { }

    /// <summary>
    /// `M_CANNOT_LEAVE_SERVER_NOTICE_ROOM`
    ///
    /// The user is unable to reject an invite to join the [server notices]
    /// room.
    ///
    /// [server notices]: https://spec.matrix.org/latest/client-server-api/#server-notices
    /// </summary>
    public record CannotLeaveServerNoticeRoom : ErrorKind { }

    /// <summary>
    /// `M_CANNOT_OVERWRITE_MEDIA`
    ///
    /// The [`create_content_async`] endpoint was called with a media ID that
    /// already has content.
    ///
    /// [`create_content_async`]: crate::media::create_content_async
    /// </summary>
    public record CannotOverwriteMedia : ErrorKind { }

    /// <summary>
    /// `M_CAPTCHA_INVALID`
    ///
    /// The Captcha provided did not match what was expected.
    /// </summary>
    public record CaptchaInvalid : ErrorKind { }

    /// <summary>
    /// `M_CAPTCHA_NEEDED`
    ///
    /// A Captcha is required to complete the request.
    /// </summary>
    public record CaptchaNeeded : ErrorKind { }

    /// <summary>
    /// `M_CONNECTION_FAILED`
    ///
    /// The connection to the application service failed.
    /// </summary>
    public record ConnectionFailed : ErrorKind { }

    /// <summary>
    /// `M_CONNECTION_TIMEOUT`
    ///
    /// The connection to the application service timed out.
    /// </summary>
    public record ConnectionTimeout : ErrorKind { }

    /// <summary>
    /// `M_DUPLICATE_ANNOTATION`
    ///
    /// The request is an attempt to send a [duplicate annotation].
    ///
    /// [duplicate annotation]: https://spec.matrix.org/latest/client-server-api/#avoiding-duplicate-annotations
    /// </summary>
    public record DuplicateAnnotation : ErrorKind { }

    /// <summary>
    /// `M_EXCLUSIVE`
    ///
    /// The resource being requested is reserved by an application service, or
    /// the application service making the request has not created the
    /// resource.
    /// </summary>
    public record Exclusive : ErrorKind { }

    /// <summary>
    /// `M_FORBIDDEN`
    ///
    /// Forbidden access, e.g. joining a room without permission, failed login.
    /// </summary>
    public record Forbidden : ErrorKind { }

    /// <summary>
    /// `M_GUEST_ACCESS_FORBIDDEN`
    ///
    /// The room or resource does not permit [guests] to access it.
    ///
    /// [guests]: https://spec.matrix.org/latest/client-server-api/#guest-access
    /// </summary>
    public record GuestAccessForbidden : ErrorKind { }

    /// <summary>
    /// `M_INCOMPATIBLE_ROOM_VERSION`
    ///
    /// The client attempted to join a room that has a version the server does
    /// not support.
    /// </summary>
    public record IncompatibleRoomVersion(string @roomVersion) : ErrorKind { }

    /// <summary>
    /// `M_INVALID_PARAM`
    ///
    /// A parameter that was specified has the wrong value. For example, the
    /// server expected an integer and instead received a string.
    /// </summary>
    public record InvalidParam : ErrorKind { }

    /// <summary>
    /// `M_INVALID_ROOM_STATE`
    ///
    /// The initial state implied by the parameters to the [`create_room`]
    /// request is invalid, e.g. the user's `power_level` is set below that
    /// necessary to set the room name.
    ///
    /// [`create_room`]: crate::room::create_room
    /// </summary>
    public record InvalidRoomState : ErrorKind { }

    /// <summary>
    /// `M_INVALID_USERNAME`
    ///
    /// The desired user name is not valid.
    /// </summary>
    public record InvalidUsername : ErrorKind { }

    /// <summary>
    /// `M_LIMIT_EXCEEDED`
    ///
    /// The request has been refused due to [rate limiting]: too many requests
    /// have been sent in a short period of time.
    ///
    /// [rate limiting]: https://spec.matrix.org/latest/client-server-api/#rate-limiting
    /// </summary>
    public record LimitExceeded(ulong? @retryAfterMs) : ErrorKind { }

    /// <summary>
    /// `M_MISSING_PARAM`
    ///
    /// A required parameter was missing from the request.
    /// </summary>
    public record MissingParam : ErrorKind { }

    /// <summary>
    /// `M_MISSING_TOKEN`
    ///
    /// No [access token] was specified for the request, but one is required.
    ///
    /// [access token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
    /// </summary>
    public record MissingToken : ErrorKind { }

    /// <summary>
    /// `M_NOT_FOUND`
    ///
    /// No resource was found for this request.
    /// </summary>
    public record NotFound : ErrorKind { }

    /// <summary>
    /// `M_NOT_JSON`
    ///
    /// The request did not contain valid JSON.
    /// </summary>
    public record NotJson : ErrorKind { }

    /// <summary>
    /// `M_NOT_YET_UPLOADED`
    ///
    /// An `mxc:` URI generated with the [`create_mxc_uri`] endpoint was used
    /// and the content is not yet available.
    ///
    /// [`create_mxc_uri`]: crate::media::create_mxc_uri
    /// </summary>
    public record NotYetUploaded : ErrorKind { }

    /// <summary>
    /// `M_RESOURCE_LIMIT_EXCEEDED`
    ///
    /// The request cannot be completed because the homeserver has reached a
    /// resource limit imposed on it. For example, a homeserver held in a
    /// shared hosting environment may reach a resource limit if it starts
    /// using too much memory or disk space.
    /// </summary>
    public record ResourceLimitExceeded(string @adminContact) : ErrorKind { }

    /// <summary>
    /// `M_ROOM_IN_USE`
    ///
    /// The [room alias] specified in the [`create_room`] request is already
    /// taken.
    ///
    /// [`create_room`]: crate::room::create_room
    /// [room alias]: https://spec.matrix.org/latest/client-server-api/#room-aliases
    /// </summary>
    public record RoomInUse : ErrorKind { }

    /// <summary>
    /// `M_SERVER_NOT_TRUSTED`
    ///
    /// The client's request used a third-party server, e.g. identity server,
    /// that this server does not trust.
    /// </summary>
    public record ServerNotTrusted : ErrorKind { }

    /// <summary>
    /// `M_THREEPID_AUTH_FAILED`
    ///
    /// Authentication could not be performed on the [third-party identifier].
    ///
    /// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
    /// </summary>
    public record ThreepidAuthFailed : ErrorKind { }

    /// <summary>
    /// `M_THREEPID_DENIED`
    ///
    /// The server does not permit this [third-party identifier]. This may
    /// happen if the server only permits, for example, email addresses from
    /// a particular domain.
    ///
    /// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
    /// </summary>
    public record ThreepidDenied : ErrorKind { }

    /// <summary>
    /// `M_THREEPID_IN_USE`
    ///
    /// The [third-party identifier] is already in use by another user.
    ///
    /// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
    /// </summary>
    public record ThreepidInUse : ErrorKind { }

    /// <summary>
    /// `M_THREEPID_MEDIUM_NOT_SUPPORTED`
    ///
    /// The homeserver does not support adding a [third-party identifier] of the
    /// given medium.
    ///
    /// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
    /// </summary>
    public record ThreepidMediumNotSupported : ErrorKind { }

    /// <summary>
    /// `M_THREEPID_NOT_FOUND`
    ///
    /// No account matching the given [third-party identifier] could be found.
    ///
    /// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
    /// </summary>
    public record ThreepidNotFound : ErrorKind { }

    /// <summary>
    /// `M_TOO_LARGE`
    ///
    /// The request or entity was too large.
    /// </summary>
    public record TooLarge : ErrorKind { }

    /// <summary>
    /// `M_UNABLE_TO_AUTHORISE_JOIN`
    ///
    /// The room is [restricted] and none of the conditions can be validated by
    /// the homeserver. This can happen if the homeserver does not know
    /// about any of the rooms listed as conditions, for example.
    ///
    /// [restricted]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
    /// </summary>
    public record UnableToAuthorizeJoin : ErrorKind { }

    /// <summary>
    /// `M_UNABLE_TO_GRANT_JOIN`
    ///
    /// A different server should be attempted for the join. This is typically
    /// because the resident server can see that the joining user satisfies
    /// one or more conditions, such as in the case of [restricted rooms],
    /// but the resident server would be unable to meet the authorization
    /// rules.
    ///
    /// [restricted rooms]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
    /// </summary>
    public record UnableToGrantJoin : ErrorKind { }

    /// <summary>
    /// `M_UNAUTHORIZED`
    ///
    /// The request was not correctly authorized. Usually due to login failures.
    /// </summary>
    public record Unauthorized : ErrorKind { }

    /// <summary>
    /// `M_UNKNOWN`
    ///
    /// An unknown error has occurred.
    /// </summary>
    public record Unknown : ErrorKind { }

    /// <summary>
    /// `M_UNKNOWN_TOKEN`
    ///
    /// The [access or refresh token] specified was not recognized.
    ///
    /// [access or refresh token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
    /// </summary>
    public record UnknownToken(bool @softLogout) : ErrorKind { }

    /// <summary>
    /// `M_UNRECOGNIZED`
    ///
    /// The server did not understand the request.
    ///
    /// This is expected to be returned with a 404 HTTP status code if the
    /// endpoint is not implemented or a 405 HTTP status code if the
    /// endpoint is implemented, but the incorrect HTTP method is used.
    /// </summary>
    public record Unrecognized : ErrorKind { }

    /// <summary>
    /// `M_UNSUPPORTED_ROOM_VERSION`
    ///
    /// The request to [`create_room`] used a room version that the server does
    /// not support.
    ///
    /// [`create_room`]: crate::room::create_room
    /// </summary>
    public record UnsupportedRoomVersion : ErrorKind { }

    /// <summary>
    /// `M_URL_NOT_SET`
    ///
    /// The application service doesn't have a URL configured.
    /// </summary>
    public record UrlNotSet : ErrorKind { }

    /// <summary>
    /// `M_USER_DEACTIVATED`
    ///
    /// The user ID associated with the request has been deactivated.
    /// </summary>
    public record UserDeactivated : ErrorKind { }

    /// <summary>
    /// `M_USER_IN_USE`
    ///
    /// The desired user ID is already taken.
    /// </summary>
    public record UserInUse : ErrorKind { }

    /// <summary>
    /// `M_USER_LOCKED`
    ///
    /// The account has been [locked] and cannot be used at this time.
    ///
    /// [locked]: https://spec.matrix.org/latest/client-server-api/#account-locking
    /// </summary>
    public record UserLocked : ErrorKind { }

    /// <summary>
    /// `M_USER_SUSPENDED`
    ///
    /// The account has been [suspended] and can only be used for limited
    /// actions at this time.
    ///
    /// [suspended]: https://spec.matrix.org/latest/client-server-api/#account-suspension
    /// </summary>
    public record UserSuspended : ErrorKind { }

    /// <summary>
    /// `M_WEAK_PASSWORD`
    ///
    /// The password was [rejected] by the server for being too weak.
    ///
    /// [rejected]: https://spec.matrix.org/latest/client-server-api/#notes-on-password-management
    /// </summary>
    public record WeakPassword : ErrorKind { }

    /// <summary>
    /// `M_WRONG_ROOM_KEYS_VERSION`
    ///
    /// The version of the [room keys backup] provided in the request does not
    /// match the current backup version.
    ///
    /// [room keys backup]: https://spec.matrix.org/latest/client-server-api/#server-side-key-backups
    /// </summary>
    public record WrongRoomKeysVersion(string? @currentVersion) : ErrorKind { }

    /// <summary>
    /// A custom API error.
    /// </summary>
    public record Custom(string @errcode) : ErrorKind { }
}

class FfiConverterTypeErrorKind : FfiConverterRustBuffer<ErrorKind>
{
    public static FfiConverterRustBuffer<ErrorKind> INSTANCE = new FfiConverterTypeErrorKind();

    public override ErrorKind Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ErrorKind.BadAlias();
            case 2:
                return new ErrorKind.BadJson();
            case 3:
                return new ErrorKind.BadState();
            case 4:
                return new ErrorKind.BadStatus(
                    FfiConverterOptionalUInt16.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 5:
                return new ErrorKind.CannotLeaveServerNoticeRoom();
            case 6:
                return new ErrorKind.CannotOverwriteMedia();
            case 7:
                return new ErrorKind.CaptchaInvalid();
            case 8:
                return new ErrorKind.CaptchaNeeded();
            case 9:
                return new ErrorKind.ConnectionFailed();
            case 10:
                return new ErrorKind.ConnectionTimeout();
            case 11:
                return new ErrorKind.DuplicateAnnotation();
            case 12:
                return new ErrorKind.Exclusive();
            case 13:
                return new ErrorKind.Forbidden();
            case 14:
                return new ErrorKind.GuestAccessForbidden();
            case 15:
                return new ErrorKind.IncompatibleRoomVersion(FfiConverterString.INSTANCE.Read(stream));
            case 16:
                return new ErrorKind.InvalidParam();
            case 17:
                return new ErrorKind.InvalidRoomState();
            case 18:
                return new ErrorKind.InvalidUsername();
            case 19:
                return new ErrorKind.LimitExceeded(FfiConverterOptionalUInt64.INSTANCE.Read(stream));
            case 20:
                return new ErrorKind.MissingParam();
            case 21:
                return new ErrorKind.MissingToken();
            case 22:
                return new ErrorKind.NotFound();
            case 23:
                return new ErrorKind.NotJson();
            case 24:
                return new ErrorKind.NotYetUploaded();
            case 25:
                return new ErrorKind.ResourceLimitExceeded(FfiConverterString.INSTANCE.Read(stream));
            case 26:
                return new ErrorKind.RoomInUse();
            case 27:
                return new ErrorKind.ServerNotTrusted();
            case 28:
                return new ErrorKind.ThreepidAuthFailed();
            case 29:
                return new ErrorKind.ThreepidDenied();
            case 30:
                return new ErrorKind.ThreepidInUse();
            case 31:
                return new ErrorKind.ThreepidMediumNotSupported();
            case 32:
                return new ErrorKind.ThreepidNotFound();
            case 33:
                return new ErrorKind.TooLarge();
            case 34:
                return new ErrorKind.UnableToAuthorizeJoin();
            case 35:
                return new ErrorKind.UnableToGrantJoin();
            case 36:
                return new ErrorKind.Unauthorized();
            case 37:
                return new ErrorKind.Unknown();
            case 38:
                return new ErrorKind.UnknownToken(FfiConverterBoolean.INSTANCE.Read(stream));
            case 39:
                return new ErrorKind.Unrecognized();
            case 40:
                return new ErrorKind.UnsupportedRoomVersion();
            case 41:
                return new ErrorKind.UrlNotSet();
            case 42:
                return new ErrorKind.UserDeactivated();
            case 43:
                return new ErrorKind.UserInUse();
            case 44:
                return new ErrorKind.UserLocked();
            case 45:
                return new ErrorKind.UserSuspended();
            case 46:
                return new ErrorKind.WeakPassword();
            case 47:
                return new ErrorKind.WrongRoomKeysVersion(FfiConverterOptionalString.INSTANCE.Read(stream));
            case 48:
                return new ErrorKind.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeErrorKind.Read()", value)
                );
        }
    }

    public override int AllocationSize(ErrorKind value)
    {
        switch (value)
        {
            case ErrorKind.BadAlias variant_value:
                return 4;
            case ErrorKind.BadJson variant_value:
                return 4;
            case ErrorKind.BadState variant_value:
                return 4;
            case ErrorKind.BadStatus variant_value:
                return 4
                    + FfiConverterOptionalUInt16.INSTANCE.AllocationSize(variant_value.@status)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@body);
            case ErrorKind.CannotLeaveServerNoticeRoom variant_value:
                return 4;
            case ErrorKind.CannotOverwriteMedia variant_value:
                return 4;
            case ErrorKind.CaptchaInvalid variant_value:
                return 4;
            case ErrorKind.CaptchaNeeded variant_value:
                return 4;
            case ErrorKind.ConnectionFailed variant_value:
                return 4;
            case ErrorKind.ConnectionTimeout variant_value:
                return 4;
            case ErrorKind.DuplicateAnnotation variant_value:
                return 4;
            case ErrorKind.Exclusive variant_value:
                return 4;
            case ErrorKind.Forbidden variant_value:
                return 4;
            case ErrorKind.GuestAccessForbidden variant_value:
                return 4;
            case ErrorKind.IncompatibleRoomVersion variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomVersion);
            case ErrorKind.InvalidParam variant_value:
                return 4;
            case ErrorKind.InvalidRoomState variant_value:
                return 4;
            case ErrorKind.InvalidUsername variant_value:
                return 4;
            case ErrorKind.LimitExceeded variant_value:
                return 4 + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(variant_value.@retryAfterMs);
            case ErrorKind.MissingParam variant_value:
                return 4;
            case ErrorKind.MissingToken variant_value:
                return 4;
            case ErrorKind.NotFound variant_value:
                return 4;
            case ErrorKind.NotJson variant_value:
                return 4;
            case ErrorKind.NotYetUploaded variant_value:
                return 4;
            case ErrorKind.ResourceLimitExceeded variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@adminContact);
            case ErrorKind.RoomInUse variant_value:
                return 4;
            case ErrorKind.ServerNotTrusted variant_value:
                return 4;
            case ErrorKind.ThreepidAuthFailed variant_value:
                return 4;
            case ErrorKind.ThreepidDenied variant_value:
                return 4;
            case ErrorKind.ThreepidInUse variant_value:
                return 4;
            case ErrorKind.ThreepidMediumNotSupported variant_value:
                return 4;
            case ErrorKind.ThreepidNotFound variant_value:
                return 4;
            case ErrorKind.TooLarge variant_value:
                return 4;
            case ErrorKind.UnableToAuthorizeJoin variant_value:
                return 4;
            case ErrorKind.UnableToGrantJoin variant_value:
                return 4;
            case ErrorKind.Unauthorized variant_value:
                return 4;
            case ErrorKind.Unknown variant_value:
                return 4;
            case ErrorKind.UnknownToken variant_value:
                return 4 + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@softLogout);
            case ErrorKind.Unrecognized variant_value:
                return 4;
            case ErrorKind.UnsupportedRoomVersion variant_value:
                return 4;
            case ErrorKind.UrlNotSet variant_value:
                return 4;
            case ErrorKind.UserDeactivated variant_value:
                return 4;
            case ErrorKind.UserInUse variant_value:
                return 4;
            case ErrorKind.UserLocked variant_value:
                return 4;
            case ErrorKind.UserSuspended variant_value:
                return 4;
            case ErrorKind.WeakPassword variant_value:
                return 4;
            case ErrorKind.WrongRoomKeysVersion variant_value:
                return 4 + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@currentVersion);
            case ErrorKind.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@errcode);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeErrorKind.AllocationSize()", value)
                );
        }
    }

    public override void Write(ErrorKind value, BigEndianStream stream)
    {
        switch (value)
        {
            case ErrorKind.BadAlias variant_value:
                stream.WriteInt(1);
                break;
            case ErrorKind.BadJson variant_value:
                stream.WriteInt(2);
                break;
            case ErrorKind.BadState variant_value:
                stream.WriteInt(3);
                break;
            case ErrorKind.BadStatus variant_value:
                stream.WriteInt(4);
                FfiConverterOptionalUInt16.INSTANCE.Write(variant_value.@status, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@body, stream);
                break;
            case ErrorKind.CannotLeaveServerNoticeRoom variant_value:
                stream.WriteInt(5);
                break;
            case ErrorKind.CannotOverwriteMedia variant_value:
                stream.WriteInt(6);
                break;
            case ErrorKind.CaptchaInvalid variant_value:
                stream.WriteInt(7);
                break;
            case ErrorKind.CaptchaNeeded variant_value:
                stream.WriteInt(8);
                break;
            case ErrorKind.ConnectionFailed variant_value:
                stream.WriteInt(9);
                break;
            case ErrorKind.ConnectionTimeout variant_value:
                stream.WriteInt(10);
                break;
            case ErrorKind.DuplicateAnnotation variant_value:
                stream.WriteInt(11);
                break;
            case ErrorKind.Exclusive variant_value:
                stream.WriteInt(12);
                break;
            case ErrorKind.Forbidden variant_value:
                stream.WriteInt(13);
                break;
            case ErrorKind.GuestAccessForbidden variant_value:
                stream.WriteInt(14);
                break;
            case ErrorKind.IncompatibleRoomVersion variant_value:
                stream.WriteInt(15);
                FfiConverterString.INSTANCE.Write(variant_value.@roomVersion, stream);
                break;
            case ErrorKind.InvalidParam variant_value:
                stream.WriteInt(16);
                break;
            case ErrorKind.InvalidRoomState variant_value:
                stream.WriteInt(17);
                break;
            case ErrorKind.InvalidUsername variant_value:
                stream.WriteInt(18);
                break;
            case ErrorKind.LimitExceeded variant_value:
                stream.WriteInt(19);
                FfiConverterOptionalUInt64.INSTANCE.Write(variant_value.@retryAfterMs, stream);
                break;
            case ErrorKind.MissingParam variant_value:
                stream.WriteInt(20);
                break;
            case ErrorKind.MissingToken variant_value:
                stream.WriteInt(21);
                break;
            case ErrorKind.NotFound variant_value:
                stream.WriteInt(22);
                break;
            case ErrorKind.NotJson variant_value:
                stream.WriteInt(23);
                break;
            case ErrorKind.NotYetUploaded variant_value:
                stream.WriteInt(24);
                break;
            case ErrorKind.ResourceLimitExceeded variant_value:
                stream.WriteInt(25);
                FfiConverterString.INSTANCE.Write(variant_value.@adminContact, stream);
                break;
            case ErrorKind.RoomInUse variant_value:
                stream.WriteInt(26);
                break;
            case ErrorKind.ServerNotTrusted variant_value:
                stream.WriteInt(27);
                break;
            case ErrorKind.ThreepidAuthFailed variant_value:
                stream.WriteInt(28);
                break;
            case ErrorKind.ThreepidDenied variant_value:
                stream.WriteInt(29);
                break;
            case ErrorKind.ThreepidInUse variant_value:
                stream.WriteInt(30);
                break;
            case ErrorKind.ThreepidMediumNotSupported variant_value:
                stream.WriteInt(31);
                break;
            case ErrorKind.ThreepidNotFound variant_value:
                stream.WriteInt(32);
                break;
            case ErrorKind.TooLarge variant_value:
                stream.WriteInt(33);
                break;
            case ErrorKind.UnableToAuthorizeJoin variant_value:
                stream.WriteInt(34);
                break;
            case ErrorKind.UnableToGrantJoin variant_value:
                stream.WriteInt(35);
                break;
            case ErrorKind.Unauthorized variant_value:
                stream.WriteInt(36);
                break;
            case ErrorKind.Unknown variant_value:
                stream.WriteInt(37);
                break;
            case ErrorKind.UnknownToken variant_value:
                stream.WriteInt(38);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@softLogout, stream);
                break;
            case ErrorKind.Unrecognized variant_value:
                stream.WriteInt(39);
                break;
            case ErrorKind.UnsupportedRoomVersion variant_value:
                stream.WriteInt(40);
                break;
            case ErrorKind.UrlNotSet variant_value:
                stream.WriteInt(41);
                break;
            case ErrorKind.UserDeactivated variant_value:
                stream.WriteInt(42);
                break;
            case ErrorKind.UserInUse variant_value:
                stream.WriteInt(43);
                break;
            case ErrorKind.UserLocked variant_value:
                stream.WriteInt(44);
                break;
            case ErrorKind.UserSuspended variant_value:
                stream.WriteInt(45);
                break;
            case ErrorKind.WeakPassword variant_value:
                stream.WriteInt(46);
                break;
            case ErrorKind.WrongRoomKeysVersion variant_value:
                stream.WriteInt(47);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@currentVersion, stream);
                break;
            case ErrorKind.Custom variant_value:
                stream.WriteInt(48);
                FfiConverterString.INSTANCE.Write(variant_value.@errcode, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeErrorKind.Write()", value)
                );
        }
    }
}

/// <summary>
/// Contains the 2 possible identifiers of an event, either it has a remote
/// event id or a local transaction id, never both or none.
/// </summary>
internal record EventOrTransactionId
{
    public record EventId(string @eventId) : EventOrTransactionId { }

    public record TransactionId(string @transactionId) : EventOrTransactionId { }
}

class FfiConverterTypeEventOrTransactionId : FfiConverterRustBuffer<EventOrTransactionId>
{
    public static FfiConverterRustBuffer<EventOrTransactionId> INSTANCE = new FfiConverterTypeEventOrTransactionId();

    public override EventOrTransactionId Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new EventOrTransactionId.EventId(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new EventOrTransactionId.TransactionId(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEventOrTransactionId.Read()", value)
                );
        }
    }

    public override int AllocationSize(EventOrTransactionId value)
    {
        switch (value)
        {
            case EventOrTransactionId.EventId variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);
            case EventOrTransactionId.TransactionId variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@transactionId);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeEventOrTransactionId.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(EventOrTransactionId value, BigEndianStream stream)
    {
        switch (value)
        {
            case EventOrTransactionId.EventId variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            case EventOrTransactionId.TransactionId variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@transactionId, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEventOrTransactionId.Write()", value)
                );
        }
    }
}

/// <summary>
/// This type represents the send state of a local event timeline item.
/// </summary>
internal record EventSendState
{
    /// <summary>
    /// The local event has not been sent yet.
    /// </summary>
    public record NotSentYet : EventSendState { }

    /// <summary>
    /// The local event has been sent to the server, but unsuccessfully: The
    /// sending has failed.
    /// </summary>
    public record SendingFailed(QueueWedgeError @error, bool @isRecoverable) : EventSendState { }

    /// <summary>
    /// The local event has been sent successfully to the server.
    /// </summary>
    public record Sent(string @eventId) : EventSendState { }
}

class FfiConverterTypeEventSendState : FfiConverterRustBuffer<EventSendState>
{
    public static FfiConverterRustBuffer<EventSendState> INSTANCE = new FfiConverterTypeEventSendState();

    public override EventSendState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new EventSendState.NotSentYet();
            case 2:
                return new EventSendState.SendingFailed(
                    FfiConverterTypeQueueWedgeError.INSTANCE.Read(stream),
                    FfiConverterBoolean.INSTANCE.Read(stream)
                );
            case 3:
                return new EventSendState.Sent(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEventSendState.Read()", value)
                );
        }
    }

    public override int AllocationSize(EventSendState value)
    {
        switch (value)
        {
            case EventSendState.NotSentYet variant_value:
                return 4;
            case EventSendState.SendingFailed variant_value:
                return 4
                    + FfiConverterTypeQueueWedgeError.INSTANCE.AllocationSize(variant_value.@error)
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@isRecoverable);
            case EventSendState.Sent variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEventSendState.AllocationSize()", value)
                );
        }
    }

    public override void Write(EventSendState value, BigEndianStream stream)
    {
        switch (value)
        {
            case EventSendState.NotSentYet variant_value:
                stream.WriteInt(1);
                break;
            case EventSendState.SendingFailed variant_value:
                stream.WriteInt(2);
                FfiConverterTypeQueueWedgeError.INSTANCE.Write(variant_value.@error, stream);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@isRecoverable, stream);
                break;
            case EventSendState.Sent variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeEventSendState.Write()", value)
                );
        }
    }
}

internal record FilterTimelineEventType
{
    public record MessageLike(MessageLikeEventType @eventType) : FilterTimelineEventType { }

    public record State(StateEventType @eventType) : FilterTimelineEventType { }
}

class FfiConverterTypeFilterTimelineEventType : FfiConverterRustBuffer<FilterTimelineEventType>
{
    public static FfiConverterRustBuffer<FilterTimelineEventType> INSTANCE =
        new FfiConverterTypeFilterTimelineEventType();

    public override FilterTimelineEventType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new FilterTimelineEventType.MessageLike(
                    FfiConverterTypeMessageLikeEventType.INSTANCE.Read(stream)
                );
            case 2:
                return new FilterTimelineEventType.State(FfiConverterTypeStateEventType.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeFilterTimelineEventType.Read()", value)
                );
        }
    }

    public override int AllocationSize(FilterTimelineEventType value)
    {
        switch (value)
        {
            case FilterTimelineEventType.MessageLike variant_value:
                return 4 + FfiConverterTypeMessageLikeEventType.INSTANCE.AllocationSize(variant_value.@eventType);
            case FilterTimelineEventType.State variant_value:
                return 4 + FfiConverterTypeStateEventType.INSTANCE.AllocationSize(variant_value.@eventType);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeFilterTimelineEventType.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(FilterTimelineEventType value, BigEndianStream stream)
    {
        switch (value)
        {
            case FilterTimelineEventType.MessageLike variant_value:
                stream.WriteInt(1);
                FfiConverterTypeMessageLikeEventType.INSTANCE.Write(variant_value.@eventType, stream);
                break;
            case FilterTimelineEventType.State variant_value:
                stream.WriteInt(2);
                FfiConverterTypeStateEventType.INSTANCE.Write(variant_value.@eventType, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeFilterTimelineEventType.Write()", value)
                );
        }
    }
}

internal class FocusEventException : UniffiException
{
    FocusEventException()
        : base() { }

    FocusEventException(String @Message)
        : base(@Message) { }

    // Each variant is a nested class

    public class InvalidEventId : FocusEventException
    {
        // Members
        public string @eventId;
        public string @err;

        // Constructor
        public InvalidEventId(string @eventId, string @err)
            : base("@eventId" + "=" + @eventId + ", " + "@err" + "=" + @err)
        {
            this.@eventId = @eventId;

            this.@err = @err;
        }
    }

    public class EventNotFound : FocusEventException
    {
        // Members
        public string @eventId;

        // Constructor
        public EventNotFound(string @eventId)
            : base("@eventId" + "=" + @eventId)
        {
            this.@eventId = @eventId;
        }
    }

    public class Other : FocusEventException
    {
        // Members
        public string @msg;

        // Constructor
        public Other(string @msg)
            : base("@msg" + "=" + @msg)
        {
            this.@msg = @msg;
        }
    }
}

class FfiConverterTypeFocusEventError
    : FfiConverterRustBuffer<FocusEventException>,
        CallStatusErrorHandler<FocusEventException>
{
    public static FfiConverterTypeFocusEventError INSTANCE = new FfiConverterTypeFocusEventError();

    public override FocusEventException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new FocusEventException.InvalidEventId(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new FocusEventException.EventNotFound(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new FocusEventException.Other(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeFocusEventError.Read()", value)
                );
        }
    }

    public override int AllocationSize(FocusEventException value)
    {
        switch (value)
        {
            case FocusEventException.InvalidEventId variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@err);

            case FocusEventException.EventNotFound variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);

            case FocusEventException.Other variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeFocusEventError.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(FocusEventException value, BigEndianStream stream)
    {
        switch (value)
        {
            case FocusEventException.InvalidEventId variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@err, stream);
                break;
            case FocusEventException.EventNotFound variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            case FocusEventException.Other variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeFocusEventError.Write()", value)
                );
        }
    }
}

internal class HumanQrLoginException : UniffiException
{
    HumanQrLoginException()
        : base() { }

    HumanQrLoginException(String @Message)
        : base(@Message) { }

    // Each variant is a nested class

    public class LinkingNotSupported : HumanQrLoginException
    {
        public LinkingNotSupported()
            : base() { }
    }

    public class Cancelled : HumanQrLoginException
    {
        public Cancelled()
            : base() { }
    }

    public class Expired : HumanQrLoginException
    {
        public Expired()
            : base() { }
    }

    public class ConnectionInsecure : HumanQrLoginException
    {
        public ConnectionInsecure()
            : base() { }
    }

    public class Declined : HumanQrLoginException
    {
        public Declined()
            : base() { }
    }

    public class Unknown : HumanQrLoginException
    {
        public Unknown()
            : base() { }
    }

    public class SlidingSyncNotAvailable : HumanQrLoginException
    {
        public SlidingSyncNotAvailable()
            : base() { }
    }

    public class OidcMetadataInvalid : HumanQrLoginException
    {
        public OidcMetadataInvalid()
            : base() { }
    }

    public class OtherDeviceNotSignedIn : HumanQrLoginException
    {
        public OtherDeviceNotSignedIn()
            : base() { }
    }
}

class FfiConverterTypeHumanQrLoginError
    : FfiConverterRustBuffer<HumanQrLoginException>,
        CallStatusErrorHandler<HumanQrLoginException>
{
    public static FfiConverterTypeHumanQrLoginError INSTANCE = new FfiConverterTypeHumanQrLoginError();

    public override HumanQrLoginException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new HumanQrLoginException.LinkingNotSupported();
            case 2:
                return new HumanQrLoginException.Cancelled();
            case 3:
                return new HumanQrLoginException.Expired();
            case 4:
                return new HumanQrLoginException.ConnectionInsecure();
            case 5:
                return new HumanQrLoginException.Declined();
            case 6:
                return new HumanQrLoginException.Unknown();
            case 7:
                return new HumanQrLoginException.SlidingSyncNotAvailable();
            case 8:
                return new HumanQrLoginException.OidcMetadataInvalid();
            case 9:
                return new HumanQrLoginException.OtherDeviceNotSignedIn();
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeHumanQrLoginError.Read()", value)
                );
        }
    }

    public override int AllocationSize(HumanQrLoginException value)
    {
        switch (value)
        {
            case HumanQrLoginException.LinkingNotSupported variant_value:
                return 4;

            case HumanQrLoginException.Cancelled variant_value:
                return 4;

            case HumanQrLoginException.Expired variant_value:
                return 4;

            case HumanQrLoginException.ConnectionInsecure variant_value:
                return 4;

            case HumanQrLoginException.Declined variant_value:
                return 4;

            case HumanQrLoginException.Unknown variant_value:
                return 4;

            case HumanQrLoginException.SlidingSyncNotAvailable variant_value:
                return 4;

            case HumanQrLoginException.OidcMetadataInvalid variant_value:
                return 4;

            case HumanQrLoginException.OtherDeviceNotSignedIn variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeHumanQrLoginError.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(HumanQrLoginException value, BigEndianStream stream)
    {
        switch (value)
        {
            case HumanQrLoginException.LinkingNotSupported variant_value:
                stream.WriteInt(1);
                break;
            case HumanQrLoginException.Cancelled variant_value:
                stream.WriteInt(2);
                break;
            case HumanQrLoginException.Expired variant_value:
                stream.WriteInt(3);
                break;
            case HumanQrLoginException.ConnectionInsecure variant_value:
                stream.WriteInt(4);
                break;
            case HumanQrLoginException.Declined variant_value:
                stream.WriteInt(5);
                break;
            case HumanQrLoginException.Unknown variant_value:
                stream.WriteInt(6);
                break;
            case HumanQrLoginException.SlidingSyncNotAvailable variant_value:
                stream.WriteInt(7);
                break;
            case HumanQrLoginException.OidcMetadataInvalid variant_value:
                stream.WriteInt(8);
                break;
            case HumanQrLoginException.OtherDeviceNotSignedIn variant_value:
                stream.WriteInt(9);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeHumanQrLoginError.Write()", value)
                );
        }
    }
}

/// <summary>
/// Defines the intent of showing the call.
///
/// This controls whether to show or skip the lobby.
/// </summary>
internal enum Intent : int
{
    /// <summary>
    /// The user wants to start a call.
    /// </summary>
    StartCall,

    /// <summary>
    /// The user wants to join an existing call.
    /// </summary>
    JoinExisting,
}

class FfiConverterTypeIntent : FfiConverterRustBuffer<Intent>
{
    public static FfiConverterTypeIntent INSTANCE = new FfiConverterTypeIntent();

    public override Intent Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(Intent), value))
        {
            return (Intent)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeIntent.Read()", value)
            );
        }
    }

    public override int AllocationSize(Intent value)
    {
        return 4;
    }

    public override void Write(Intent value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// The rule used for users wishing to join this room.
/// </summary>
internal record JoinRule
{
    /// <summary>
    /// Anyone can join the room without any prior action.
    /// </summary>
    public record Public : JoinRule { }

    /// <summary>
    /// A user who wishes to join the room must first receive an invite to the
    /// room from someone already inside of the room.
    /// </summary>
    public record Invite : JoinRule { }

    /// <summary>
    /// Users can join the room if they are invited, or they can request an
    /// invite to the room.
    ///
    /// They can be allowed (invited) or denied (kicked/banned) access.
    /// </summary>
    public record Knock : JoinRule { }

    /// <summary>
    /// Reserved but not yet implemented by the Matrix specification.
    /// </summary>
    public record Private : JoinRule { }

    /// <summary>
    /// Users can join the room if they are invited, or if they meet any of the
    /// conditions described in a set of [`AllowRule`]s.
    /// </summary>
    public record Restricted(List<AllowRule> @rules) : JoinRule { }

    /// <summary>
    /// Users can join the room if they are invited, or if they meet any of the
    /// conditions described in a set of [`AllowRule`]s, or they can request
    /// an invite to the room.
    /// </summary>
    public record KnockRestricted(List<AllowRule> @rules) : JoinRule { }

    /// <summary>
    /// A custom join rule, up for interpretation by the consumer.
    /// </summary>
    public record Custom(string @repr) : JoinRule { }
}

class FfiConverterTypeJoinRule : FfiConverterRustBuffer<JoinRule>
{
    public static FfiConverterRustBuffer<JoinRule> INSTANCE = new FfiConverterTypeJoinRule();

    public override JoinRule Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new JoinRule.Public();
            case 2:
                return new JoinRule.Invite();
            case 3:
                return new JoinRule.Knock();
            case 4:
                return new JoinRule.Private();
            case 5:
                return new JoinRule.Restricted(FfiConverterSequenceTypeAllowRule.INSTANCE.Read(stream));
            case 6:
                return new JoinRule.KnockRestricted(FfiConverterSequenceTypeAllowRule.INSTANCE.Read(stream));
            case 7:
                return new JoinRule.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeJoinRule.Read()", value)
                );
        }
    }

    public override int AllocationSize(JoinRule value)
    {
        switch (value)
        {
            case JoinRule.Public variant_value:
                return 4;
            case JoinRule.Invite variant_value:
                return 4;
            case JoinRule.Knock variant_value:
                return 4;
            case JoinRule.Private variant_value:
                return 4;
            case JoinRule.Restricted variant_value:
                return 4 + FfiConverterSequenceTypeAllowRule.INSTANCE.AllocationSize(variant_value.@rules);
            case JoinRule.KnockRestricted variant_value:
                return 4 + FfiConverterSequenceTypeAllowRule.INSTANCE.AllocationSize(variant_value.@rules);
            case JoinRule.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@repr);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeJoinRule.AllocationSize()", value)
                );
        }
    }

    public override void Write(JoinRule value, BigEndianStream stream)
    {
        switch (value)
        {
            case JoinRule.Public variant_value:
                stream.WriteInt(1);
                break;
            case JoinRule.Invite variant_value:
                stream.WriteInt(2);
                break;
            case JoinRule.Knock variant_value:
                stream.WriteInt(3);
                break;
            case JoinRule.Private variant_value:
                stream.WriteInt(4);
                break;
            case JoinRule.Restricted variant_value:
                stream.WriteInt(5);
                FfiConverterSequenceTypeAllowRule.INSTANCE.Write(variant_value.@rules, stream);
                break;
            case JoinRule.KnockRestricted variant_value:
                stream.WriteInt(6);
                FfiConverterSequenceTypeAllowRule.INSTANCE.Write(variant_value.@rules, stream);
                break;
            case JoinRule.Custom variant_value:
                stream.WriteInt(7);
                FfiConverterString.INSTANCE.Write(variant_value.@repr, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeJoinRule.Write()", value)
                );
        }
    }
}

internal record JsonValue
{
    /// <summary>
    /// Represents a `null` value.
    /// </summary>
    public record Null : JsonValue { }

    /// <summary>
    /// Represents a boolean.
    /// </summary>
    public record Bool(bool @value) : JsonValue { }

    /// <summary>
    /// Represents an integer.
    /// </summary>
    public record Integer(long @value) : JsonValue { }

    /// <summary>
    /// Represents a string.
    /// </summary>
    public record String(string @value) : JsonValue { }
}

class FfiConverterTypeJsonValue : FfiConverterRustBuffer<JsonValue>
{
    public static FfiConverterRustBuffer<JsonValue> INSTANCE = new FfiConverterTypeJsonValue();

    public override JsonValue Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new JsonValue.Null();
            case 2:
                return new JsonValue.Bool(FfiConverterBoolean.INSTANCE.Read(stream));
            case 3:
                return new JsonValue.Integer(FfiConverterInt64.INSTANCE.Read(stream));
            case 4:
                return new JsonValue.String(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeJsonValue.Read()", value)
                );
        }
    }

    public override int AllocationSize(JsonValue value)
    {
        switch (value)
        {
            case JsonValue.Null variant_value:
                return 4;
            case JsonValue.Bool variant_value:
                return 4 + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@value);
            case JsonValue.Integer variant_value:
                return 4 + FfiConverterInt64.INSTANCE.AllocationSize(variant_value.@value);
            case JsonValue.String variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeJsonValue.AllocationSize()", value)
                );
        }
    }

    public override void Write(JsonValue value, BigEndianStream stream)
    {
        switch (value)
        {
            case JsonValue.Null variant_value:
                stream.WriteInt(1);
                break;
            case JsonValue.Bool variant_value:
                stream.WriteInt(2);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@value, stream);
                break;
            case JsonValue.Integer variant_value:
                stream.WriteInt(3);
                FfiConverterInt64.INSTANCE.Write(variant_value.@value, stream);
                break;
            case JsonValue.String variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeJsonValue.Write()", value)
                );
        }
    }
}

internal enum LogLevel : int
{
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

class FfiConverterTypeLogLevel : FfiConverterRustBuffer<LogLevel>
{
    public static FfiConverterTypeLogLevel INSTANCE = new FfiConverterTypeLogLevel();

    public override LogLevel Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(LogLevel), value))
        {
            return (LogLevel)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeLogLevel.Read()", value)
            );
        }
    }

    public override int AllocationSize(LogLevel value)
    {
        return 4;
    }

    public override void Write(LogLevel value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// A Matrix ID that can be a room, room alias, user, or event.
/// </summary>
internal record MatrixId
{
    public record Room(string @id) : MatrixId { }

    public record RoomAlias(string @alias) : MatrixId { }

    public record User(string @id) : MatrixId { }

    public record EventOnRoomId(string @roomId, string @eventId) : MatrixId { }

    public record EventOnRoomAlias(string @alias, string @eventId) : MatrixId { }
}

class FfiConverterTypeMatrixId : FfiConverterRustBuffer<MatrixId>
{
    public static FfiConverterRustBuffer<MatrixId> INSTANCE = new FfiConverterTypeMatrixId();

    public override MatrixId Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MatrixId.Room(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new MatrixId.RoomAlias(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new MatrixId.User(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new MatrixId.EventOnRoomId(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 5:
                return new MatrixId.EventOnRoomAlias(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMatrixId.Read()", value)
                );
        }
    }

    public override int AllocationSize(MatrixId value)
    {
        switch (value)
        {
            case MatrixId.Room variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@id);
            case MatrixId.RoomAlias variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@alias);
            case MatrixId.User variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@id);
            case MatrixId.EventOnRoomId variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomId)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);
            case MatrixId.EventOnRoomAlias variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@alias)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMatrixId.AllocationSize()", value)
                );
        }
    }

    public override void Write(MatrixId value, BigEndianStream stream)
    {
        switch (value)
        {
            case MatrixId.Room variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@id, stream);
                break;
            case MatrixId.RoomAlias variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@alias, stream);
                break;
            case MatrixId.User variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@id, stream);
                break;
            case MatrixId.EventOnRoomId variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@roomId, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            case MatrixId.EventOnRoomAlias variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@alias, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMatrixId.Write()", value)
                );
        }
    }
}

internal class MediaInfoException : UniffiException
{
    MediaInfoException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class MissingField : MediaInfoException
    {
        public MissingField(string message)
            : base(message) { }
    }

    public class InvalidField : MediaInfoException
    {
        public InvalidField(string message)
            : base(message) { }
    }
}

class FfiConverterTypeMediaInfoError
    : FfiConverterRustBuffer<MediaInfoException>,
        CallStatusErrorHandler<MediaInfoException>
{
    public static FfiConverterTypeMediaInfoError INSTANCE = new FfiConverterTypeMediaInfoError();

    public override MediaInfoException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MediaInfoException.MissingField(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new MediaInfoException.InvalidField(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeMediaInfoError.Read()", value)
                );
        }
    }

    public override int AllocationSize(MediaInfoException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(MediaInfoException value, BigEndianStream stream)
    {
        switch (value)
        {
            case MediaInfoException.MissingField:
                stream.WriteInt(1);
                break;
            case MediaInfoException.InvalidField:
                stream.WriteInt(2);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeMediaInfoError.Write()", value)
                );
        }
    }
}

internal enum Membership : int
{
    Invited,
    Joined,
    Left,
    Knocked,
    Banned,
}

class FfiConverterTypeMembership : FfiConverterRustBuffer<Membership>
{
    public static FfiConverterTypeMembership INSTANCE = new FfiConverterTypeMembership();

    public override Membership Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(Membership), value))
        {
            return (Membership)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeMembership.Read()", value)
            );
        }
    }

    public override int AllocationSize(Membership value)
    {
        return 4;
    }

    public override void Write(Membership value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal enum MembershipChange : int
{
    None,
    Error,
    Joined,
    Left,
    Banned,
    Unbanned,
    Kicked,
    Invited,
    KickedAndBanned,
    InvitationAccepted,
    InvitationRejected,
    InvitationRevoked,
    Knocked,
    KnockAccepted,
    KnockRetracted,
    KnockDenied,
    NotImplemented,
}

class FfiConverterTypeMembershipChange : FfiConverterRustBuffer<MembershipChange>
{
    public static FfiConverterTypeMembershipChange INSTANCE = new FfiConverterTypeMembershipChange();

    public override MembershipChange Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(MembershipChange), value))
        {
            return (MembershipChange)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeMembershipChange.Read()", value)
            );
        }
    }

    public override int AllocationSize(MembershipChange value)
    {
        return 4;
    }

    public override void Write(MembershipChange value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record MembershipState
{
    /// <summary>
    /// The user is banned.
    /// </summary>
    public record Ban : MembershipState { }

    /// <summary>
    /// The user has been invited.
    /// </summary>
    public record Invite : MembershipState { }

    /// <summary>
    /// The user has joined.
    /// </summary>
    public record Join : MembershipState { }

    /// <summary>
    /// The user has requested to join.
    /// </summary>
    public record Knock : MembershipState { }

    /// <summary>
    /// The user has left.
    /// </summary>
    public record Leave : MembershipState { }

    /// <summary>
    /// A custom membership state value.
    /// </summary>
    public record Custom(string @value) : MembershipState { }
}

class FfiConverterTypeMembershipState : FfiConverterRustBuffer<MembershipState>
{
    public static FfiConverterRustBuffer<MembershipState> INSTANCE = new FfiConverterTypeMembershipState();

    public override MembershipState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MembershipState.Ban();
            case 2:
                return new MembershipState.Invite();
            case 3:
                return new MembershipState.Join();
            case 4:
                return new MembershipState.Knock();
            case 5:
                return new MembershipState.Leave();
            case 6:
                return new MembershipState.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMembershipState.Read()", value)
                );
        }
    }

    public override int AllocationSize(MembershipState value)
    {
        switch (value)
        {
            case MembershipState.Ban variant_value:
                return 4;
            case MembershipState.Invite variant_value:
                return 4;
            case MembershipState.Join variant_value:
                return 4;
            case MembershipState.Knock variant_value:
                return 4;
            case MembershipState.Leave variant_value:
                return 4;
            case MembershipState.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMembershipState.AllocationSize()", value)
                );
        }
    }

    public override void Write(MembershipState value, BigEndianStream stream)
    {
        switch (value)
        {
            case MembershipState.Ban variant_value:
                stream.WriteInt(1);
                break;
            case MembershipState.Invite variant_value:
                stream.WriteInt(2);
                break;
            case MembershipState.Join variant_value:
                stream.WriteInt(3);
                break;
            case MembershipState.Knock variant_value:
                stream.WriteInt(4);
                break;
            case MembershipState.Leave variant_value:
                stream.WriteInt(5);
                break;
            case MembershipState.Custom variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMembershipState.Write()", value)
                );
        }
    }
}

internal record MessageFormat
{
    public record Html : MessageFormat { }

    public record Unknown(string @format) : MessageFormat { }
}

class FfiConverterTypeMessageFormat : FfiConverterRustBuffer<MessageFormat>
{
    public static FfiConverterRustBuffer<MessageFormat> INSTANCE = new FfiConverterTypeMessageFormat();

    public override MessageFormat Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MessageFormat.Html();
            case 2:
                return new MessageFormat.Unknown(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageFormat.Read()", value)
                );
        }
    }

    public override int AllocationSize(MessageFormat value)
    {
        switch (value)
        {
            case MessageFormat.Html variant_value:
                return 4;
            case MessageFormat.Unknown variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@format);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageFormat.AllocationSize()", value)
                );
        }
    }

    public override void Write(MessageFormat value, BigEndianStream stream)
    {
        switch (value)
        {
            case MessageFormat.Html variant_value:
                stream.WriteInt(1);
                break;
            case MessageFormat.Unknown variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@format, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageFormat.Write()", value)
                );
        }
    }
}

internal record MessageLikeEventContent : IDisposable
{
    public record CallAnswer : MessageLikeEventContent { }

    public record CallInvite : MessageLikeEventContent { }

    public record CallNotify(NotifyType @notifyType) : MessageLikeEventContent { }

    public record CallHangup : MessageLikeEventContent { }

    public record CallCandidates : MessageLikeEventContent { }

    public record KeyVerificationReady : MessageLikeEventContent { }

    public record KeyVerificationStart : MessageLikeEventContent { }

    public record KeyVerificationCancel : MessageLikeEventContent { }

    public record KeyVerificationAccept : MessageLikeEventContent { }

    public record KeyVerificationKey : MessageLikeEventContent { }

    public record KeyVerificationMac : MessageLikeEventContent { }

    public record KeyVerificationDone : MessageLikeEventContent { }

    public record Poll(string @question) : MessageLikeEventContent { }

    public record ReactionContent(string @relatedEventId) : MessageLikeEventContent { }

    public record RoomEncrypted : MessageLikeEventContent { }

    public record RoomMessage(MessageType @messageType, string? @inReplyToEventId) : MessageLikeEventContent { }

    public record RoomRedaction(string? @redactedEventId, string? @reason) : MessageLikeEventContent { }

    public record Sticker : MessageLikeEventContent { }

    public void Dispose()
    {
        switch (this)
        {
            case MessageLikeEventContent.CallAnswer variant_value:
                break;
            case MessageLikeEventContent.CallInvite variant_value:
                break;
            case MessageLikeEventContent.CallNotify variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@notifyType);
                break;
            case MessageLikeEventContent.CallHangup variant_value:
                break;
            case MessageLikeEventContent.CallCandidates variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationReady variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationStart variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationCancel variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationAccept variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationKey variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationMac variant_value:
                break;
            case MessageLikeEventContent.KeyVerificationDone variant_value:
                break;
            case MessageLikeEventContent.Poll variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@question);
                break;
            case MessageLikeEventContent.ReactionContent variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@relatedEventId);
                break;
            case MessageLikeEventContent.RoomEncrypted variant_value:
                break;
            case MessageLikeEventContent.RoomMessage variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@messageType, variant_value.@inReplyToEventId);
                break;
            case MessageLikeEventContent.RoomRedaction variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@redactedEventId, variant_value.@reason);
                break;
            case MessageLikeEventContent.Sticker variant_value:
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in MessageLikeEventContent.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeMessageLikeEventContent : FfiConverterRustBuffer<MessageLikeEventContent>
{
    public static FfiConverterRustBuffer<MessageLikeEventContent> INSTANCE =
        new FfiConverterTypeMessageLikeEventContent();

    public override MessageLikeEventContent Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MessageLikeEventContent.CallAnswer();
            case 2:
                return new MessageLikeEventContent.CallInvite();
            case 3:
                return new MessageLikeEventContent.CallNotify(FfiConverterTypeNotifyType.INSTANCE.Read(stream));
            case 4:
                return new MessageLikeEventContent.CallHangup();
            case 5:
                return new MessageLikeEventContent.CallCandidates();
            case 6:
                return new MessageLikeEventContent.KeyVerificationReady();
            case 7:
                return new MessageLikeEventContent.KeyVerificationStart();
            case 8:
                return new MessageLikeEventContent.KeyVerificationCancel();
            case 9:
                return new MessageLikeEventContent.KeyVerificationAccept();
            case 10:
                return new MessageLikeEventContent.KeyVerificationKey();
            case 11:
                return new MessageLikeEventContent.KeyVerificationMac();
            case 12:
                return new MessageLikeEventContent.KeyVerificationDone();
            case 13:
                return new MessageLikeEventContent.Poll(FfiConverterString.INSTANCE.Read(stream));
            case 14:
                return new MessageLikeEventContent.ReactionContent(FfiConverterString.INSTANCE.Read(stream));
            case 15:
                return new MessageLikeEventContent.RoomEncrypted();
            case 16:
                return new MessageLikeEventContent.RoomMessage(
                    FfiConverterTypeMessageType.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 17:
                return new MessageLikeEventContent.RoomRedaction(
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 18:
                return new MessageLikeEventContent.Sticker();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageLikeEventContent.Read()", value)
                );
        }
    }

    public override int AllocationSize(MessageLikeEventContent value)
    {
        switch (value)
        {
            case MessageLikeEventContent.CallAnswer variant_value:
                return 4;
            case MessageLikeEventContent.CallInvite variant_value:
                return 4;
            case MessageLikeEventContent.CallNotify variant_value:
                return 4 + FfiConverterTypeNotifyType.INSTANCE.AllocationSize(variant_value.@notifyType);
            case MessageLikeEventContent.CallHangup variant_value:
                return 4;
            case MessageLikeEventContent.CallCandidates variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationReady variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationStart variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationCancel variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationAccept variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationKey variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationMac variant_value:
                return 4;
            case MessageLikeEventContent.KeyVerificationDone variant_value:
                return 4;
            case MessageLikeEventContent.Poll variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@question);
            case MessageLikeEventContent.ReactionContent variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@relatedEventId);
            case MessageLikeEventContent.RoomEncrypted variant_value:
                return 4;
            case MessageLikeEventContent.RoomMessage variant_value:
                return 4
                    + FfiConverterTypeMessageType.INSTANCE.AllocationSize(variant_value.@messageType)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@inReplyToEventId);
            case MessageLikeEventContent.RoomRedaction variant_value:
                return 4
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@redactedEventId)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@reason);
            case MessageLikeEventContent.Sticker variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeMessageLikeEventContent.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(MessageLikeEventContent value, BigEndianStream stream)
    {
        switch (value)
        {
            case MessageLikeEventContent.CallAnswer variant_value:
                stream.WriteInt(1);
                break;
            case MessageLikeEventContent.CallInvite variant_value:
                stream.WriteInt(2);
                break;
            case MessageLikeEventContent.CallNotify variant_value:
                stream.WriteInt(3);
                FfiConverterTypeNotifyType.INSTANCE.Write(variant_value.@notifyType, stream);
                break;
            case MessageLikeEventContent.CallHangup variant_value:
                stream.WriteInt(4);
                break;
            case MessageLikeEventContent.CallCandidates variant_value:
                stream.WriteInt(5);
                break;
            case MessageLikeEventContent.KeyVerificationReady variant_value:
                stream.WriteInt(6);
                break;
            case MessageLikeEventContent.KeyVerificationStart variant_value:
                stream.WriteInt(7);
                break;
            case MessageLikeEventContent.KeyVerificationCancel variant_value:
                stream.WriteInt(8);
                break;
            case MessageLikeEventContent.KeyVerificationAccept variant_value:
                stream.WriteInt(9);
                break;
            case MessageLikeEventContent.KeyVerificationKey variant_value:
                stream.WriteInt(10);
                break;
            case MessageLikeEventContent.KeyVerificationMac variant_value:
                stream.WriteInt(11);
                break;
            case MessageLikeEventContent.KeyVerificationDone variant_value:
                stream.WriteInt(12);
                break;
            case MessageLikeEventContent.Poll variant_value:
                stream.WriteInt(13);
                FfiConverterString.INSTANCE.Write(variant_value.@question, stream);
                break;
            case MessageLikeEventContent.ReactionContent variant_value:
                stream.WriteInt(14);
                FfiConverterString.INSTANCE.Write(variant_value.@relatedEventId, stream);
                break;
            case MessageLikeEventContent.RoomEncrypted variant_value:
                stream.WriteInt(15);
                break;
            case MessageLikeEventContent.RoomMessage variant_value:
                stream.WriteInt(16);
                FfiConverterTypeMessageType.INSTANCE.Write(variant_value.@messageType, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@inReplyToEventId, stream);
                break;
            case MessageLikeEventContent.RoomRedaction variant_value:
                stream.WriteInt(17);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@redactedEventId, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@reason, stream);
                break;
            case MessageLikeEventContent.Sticker variant_value:
                stream.WriteInt(18);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageLikeEventContent.Write()", value)
                );
        }
    }
}

internal enum MessageLikeEventType : int
{
    CallAnswer,
    CallCandidates,
    CallHangup,
    CallInvite,
    CallNotify,
    KeyVerificationAccept,
    KeyVerificationCancel,
    KeyVerificationDone,
    KeyVerificationKey,
    KeyVerificationMac,
    KeyVerificationReady,
    KeyVerificationStart,
    PollEnd,
    PollResponse,
    PollStart,
    Reaction,
    RoomEncrypted,
    RoomMessage,
    RoomRedaction,
    Sticker,
    UnstablePollEnd,
    UnstablePollResponse,
    UnstablePollStart,
}

class FfiConverterTypeMessageLikeEventType : FfiConverterRustBuffer<MessageLikeEventType>
{
    public static FfiConverterTypeMessageLikeEventType INSTANCE = new FfiConverterTypeMessageLikeEventType();

    public override MessageLikeEventType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(MessageLikeEventType), value))
        {
            return (MessageLikeEventType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeMessageLikeEventType.Read()", value)
            );
        }
    }

    public override int AllocationSize(MessageLikeEventType value)
    {
        return 4;
    }

    public override void Write(MessageLikeEventType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record MessageType : IDisposable
{
    public record Emote(EmoteMessageContent @content) : MessageType { }

    public record Image(ImageMessageContent @content) : MessageType { }

    public record Audio(AudioMessageContent @content) : MessageType { }

    public record Video(VideoMessageContent @content) : MessageType { }

    public record File(FileMessageContent @content) : MessageType { }

    public record Notice(NoticeMessageContent @content) : MessageType { }

    public record Text(TextMessageContent @content) : MessageType { }

    public record Location(LocationContent @content) : MessageType { }

    public record Other(string @msgtype, string @body) : MessageType { }

    public void Dispose()
    {
        switch (this)
        {
            case MessageType.Emote variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Image variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Audio variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Video variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.File variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Notice variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Text variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Location variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MessageType.Other variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@msgtype, variant_value.@body);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in MessageType.Dispose()", this));
        }
    }
}

class FfiConverterTypeMessageType : FfiConverterRustBuffer<MessageType>
{
    public static FfiConverterRustBuffer<MessageType> INSTANCE = new FfiConverterTypeMessageType();

    public override MessageType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MessageType.Emote(FfiConverterTypeEmoteMessageContent.INSTANCE.Read(stream));
            case 2:
                return new MessageType.Image(FfiConverterTypeImageMessageContent.INSTANCE.Read(stream));
            case 3:
                return new MessageType.Audio(FfiConverterTypeAudioMessageContent.INSTANCE.Read(stream));
            case 4:
                return new MessageType.Video(FfiConverterTypeVideoMessageContent.INSTANCE.Read(stream));
            case 5:
                return new MessageType.File(FfiConverterTypeFileMessageContent.INSTANCE.Read(stream));
            case 6:
                return new MessageType.Notice(FfiConverterTypeNoticeMessageContent.INSTANCE.Read(stream));
            case 7:
                return new MessageType.Text(FfiConverterTypeTextMessageContent.INSTANCE.Read(stream));
            case 8:
                return new MessageType.Location(FfiConverterTypeLocationContent.INSTANCE.Read(stream));
            case 9:
                return new MessageType.Other(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageType.Read()", value)
                );
        }
    }

    public override int AllocationSize(MessageType value)
    {
        switch (value)
        {
            case MessageType.Emote variant_value:
                return 4 + FfiConverterTypeEmoteMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Image variant_value:
                return 4 + FfiConverterTypeImageMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Audio variant_value:
                return 4 + FfiConverterTypeAudioMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Video variant_value:
                return 4 + FfiConverterTypeVideoMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.File variant_value:
                return 4 + FfiConverterTypeFileMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Notice variant_value:
                return 4 + FfiConverterTypeNoticeMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Text variant_value:
                return 4 + FfiConverterTypeTextMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Location variant_value:
                return 4 + FfiConverterTypeLocationContent.INSTANCE.AllocationSize(variant_value.@content);
            case MessageType.Other variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msgtype)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@body);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageType.AllocationSize()", value)
                );
        }
    }

    public override void Write(MessageType value, BigEndianStream stream)
    {
        switch (value)
        {
            case MessageType.Emote variant_value:
                stream.WriteInt(1);
                FfiConverterTypeEmoteMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Image variant_value:
                stream.WriteInt(2);
                FfiConverterTypeImageMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Audio variant_value:
                stream.WriteInt(3);
                FfiConverterTypeAudioMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Video variant_value:
                stream.WriteInt(4);
                FfiConverterTypeVideoMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.File variant_value:
                stream.WriteInt(5);
                FfiConverterTypeFileMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Notice variant_value:
                stream.WriteInt(6);
                FfiConverterTypeNoticeMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Text variant_value:
                stream.WriteInt(7);
                FfiConverterTypeTextMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Location variant_value:
                stream.WriteInt(8);
                FfiConverterTypeLocationContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MessageType.Other variant_value:
                stream.WriteInt(9);
                FfiConverterString.INSTANCE.Write(variant_value.@msgtype, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@body, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMessageType.Write()", value)
                );
        }
    }
}

internal record MsgLikeKind : IDisposable
{
    /// <summary>
    /// An `m.room.message` event or extensible event, including edits.
    /// </summary>
    public record Message(MessageContent @content) : MsgLikeKind { }

    /// <summary>
    /// An `m.sticker` event.
    /// </summary>
    public record Sticker(string @body, ImageInfo @info, MediaSource @source) : MsgLikeKind { }

    /// <summary>
    /// An `m.poll.start` event.
    /// </summary>
    public record Poll(
        string @question,
        PollKind @kind,
        ulong @maxSelections,
        List<PollAnswer> @answers,
        Dictionary<string, List<string>> @votes,
        Timestamp? @endTime,
        bool @hasBeenEdited
    ) : MsgLikeKind { }

    /// <summary>
    /// A redacted message.
    /// </summary>
    public record Redacted : MsgLikeKind { }

    /// <summary>
    /// An `m.room.encrypted` event that could not be decrypted.
    /// </summary>
    public record UnableToDecrypt(EncryptedMessage @msg) : MsgLikeKind { }

    public void Dispose()
    {
        switch (this)
        {
            case MsgLikeKind.Message variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case MsgLikeKind.Sticker variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@body, variant_value.@info, variant_value.@source);
                break;
            case MsgLikeKind.Poll variant_value:

                FFIObjectUtil.DisposeAll(
                    variant_value.@question,
                    variant_value.@kind,
                    variant_value.@maxSelections,
                    variant_value.@answers,
                    variant_value.@votes,
                    variant_value.@endTime,
                    variant_value.@hasBeenEdited
                );
                break;
            case MsgLikeKind.Redacted variant_value:
                break;
            case MsgLikeKind.UnableToDecrypt variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@msg);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in MsgLikeKind.Dispose()", this));
        }
    }
}

class FfiConverterTypeMsgLikeKind : FfiConverterRustBuffer<MsgLikeKind>
{
    public static FfiConverterRustBuffer<MsgLikeKind> INSTANCE = new FfiConverterTypeMsgLikeKind();

    public override MsgLikeKind Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new MsgLikeKind.Message(FfiConverterTypeMessageContent.INSTANCE.Read(stream));
            case 2:
                return new MsgLikeKind.Sticker(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeImageInfo.INSTANCE.Read(stream),
                    FfiConverterTypeMediaSource.INSTANCE.Read(stream)
                );
            case 3:
                return new MsgLikeKind.Poll(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypePollKind.INSTANCE.Read(stream),
                    FfiConverterUInt64.INSTANCE.Read(stream),
                    FfiConverterSequenceTypePollAnswer.INSTANCE.Read(stream),
                    FfiConverterDictionaryStringSequenceString.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeTimestamp.INSTANCE.Read(stream),
                    FfiConverterBoolean.INSTANCE.Read(stream)
                );
            case 4:
                return new MsgLikeKind.Redacted();
            case 5:
                return new MsgLikeKind.UnableToDecrypt(FfiConverterTypeEncryptedMessage.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMsgLikeKind.Read()", value)
                );
        }
    }

    public override int AllocationSize(MsgLikeKind value)
    {
        switch (value)
        {
            case MsgLikeKind.Message variant_value:
                return 4 + FfiConverterTypeMessageContent.INSTANCE.AllocationSize(variant_value.@content);
            case MsgLikeKind.Sticker variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@body)
                    + FfiConverterTypeImageInfo.INSTANCE.AllocationSize(variant_value.@info)
                    + FfiConverterTypeMediaSource.INSTANCE.AllocationSize(variant_value.@source);
            case MsgLikeKind.Poll variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@question)
                    + FfiConverterTypePollKind.INSTANCE.AllocationSize(variant_value.@kind)
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@maxSelections)
                    + FfiConverterSequenceTypePollAnswer.INSTANCE.AllocationSize(variant_value.@answers)
                    + FfiConverterDictionaryStringSequenceString.INSTANCE.AllocationSize(variant_value.@votes)
                    + FfiConverterOptionalTypeTimestamp.INSTANCE.AllocationSize(variant_value.@endTime)
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@hasBeenEdited);
            case MsgLikeKind.Redacted variant_value:
                return 4;
            case MsgLikeKind.UnableToDecrypt variant_value:
                return 4 + FfiConverterTypeEncryptedMessage.INSTANCE.AllocationSize(variant_value.@msg);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMsgLikeKind.AllocationSize()", value)
                );
        }
    }

    public override void Write(MsgLikeKind value, BigEndianStream stream)
    {
        switch (value)
        {
            case MsgLikeKind.Message variant_value:
                stream.WriteInt(1);
                FfiConverterTypeMessageContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case MsgLikeKind.Sticker variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@body, stream);
                FfiConverterTypeImageInfo.INSTANCE.Write(variant_value.@info, stream);
                FfiConverterTypeMediaSource.INSTANCE.Write(variant_value.@source, stream);
                break;
            case MsgLikeKind.Poll variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@question, stream);
                FfiConverterTypePollKind.INSTANCE.Write(variant_value.@kind, stream);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@maxSelections, stream);
                FfiConverterSequenceTypePollAnswer.INSTANCE.Write(variant_value.@answers, stream);
                FfiConverterDictionaryStringSequenceString.INSTANCE.Write(variant_value.@votes, stream);
                FfiConverterOptionalTypeTimestamp.INSTANCE.Write(variant_value.@endTime, stream);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@hasBeenEdited, stream);
                break;
            case MsgLikeKind.Redacted variant_value:
                stream.WriteInt(4);
                break;
            case MsgLikeKind.UnableToDecrypt variant_value:
                stream.WriteInt(5);
                FfiConverterTypeEncryptedMessage.INSTANCE.Write(variant_value.@msg, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeMsgLikeKind.Write()", value)
                );
        }
    }
}

internal record NotificationEvent : IDisposable
{
    public record Timeline(TimelineEvent @event) : NotificationEvent { }

    public record Invite(string @sender) : NotificationEvent { }

    public void Dispose()
    {
        switch (this)
        {
            case NotificationEvent.Timeline variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@event);
                break;
            case NotificationEvent.Invite variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@sender);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in NotificationEvent.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeNotificationEvent : FfiConverterRustBuffer<NotificationEvent>
{
    public static FfiConverterRustBuffer<NotificationEvent> INSTANCE = new FfiConverterTypeNotificationEvent();

    public override NotificationEvent Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new NotificationEvent.Timeline(FfiConverterTypeTimelineEvent.INSTANCE.Read(stream));
            case 2:
                return new NotificationEvent.Invite(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeNotificationEvent.Read()", value)
                );
        }
    }

    public override int AllocationSize(NotificationEvent value)
    {
        switch (value)
        {
            case NotificationEvent.Timeline variant_value:
                return 4 + FfiConverterTypeTimelineEvent.INSTANCE.AllocationSize(variant_value.@event);
            case NotificationEvent.Invite variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@sender);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeNotificationEvent.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(NotificationEvent value, BigEndianStream stream)
    {
        switch (value)
        {
            case NotificationEvent.Timeline variant_value:
                stream.WriteInt(1);
                FfiConverterTypeTimelineEvent.INSTANCE.Write(variant_value.@event, stream);
                break;
            case NotificationEvent.Invite variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@sender, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeNotificationEvent.Write()", value)
                );
        }
    }
}

internal record NotificationProcessSetup : IDisposable
{
    public record MultipleProcesses : NotificationProcessSetup { }

    public record SingleProcess(SyncService @syncService) : NotificationProcessSetup { }

    public void Dispose()
    {
        switch (this)
        {
            case NotificationProcessSetup.MultipleProcesses variant_value:
                break;
            case NotificationProcessSetup.SingleProcess variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@syncService);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in NotificationProcessSetup.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeNotificationProcessSetup : FfiConverterRustBuffer<NotificationProcessSetup>
{
    public static FfiConverterRustBuffer<NotificationProcessSetup> INSTANCE =
        new FfiConverterTypeNotificationProcessSetup();

    public override NotificationProcessSetup Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new NotificationProcessSetup.MultipleProcesses();
            case 2:
                return new NotificationProcessSetup.SingleProcess(FfiConverterTypeSyncService.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeNotificationProcessSetup.Read()", value)
                );
        }
    }

    public override int AllocationSize(NotificationProcessSetup value)
    {
        switch (value)
        {
            case NotificationProcessSetup.MultipleProcesses variant_value:
                return 4;
            case NotificationProcessSetup.SingleProcess variant_value:
                return 4 + FfiConverterTypeSyncService.INSTANCE.AllocationSize(variant_value.@syncService);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeNotificationProcessSetup.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(NotificationProcessSetup value, BigEndianStream stream)
    {
        switch (value)
        {
            case NotificationProcessSetup.MultipleProcesses variant_value:
                stream.WriteInt(1);
                break;
            case NotificationProcessSetup.SingleProcess variant_value:
                stream.WriteInt(2);
                FfiConverterTypeSyncService.INSTANCE.Write(variant_value.@syncService, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeNotificationProcessSetup.Write()", value)
                );
        }
    }
}

internal class NotificationSettingsException : UniffiException
{
    NotificationSettingsException()
        : base() { }

    NotificationSettingsException(String @Message)
        : base(@Message) { }

    // Each variant is a nested class

    public class Generic : NotificationSettingsException
    {
        // Members
        public string @msg;

        // Constructor
        public Generic(string @msg)
            : base("@msg" + "=" + @msg)
        {
            this.@msg = @msg;
        }
    }

    /// <summary>
    /// Invalid parameter.
    /// </summary>
    public class InvalidParameter : NotificationSettingsException
    {
        // Members
        public string @msg;

        // Constructor
        public InvalidParameter(string @msg)
            : base("@msg" + "=" + @msg)
        {
            this.@msg = @msg;
        }
    }

    /// <summary>
    /// Invalid room id.
    /// </summary>
    public class InvalidRoomId : NotificationSettingsException
    {
        // Members
        public string @roomId;

        // Constructor
        public InvalidRoomId(string @roomId)
            : base("@roomId" + "=" + @roomId)
        {
            this.@roomId = @roomId;
        }
    }

    /// <summary>
    /// Rule not found
    /// </summary>
    public class RuleNotFound : NotificationSettingsException
    {
        // Members
        public string @ruleId;

        // Constructor
        public RuleNotFound(string @ruleId)
            : base("@ruleId" + "=" + @ruleId)
        {
            this.@ruleId = @ruleId;
        }
    }

    /// <summary>
    /// Unable to add push rule.
    /// </summary>
    public class UnableToAddPushRule : NotificationSettingsException
    {
        public UnableToAddPushRule()
            : base() { }
    }

    /// <summary>
    /// Unable to remove push rule.
    /// </summary>
    public class UnableToRemovePushRule : NotificationSettingsException
    {
        public UnableToRemovePushRule()
            : base() { }
    }

    /// <summary>
    /// Unable to save the push rules
    /// </summary>
    public class UnableToSavePushRules : NotificationSettingsException
    {
        public UnableToSavePushRules()
            : base() { }
    }

    /// <summary>
    /// Unable to update push rule.
    /// </summary>
    public class UnableToUpdatePushRule : NotificationSettingsException
    {
        public UnableToUpdatePushRule()
            : base() { }
    }
}

class FfiConverterTypeNotificationSettingsError
    : FfiConverterRustBuffer<NotificationSettingsException>,
        CallStatusErrorHandler<NotificationSettingsException>
{
    public static FfiConverterTypeNotificationSettingsError INSTANCE = new FfiConverterTypeNotificationSettingsError();

    public override NotificationSettingsException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new NotificationSettingsException.Generic(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new NotificationSettingsException.InvalidParameter(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new NotificationSettingsException.InvalidRoomId(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new NotificationSettingsException.RuleNotFound(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new NotificationSettingsException.UnableToAddPushRule();
            case 6:
                return new NotificationSettingsException.UnableToRemovePushRule();
            case 7:
                return new NotificationSettingsException.UnableToSavePushRules();
            case 8:
                return new NotificationSettingsException.UnableToUpdatePushRule();
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeNotificationSettingsError.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(NotificationSettingsException value)
    {
        switch (value)
        {
            case NotificationSettingsException.Generic variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);

            case NotificationSettingsException.InvalidParameter variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);

            case NotificationSettingsException.InvalidRoomId variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomId);

            case NotificationSettingsException.RuleNotFound variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@ruleId);

            case NotificationSettingsException.UnableToAddPushRule variant_value:
                return 4;

            case NotificationSettingsException.UnableToRemovePushRule variant_value:
                return 4;

            case NotificationSettingsException.UnableToSavePushRules variant_value:
                return 4;

            case NotificationSettingsException.UnableToUpdatePushRule variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeNotificationSettingsError.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(NotificationSettingsException value, BigEndianStream stream)
    {
        switch (value)
        {
            case NotificationSettingsException.Generic variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                break;
            case NotificationSettingsException.InvalidParameter variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                break;
            case NotificationSettingsException.InvalidRoomId variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@roomId, stream);
                break;
            case NotificationSettingsException.RuleNotFound variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@ruleId, stream);
                break;
            case NotificationSettingsException.UnableToAddPushRule variant_value:
                stream.WriteInt(5);
                break;
            case NotificationSettingsException.UnableToRemovePushRule variant_value:
                stream.WriteInt(6);
                break;
            case NotificationSettingsException.UnableToSavePushRules variant_value:
                stream.WriteInt(7);
                break;
            case NotificationSettingsException.UnableToUpdatePushRule variant_value:
                stream.WriteInt(8);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeNotificationSettingsError.Write()",
                        value
                    )
                );
        }
    }
}

internal enum NotifyType : int
{
    Ring,
    Notify,
}

class FfiConverterTypeNotifyType : FfiConverterRustBuffer<NotifyType>
{
    public static FfiConverterTypeNotifyType INSTANCE = new FfiConverterTypeNotifyType();

    public override NotifyType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(NotifyType), value))
        {
            return (NotifyType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeNotifyType.Read()", value)
            );
        }
    }

    public override int AllocationSize(NotifyType value)
    {
        return 4;
    }

    public override void Write(NotifyType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal class OidcException : UniffiException
{
    OidcException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class NotSupported : OidcException
    {
        public NotSupported(string message)
            : base(message) { }
    }

    public class MetadataInvalid : OidcException
    {
        public MetadataInvalid(string message)
            : base(message) { }
    }

    public class CallbackUrlInvalid : OidcException
    {
        public CallbackUrlInvalid(string message)
            : base(message) { }
    }

    public class Cancelled : OidcException
    {
        public Cancelled(string message)
            : base(message) { }
    }

    public class Generic : OidcException
    {
        public Generic(string message)
            : base(message) { }
    }
}

class FfiConverterTypeOidcError : FfiConverterRustBuffer<OidcException>, CallStatusErrorHandler<OidcException>
{
    public static FfiConverterTypeOidcError INSTANCE = new FfiConverterTypeOidcError();

    public override OidcException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new OidcException.NotSupported(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new OidcException.MetadataInvalid(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new OidcException.CallbackUrlInvalid(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new OidcException.Cancelled(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new OidcException.Generic(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeOidcError.Read()", value)
                );
        }
    }

    public override int AllocationSize(OidcException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(OidcException value, BigEndianStream stream)
    {
        switch (value)
        {
            case OidcException.NotSupported:
                stream.WriteInt(1);
                break;
            case OidcException.MetadataInvalid:
                stream.WriteInt(2);
                break;
            case OidcException.CallbackUrlInvalid:
                stream.WriteInt(3);
                break;
            case OidcException.Cancelled:
                stream.WriteInt(4);
                break;
            case OidcException.Generic:
                stream.WriteInt(5);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeOidcError.Write()", value)
                );
        }
    }
}

internal record OidcPrompt
{
    /// <summary>
    /// The Authorization Server should prompt the End-User to create a user
    /// account.
    ///
    /// Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
    /// </summary>
    public record Create : OidcPrompt { }

    /// <summary>
    /// The Authorization Server should prompt the End-User for
    /// reauthentication.
    /// </summary>
    public record Login : OidcPrompt { }

    /// <summary>
    /// The Authorization Server should prompt the End-User for consent before
    /// returning information to the Client.
    /// </summary>
    public record Consent : OidcPrompt { }

    /// <summary>
    /// An unknown value.
    /// </summary>
    public record Unknown(string @value) : OidcPrompt { }
}

class FfiConverterTypeOidcPrompt : FfiConverterRustBuffer<OidcPrompt>
{
    public static FfiConverterRustBuffer<OidcPrompt> INSTANCE = new FfiConverterTypeOidcPrompt();

    public override OidcPrompt Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new OidcPrompt.Create();
            case 2:
                return new OidcPrompt.Login();
            case 3:
                return new OidcPrompt.Consent();
            case 4:
                return new OidcPrompt.Unknown(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeOidcPrompt.Read()", value)
                );
        }
    }

    public override int AllocationSize(OidcPrompt value)
    {
        switch (value)
        {
            case OidcPrompt.Create variant_value:
                return 4;
            case OidcPrompt.Login variant_value:
                return 4;
            case OidcPrompt.Consent variant_value:
                return 4;
            case OidcPrompt.Unknown variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeOidcPrompt.AllocationSize()", value)
                );
        }
    }

    public override void Write(OidcPrompt value, BigEndianStream stream)
    {
        switch (value)
        {
            case OidcPrompt.Create variant_value:
                stream.WriteInt(1);
                break;
            case OidcPrompt.Login variant_value:
                stream.WriteInt(2);
                break;
            case OidcPrompt.Consent variant_value:
                stream.WriteInt(3);
                break;
            case OidcPrompt.Unknown variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeOidcPrompt.Write()", value)
                );
        }
    }
}

internal record OtherState
{
    public record PolicyRuleRoom : OtherState { }

    public record PolicyRuleServer : OtherState { }

    public record PolicyRuleUser : OtherState { }

    public record RoomAliases : OtherState { }

    public record RoomAvatar(string? @url) : OtherState { }

    public record RoomCanonicalAlias : OtherState { }

    public record RoomCreate : OtherState { }

    public record RoomEncryption : OtherState { }

    public record RoomGuestAccess : OtherState { }

    public record RoomHistoryVisibility : OtherState { }

    public record RoomJoinRules : OtherState { }

    public record RoomName(string? @name) : OtherState { }

    public record RoomPinnedEvents(RoomPinnedEventsChange @change) : OtherState { }

    public record RoomPowerLevels(Dictionary<string, long> @users, Dictionary<string, long>? @previous) : OtherState { }

    public record RoomServerAcl : OtherState { }

    public record RoomThirdPartyInvite(string? @displayName) : OtherState { }

    public record RoomTombstone : OtherState { }

    public record RoomTopic(string? @topic) : OtherState { }

    public record SpaceChild : OtherState { }

    public record SpaceParent : OtherState { }

    public record Custom(string @eventType) : OtherState { }
}

class FfiConverterTypeOtherState : FfiConverterRustBuffer<OtherState>
{
    public static FfiConverterRustBuffer<OtherState> INSTANCE = new FfiConverterTypeOtherState();

    public override OtherState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new OtherState.PolicyRuleRoom();
            case 2:
                return new OtherState.PolicyRuleServer();
            case 3:
                return new OtherState.PolicyRuleUser();
            case 4:
                return new OtherState.RoomAliases();
            case 5:
                return new OtherState.RoomAvatar(FfiConverterOptionalString.INSTANCE.Read(stream));
            case 6:
                return new OtherState.RoomCanonicalAlias();
            case 7:
                return new OtherState.RoomCreate();
            case 8:
                return new OtherState.RoomEncryption();
            case 9:
                return new OtherState.RoomGuestAccess();
            case 10:
                return new OtherState.RoomHistoryVisibility();
            case 11:
                return new OtherState.RoomJoinRules();
            case 12:
                return new OtherState.RoomName(FfiConverterOptionalString.INSTANCE.Read(stream));
            case 13:
                return new OtherState.RoomPinnedEvents(FfiConverterTypeRoomPinnedEventsChange.INSTANCE.Read(stream));
            case 14:
                return new OtherState.RoomPowerLevels(
                    FfiConverterDictionaryStringInt64.INSTANCE.Read(stream),
                    FfiConverterOptionalDictionaryStringInt64.INSTANCE.Read(stream)
                );
            case 15:
                return new OtherState.RoomServerAcl();
            case 16:
                return new OtherState.RoomThirdPartyInvite(FfiConverterOptionalString.INSTANCE.Read(stream));
            case 17:
                return new OtherState.RoomTombstone();
            case 18:
                return new OtherState.RoomTopic(FfiConverterOptionalString.INSTANCE.Read(stream));
            case 19:
                return new OtherState.SpaceChild();
            case 20:
                return new OtherState.SpaceParent();
            case 21:
                return new OtherState.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeOtherState.Read()", value)
                );
        }
    }

    public override int AllocationSize(OtherState value)
    {
        switch (value)
        {
            case OtherState.PolicyRuleRoom variant_value:
                return 4;
            case OtherState.PolicyRuleServer variant_value:
                return 4;
            case OtherState.PolicyRuleUser variant_value:
                return 4;
            case OtherState.RoomAliases variant_value:
                return 4;
            case OtherState.RoomAvatar variant_value:
                return 4 + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@url);
            case OtherState.RoomCanonicalAlias variant_value:
                return 4;
            case OtherState.RoomCreate variant_value:
                return 4;
            case OtherState.RoomEncryption variant_value:
                return 4;
            case OtherState.RoomGuestAccess variant_value:
                return 4;
            case OtherState.RoomHistoryVisibility variant_value:
                return 4;
            case OtherState.RoomJoinRules variant_value:
                return 4;
            case OtherState.RoomName variant_value:
                return 4 + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@name);
            case OtherState.RoomPinnedEvents variant_value:
                return 4 + FfiConverterTypeRoomPinnedEventsChange.INSTANCE.AllocationSize(variant_value.@change);
            case OtherState.RoomPowerLevels variant_value:
                return 4
                    + FfiConverterDictionaryStringInt64.INSTANCE.AllocationSize(variant_value.@users)
                    + FfiConverterOptionalDictionaryStringInt64.INSTANCE.AllocationSize(variant_value.@previous);
            case OtherState.RoomServerAcl variant_value:
                return 4;
            case OtherState.RoomThirdPartyInvite variant_value:
                return 4 + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@displayName);
            case OtherState.RoomTombstone variant_value:
                return 4;
            case OtherState.RoomTopic variant_value:
                return 4 + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@topic);
            case OtherState.SpaceChild variant_value:
                return 4;
            case OtherState.SpaceParent variant_value:
                return 4;
            case OtherState.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventType);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeOtherState.AllocationSize()", value)
                );
        }
    }

    public override void Write(OtherState value, BigEndianStream stream)
    {
        switch (value)
        {
            case OtherState.PolicyRuleRoom variant_value:
                stream.WriteInt(1);
                break;
            case OtherState.PolicyRuleServer variant_value:
                stream.WriteInt(2);
                break;
            case OtherState.PolicyRuleUser variant_value:
                stream.WriteInt(3);
                break;
            case OtherState.RoomAliases variant_value:
                stream.WriteInt(4);
                break;
            case OtherState.RoomAvatar variant_value:
                stream.WriteInt(5);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@url, stream);
                break;
            case OtherState.RoomCanonicalAlias variant_value:
                stream.WriteInt(6);
                break;
            case OtherState.RoomCreate variant_value:
                stream.WriteInt(7);
                break;
            case OtherState.RoomEncryption variant_value:
                stream.WriteInt(8);
                break;
            case OtherState.RoomGuestAccess variant_value:
                stream.WriteInt(9);
                break;
            case OtherState.RoomHistoryVisibility variant_value:
                stream.WriteInt(10);
                break;
            case OtherState.RoomJoinRules variant_value:
                stream.WriteInt(11);
                break;
            case OtherState.RoomName variant_value:
                stream.WriteInt(12);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@name, stream);
                break;
            case OtherState.RoomPinnedEvents variant_value:
                stream.WriteInt(13);
                FfiConverterTypeRoomPinnedEventsChange.INSTANCE.Write(variant_value.@change, stream);
                break;
            case OtherState.RoomPowerLevels variant_value:
                stream.WriteInt(14);
                FfiConverterDictionaryStringInt64.INSTANCE.Write(variant_value.@users, stream);
                FfiConverterOptionalDictionaryStringInt64.INSTANCE.Write(variant_value.@previous, stream);
                break;
            case OtherState.RoomServerAcl variant_value:
                stream.WriteInt(15);
                break;
            case OtherState.RoomThirdPartyInvite variant_value:
                stream.WriteInt(16);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@displayName, stream);
                break;
            case OtherState.RoomTombstone variant_value:
                stream.WriteInt(17);
                break;
            case OtherState.RoomTopic variant_value:
                stream.WriteInt(18);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@topic, stream);
                break;
            case OtherState.SpaceChild variant_value:
                stream.WriteInt(19);
                break;
            case OtherState.SpaceParent variant_value:
                stream.WriteInt(20);
                break;
            case OtherState.Custom variant_value:
                stream.WriteInt(21);
                FfiConverterString.INSTANCE.Write(variant_value.@eventType, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeOtherState.Write()", value)
                );
        }
    }
}

internal class ParseException : UniffiException
{
    ParseException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class EmptyHost : ParseException
    {
        public EmptyHost(string message)
            : base(message) { }
    }

    public class IdnaException : ParseException
    {
        public IdnaException(string message)
            : base(message) { }
    }

    public class InvalidPort : ParseException
    {
        public InvalidPort(string message)
            : base(message) { }
    }

    public class InvalidIpv4Address : ParseException
    {
        public InvalidIpv4Address(string message)
            : base(message) { }
    }

    public class InvalidIpv6Address : ParseException
    {
        public InvalidIpv6Address(string message)
            : base(message) { }
    }

    public class InvalidDomainCharacter : ParseException
    {
        public InvalidDomainCharacter(string message)
            : base(message) { }
    }

    public class RelativeUrlWithoutBase : ParseException
    {
        public RelativeUrlWithoutBase(string message)
            : base(message) { }
    }

    public class RelativeUrlWithCannotBeABaseBase : ParseException
    {
        public RelativeUrlWithCannotBeABaseBase(string message)
            : base(message) { }
    }

    public class SetHostOnCannotBeABaseUrl : ParseException
    {
        public SetHostOnCannotBeABaseUrl(string message)
            : base(message) { }
    }

    public class Overflow : ParseException
    {
        public Overflow(string message)
            : base(message) { }
    }

    public class Other : ParseException
    {
        public Other(string message)
            : base(message) { }
    }
}

class FfiConverterTypeParseError : FfiConverterRustBuffer<ParseException>, CallStatusErrorHandler<ParseException>
{
    public static FfiConverterTypeParseError INSTANCE = new FfiConverterTypeParseError();

    public override ParseException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ParseException.EmptyHost(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new ParseException.IdnaException(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new ParseException.InvalidPort(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new ParseException.InvalidIpv4Address(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new ParseException.InvalidIpv6Address(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new ParseException.InvalidDomainCharacter(FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new ParseException.RelativeUrlWithoutBase(FfiConverterString.INSTANCE.Read(stream));
            case 8:
                return new ParseException.RelativeUrlWithCannotBeABaseBase(FfiConverterString.INSTANCE.Read(stream));
            case 9:
                return new ParseException.SetHostOnCannotBeABaseUrl(FfiConverterString.INSTANCE.Read(stream));
            case 10:
                return new ParseException.Overflow(FfiConverterString.INSTANCE.Read(stream));
            case 11:
                return new ParseException.Other(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeParseError.Read()", value)
                );
        }
    }

    public override int AllocationSize(ParseException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(ParseException value, BigEndianStream stream)
    {
        switch (value)
        {
            case ParseException.EmptyHost:
                stream.WriteInt(1);
                break;
            case ParseException.IdnaException:
                stream.WriteInt(2);
                break;
            case ParseException.InvalidPort:
                stream.WriteInt(3);
                break;
            case ParseException.InvalidIpv4Address:
                stream.WriteInt(4);
                break;
            case ParseException.InvalidIpv6Address:
                stream.WriteInt(5);
                break;
            case ParseException.InvalidDomainCharacter:
                stream.WriteInt(6);
                break;
            case ParseException.RelativeUrlWithoutBase:
                stream.WriteInt(7);
                break;
            case ParseException.RelativeUrlWithCannotBeABaseBase:
                stream.WriteInt(8);
                break;
            case ParseException.SetHostOnCannotBeABaseUrl:
                stream.WriteInt(9);
                break;
            case ParseException.Overflow:
                stream.WriteInt(10);
                break;
            case ParseException.Other:
                stream.WriteInt(11);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeParseError.Write()", value)
                );
        }
    }
}

internal enum PollKind : int
{
    Disclosed,
    Undisclosed,
}

class FfiConverterTypePollKind : FfiConverterRustBuffer<PollKind>
{
    public static FfiConverterTypePollKind INSTANCE = new FfiConverterTypePollKind();

    public override PollKind Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PollKind), value))
        {
            return (PollKind)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypePollKind.Read()", value)
            );
        }
    }

    public override int AllocationSize(PollKind value)
    {
        return 4;
    }

    public override void Write(PollKind value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record ProfileDetails
{
    public record Unavailable : ProfileDetails { }

    public record Pending : ProfileDetails { }

    public record Ready(string? @displayName, bool @displayNameAmbiguous, string? @avatarUrl) : ProfileDetails { }

    public record Error(string @message) : ProfileDetails { }
}

class FfiConverterTypeProfileDetails : FfiConverterRustBuffer<ProfileDetails>
{
    public static FfiConverterRustBuffer<ProfileDetails> INSTANCE = new FfiConverterTypeProfileDetails();

    public override ProfileDetails Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ProfileDetails.Unavailable();
            case 2:
                return new ProfileDetails.Pending();
            case 3:
                return new ProfileDetails.Ready(
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterBoolean.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 4:
                return new ProfileDetails.Error(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeProfileDetails.Read()", value)
                );
        }
    }

    public override int AllocationSize(ProfileDetails value)
    {
        switch (value)
        {
            case ProfileDetails.Unavailable variant_value:
                return 4;
            case ProfileDetails.Pending variant_value:
                return 4;
            case ProfileDetails.Ready variant_value:
                return 4
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@displayName)
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@displayNameAmbiguous)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@avatarUrl);
            case ProfileDetails.Error variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeProfileDetails.AllocationSize()", value)
                );
        }
    }

    public override void Write(ProfileDetails value, BigEndianStream stream)
    {
        switch (value)
        {
            case ProfileDetails.Unavailable variant_value:
                stream.WriteInt(1);
                break;
            case ProfileDetails.Pending variant_value:
                stream.WriteInt(2);
                break;
            case ProfileDetails.Ready variant_value:
                stream.WriteInt(3);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@displayName, stream);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@displayNameAmbiguous, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@avatarUrl, stream);
                break;
            case ProfileDetails.Error variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeProfileDetails.Write()", value)
                );
        }
    }
}

internal enum PublicRoomJoinRule : int
{
    Public,
    Knock,
}

class FfiConverterTypePublicRoomJoinRule : FfiConverterRustBuffer<PublicRoomJoinRule>
{
    public static FfiConverterTypePublicRoomJoinRule INSTANCE = new FfiConverterTypePublicRoomJoinRule();

    public override PublicRoomJoinRule Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PublicRoomJoinRule), value))
        {
            return (PublicRoomJoinRule)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypePublicRoomJoinRule.Read()", value)
            );
        }
    }

    public override int AllocationSize(PublicRoomJoinRule value)
    {
        return 4;
    }

    public override void Write(PublicRoomJoinRule value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record PushCondition
{
    /// <summary>
    /// A glob pattern match on a field of the event.
    /// </summary>
    public record EventMatch(string @key, string @pattern) : PushCondition { }

    /// <summary>
    /// Matches unencrypted messages where `content.body` contains the owner's
    /// display name in that room.
    /// </summary>
    public record ContainsDisplayName : PushCondition { }

    /// <summary>
    /// Matches the current number of members in the room.
    /// </summary>
    public record RoomMemberCount(ComparisonOperator @prefix, ulong @count) : PushCondition { }

    /// <summary>
    /// Takes into account the current power levels in the room, ensuring the
    /// sender of the event has high enough power to trigger the
    /// notification.
    /// </summary>
    public record SenderNotificationPermission(string @key) : PushCondition { }

    /// <summary>
    /// Exact value match on a property of the event.
    /// </summary>
    public record EventPropertyIs(string @key, JsonValue @value) : PushCondition { }

    /// <summary>
    /// Exact value match on a value in an array property of the event.
    /// </summary>
    public record EventPropertyContains(string @key, JsonValue @value) : PushCondition { }
}

class FfiConverterTypePushCondition : FfiConverterRustBuffer<PushCondition>
{
    public static FfiConverterRustBuffer<PushCondition> INSTANCE = new FfiConverterTypePushCondition();

    public override PushCondition Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new PushCondition.EventMatch(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new PushCondition.ContainsDisplayName();
            case 3:
                return new PushCondition.RoomMemberCount(
                    FfiConverterTypeComparisonOperator.INSTANCE.Read(stream),
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 4:
                return new PushCondition.SenderNotificationPermission(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new PushCondition.EventPropertyIs(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeJsonValue.INSTANCE.Read(stream)
                );
            case 6:
                return new PushCondition.EventPropertyContains(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeJsonValue.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypePushCondition.Read()", value)
                );
        }
    }

    public override int AllocationSize(PushCondition value)
    {
        switch (value)
        {
            case PushCondition.EventMatch variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@key)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@pattern);
            case PushCondition.ContainsDisplayName variant_value:
                return 4;
            case PushCondition.RoomMemberCount variant_value:
                return 4
                    + FfiConverterTypeComparisonOperator.INSTANCE.AllocationSize(variant_value.@prefix)
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@count);
            case PushCondition.SenderNotificationPermission variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@key);
            case PushCondition.EventPropertyIs variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@key)
                    + FfiConverterTypeJsonValue.INSTANCE.AllocationSize(variant_value.@value);
            case PushCondition.EventPropertyContains variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@key)
                    + FfiConverterTypeJsonValue.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypePushCondition.AllocationSize()", value)
                );
        }
    }

    public override void Write(PushCondition value, BigEndianStream stream)
    {
        switch (value)
        {
            case PushCondition.EventMatch variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@key, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@pattern, stream);
                break;
            case PushCondition.ContainsDisplayName variant_value:
                stream.WriteInt(2);
                break;
            case PushCondition.RoomMemberCount variant_value:
                stream.WriteInt(3);
                FfiConverterTypeComparisonOperator.INSTANCE.Write(variant_value.@prefix, stream);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@count, stream);
                break;
            case PushCondition.SenderNotificationPermission variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@key, stream);
                break;
            case PushCondition.EventPropertyIs variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@key, stream);
                FfiConverterTypeJsonValue.INSTANCE.Write(variant_value.@value, stream);
                break;
            case PushCondition.EventPropertyContains variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@key, stream);
                FfiConverterTypeJsonValue.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypePushCondition.Write()", value)
                );
        }
    }
}

internal enum PushFormat : int
{
    EventIdOnly,
}

class FfiConverterTypePushFormat : FfiConverterRustBuffer<PushFormat>
{
    public static FfiConverterTypePushFormat INSTANCE = new FfiConverterTypePushFormat();

    public override PushFormat Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PushFormat), value))
        {
            return (PushFormat)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypePushFormat.Read()", value)
            );
        }
    }

    public override int AllocationSize(PushFormat value)
    {
        return 4;
    }

    public override void Write(PushFormat value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record PusherKind
{
    public record Http(HttpPusherData @data) : PusherKind { }

    public record Email : PusherKind { }
}

class FfiConverterTypePusherKind : FfiConverterRustBuffer<PusherKind>
{
    public static FfiConverterRustBuffer<PusherKind> INSTANCE = new FfiConverterTypePusherKind();

    public override PusherKind Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new PusherKind.Http(FfiConverterTypeHttpPusherData.INSTANCE.Read(stream));
            case 2:
                return new PusherKind.Email();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypePusherKind.Read()", value)
                );
        }
    }

    public override int AllocationSize(PusherKind value)
    {
        switch (value)
        {
            case PusherKind.Http variant_value:
                return 4 + FfiConverterTypeHttpPusherData.INSTANCE.AllocationSize(variant_value.@data);
            case PusherKind.Email variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypePusherKind.AllocationSize()", value)
                );
        }
    }

    public override void Write(PusherKind value, BigEndianStream stream)
    {
        switch (value)
        {
            case PusherKind.Http variant_value:
                stream.WriteInt(1);
                FfiConverterTypeHttpPusherData.INSTANCE.Write(variant_value.@data, stream);
                break;
            case PusherKind.Email variant_value:
                stream.WriteInt(2);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypePusherKind.Write()", value)
                );
        }
    }
}

/// <summary>
/// Error type for the decoding of the [`QrCodeData`].
/// </summary>
internal class QrCodeDecodeException : UniffiException
{
    QrCodeDecodeException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class Crypto : QrCodeDecodeException
    {
        public Crypto(string message)
            : base(message) { }
    }
}

class FfiConverterTypeQrCodeDecodeError
    : FfiConverterRustBuffer<QrCodeDecodeException>,
        CallStatusErrorHandler<QrCodeDecodeException>
{
    public static FfiConverterTypeQrCodeDecodeError INSTANCE = new FfiConverterTypeQrCodeDecodeError();

    public override QrCodeDecodeException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new QrCodeDecodeException.Crypto(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeQrCodeDecodeError.Read()", value)
                );
        }
    }

    public override int AllocationSize(QrCodeDecodeException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(QrCodeDecodeException value, BigEndianStream stream)
    {
        switch (value)
        {
            case QrCodeDecodeException.Crypto:
                stream.WriteInt(1);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeQrCodeDecodeError.Write()", value)
                );
        }
    }
}

/// <summary>
/// Enum describing the progress of the QR-code login.
/// </summary>
internal record QrLoginProgress
{
    /// <summary>
    /// The login process is starting.
    /// </summary>
    public record Starting : QrLoginProgress { }

    /// <summary>
    /// We established a secure channel with the other device.
    /// </summary>
    public record EstablishingSecureChannel(byte @checkCode, string @checkCodeString) : QrLoginProgress { }

    /// <summary>
    /// We are waiting for the login and for the OAuth 2.0 authorization server
    /// to give us an access token.
    /// </summary>
    public record WaitingForToken(string @userCode) : QrLoginProgress { }

    /// <summary>
    /// The login has successfully finished.
    /// </summary>
    public record Done : QrLoginProgress { }
}

class FfiConverterTypeQrLoginProgress : FfiConverterRustBuffer<QrLoginProgress>
{
    public static FfiConverterRustBuffer<QrLoginProgress> INSTANCE = new FfiConverterTypeQrLoginProgress();

    public override QrLoginProgress Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new QrLoginProgress.Starting();
            case 2:
                return new QrLoginProgress.EstablishingSecureChannel(
                    FfiConverterUInt8.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new QrLoginProgress.WaitingForToken(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new QrLoginProgress.Done();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeQrLoginProgress.Read()", value)
                );
        }
    }

    public override int AllocationSize(QrLoginProgress value)
    {
        switch (value)
        {
            case QrLoginProgress.Starting variant_value:
                return 4;
            case QrLoginProgress.EstablishingSecureChannel variant_value:
                return 4
                    + FfiConverterUInt8.INSTANCE.AllocationSize(variant_value.@checkCode)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@checkCodeString);
            case QrLoginProgress.WaitingForToken variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@userCode);
            case QrLoginProgress.Done variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeQrLoginProgress.AllocationSize()", value)
                );
        }
    }

    public override void Write(QrLoginProgress value, BigEndianStream stream)
    {
        switch (value)
        {
            case QrLoginProgress.Starting variant_value:
                stream.WriteInt(1);
                break;
            case QrLoginProgress.EstablishingSecureChannel variant_value:
                stream.WriteInt(2);
                FfiConverterUInt8.INSTANCE.Write(variant_value.@checkCode, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@checkCodeString, stream);
                break;
            case QrLoginProgress.WaitingForToken variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@userCode, stream);
                break;
            case QrLoginProgress.Done variant_value:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeQrLoginProgress.Write()", value)
                );
        }
    }
}

/// <summary>
/// Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
/// String.
///
/// Represent a failed to send unrecoverable error of an event sent via the
/// send_queue. It is a serializable representation of a client error, see
/// `From` implementation for more details. These errors can not be
/// automatically retried, but yet some manual action can be taken before retry
/// sending. If not the only solution is to delete the local event.
/// </summary>
internal record QueueWedgeError
{
    /// <summary>
    /// This error occurs when there are some insecure devices in the room, and
    /// the current encryption setting prohibit sharing with them.
    /// </summary>
    public record InsecureDevices(Dictionary<string, List<string>> @userDeviceMap) : QueueWedgeError { }

    /// <summary>
    /// This error occurs when a previously verified user is not anymore, and
    /// the current encryption setting prohibit sharing when it happens.
    /// </summary>
    public record IdentityViolations(List<string> @users) : QueueWedgeError { }

    /// <summary>
    /// It is required to set up cross-signing and properly erify the current
    /// session before sending.
    /// </summary>
    public record CrossVerificationRequired : QueueWedgeError { }

    /// <summary>
    /// Some media content to be sent has disappeared from the cache.
    /// </summary>
    public record MissingMediaContent : QueueWedgeError { }

    /// <summary>
    /// Some mime type couldn't be parsed.
    /// </summary>
    public record InvalidMimeType(string @mimeType) : QueueWedgeError { }

    /// <summary>
    /// Other errors.
    /// </summary>
    public record GenericApiError(string @msg) : QueueWedgeError { }
}

class FfiConverterTypeQueueWedgeError : FfiConverterRustBuffer<QueueWedgeError>
{
    public static FfiConverterRustBuffer<QueueWedgeError> INSTANCE = new FfiConverterTypeQueueWedgeError();

    public override QueueWedgeError Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new QueueWedgeError.InsecureDevices(
                    FfiConverterDictionaryStringSequenceString.INSTANCE.Read(stream)
                );
            case 2:
                return new QueueWedgeError.IdentityViolations(FfiConverterSequenceString.INSTANCE.Read(stream));
            case 3:
                return new QueueWedgeError.CrossVerificationRequired();
            case 4:
                return new QueueWedgeError.MissingMediaContent();
            case 5:
                return new QueueWedgeError.InvalidMimeType(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new QueueWedgeError.GenericApiError(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeQueueWedgeError.Read()", value)
                );
        }
    }

    public override int AllocationSize(QueueWedgeError value)
    {
        switch (value)
        {
            case QueueWedgeError.InsecureDevices variant_value:
                return 4
                    + FfiConverterDictionaryStringSequenceString.INSTANCE.AllocationSize(variant_value.@userDeviceMap);
            case QueueWedgeError.IdentityViolations variant_value:
                return 4 + FfiConverterSequenceString.INSTANCE.AllocationSize(variant_value.@users);
            case QueueWedgeError.CrossVerificationRequired variant_value:
                return 4;
            case QueueWedgeError.MissingMediaContent variant_value:
                return 4;
            case QueueWedgeError.InvalidMimeType variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@mimeType);
            case QueueWedgeError.GenericApiError variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeQueueWedgeError.AllocationSize()", value)
                );
        }
    }

    public override void Write(QueueWedgeError value, BigEndianStream stream)
    {
        switch (value)
        {
            case QueueWedgeError.InsecureDevices variant_value:
                stream.WriteInt(1);
                FfiConverterDictionaryStringSequenceString.INSTANCE.Write(variant_value.@userDeviceMap, stream);
                break;
            case QueueWedgeError.IdentityViolations variant_value:
                stream.WriteInt(2);
                FfiConverterSequenceString.INSTANCE.Write(variant_value.@users, stream);
                break;
            case QueueWedgeError.CrossVerificationRequired variant_value:
                stream.WriteInt(3);
                break;
            case QueueWedgeError.MissingMediaContent variant_value:
                stream.WriteInt(4);
                break;
            case QueueWedgeError.InvalidMimeType variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@mimeType, stream);
                break;
            case QueueWedgeError.GenericApiError variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeQueueWedgeError.Write()", value)
                );
        }
    }
}

/// <summary>
/// A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
/// </summary>
internal enum ReceiptType : int
{
    Read,
    ReadPrivate,
    FullyRead,
}

class FfiConverterTypeReceiptType : FfiConverterRustBuffer<ReceiptType>
{
    public static FfiConverterTypeReceiptType INSTANCE = new FfiConverterTypeReceiptType();

    public override ReceiptType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(ReceiptType), value))
        {
            return (ReceiptType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeReceiptType.Read()", value)
            );
        }
    }

    public override int AllocationSize(ReceiptType value)
    {
        return 4;
    }

    public override void Write(ReceiptType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal class RecoveryException : UniffiException
{
    RecoveryException()
        : base() { }

    RecoveryException(String @Message)
        : base(@Message) { }

    // Each variant is a nested class

    /// <summary>
    /// A backup already exists on the homeserver, the recovery subsystem does
    /// not allow backups to be overwritten, disable recovery first.
    /// </summary>
    public class BackupExistsOnServer : RecoveryException
    {
        public BackupExistsOnServer()
            : base() { }
    }

    /// <summary>
    /// A typical SDK error.
    /// </summary>
    public class Client : RecoveryException
    {
        // Members
        public ClientException @source;

        // Constructor
        public Client(ClientException @source)
            : base("@source" + "=" + @source)
        {
            this.@source = @source;
        }
    }

    /// <summary>
    /// Error in the secret storage subsystem.
    /// </summary>
    public class SecretStorage : RecoveryException
    {
        // Members
        public string @errorMessage;

        // Constructor
        public SecretStorage(string @errorMessage)
            : base("@errorMessage" + "=" + @errorMessage)
        {
            this.@errorMessage = @errorMessage;
        }
    }
}

class FfiConverterTypeRecoveryError
    : FfiConverterRustBuffer<RecoveryException>,
        CallStatusErrorHandler<RecoveryException>
{
    public static FfiConverterTypeRecoveryError INSTANCE = new FfiConverterTypeRecoveryError();

    public override RecoveryException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RecoveryException.BackupExistsOnServer();
            case 2:
                return new RecoveryException.Client(FfiConverterTypeClientError.INSTANCE.Read(stream));
            case 3:
                return new RecoveryException.SecretStorage(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRecoveryError.Read()", value)
                );
        }
    }

    public override int AllocationSize(RecoveryException value)
    {
        switch (value)
        {
            case RecoveryException.BackupExistsOnServer variant_value:
                return 4;

            case RecoveryException.Client variant_value:
                return 4 + FfiConverterTypeClientError.INSTANCE.AllocationSize(variant_value.@source);

            case RecoveryException.SecretStorage variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@errorMessage);
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRecoveryError.AllocationSize()", value)
                );
        }
    }

    public override void Write(RecoveryException value, BigEndianStream stream)
    {
        switch (value)
        {
            case RecoveryException.BackupExistsOnServer variant_value:
                stream.WriteInt(1);
                break;
            case RecoveryException.Client variant_value:
                stream.WriteInt(2);
                FfiConverterTypeClientError.INSTANCE.Write(variant_value.@source, stream);
                break;
            case RecoveryException.SecretStorage variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@errorMessage, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRecoveryError.Write()", value)
                );
        }
    }
}

internal enum RecoveryState : int
{
    Unknown,
    Enabled,
    Disabled,
    Incomplete,
}

class FfiConverterTypeRecoveryState : FfiConverterRustBuffer<RecoveryState>
{
    public static FfiConverterTypeRecoveryState INSTANCE = new FfiConverterTypeRecoveryState();

    public override RecoveryState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RecoveryState), value))
        {
            return (RecoveryState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRecoveryState.Read()", value)
            );
        }
    }

    public override int AllocationSize(RecoveryState value)
    {
        return 4;
    }

    public override void Write(RecoveryState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record RepliedToEventDetails : IDisposable
{
    public record Unavailable : RepliedToEventDetails { }

    public record Pending : RepliedToEventDetails { }

    public record Ready(TimelineItemContent @content, string @sender, ProfileDetails @senderProfile)
        : RepliedToEventDetails { }

    public record Error(string @message) : RepliedToEventDetails { }

    public void Dispose()
    {
        switch (this)
        {
            case RepliedToEventDetails.Unavailable variant_value:
                break;
            case RepliedToEventDetails.Pending variant_value:
                break;
            case RepliedToEventDetails.Ready variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content, variant_value.@sender, variant_value.@senderProfile);
                break;
            case RepliedToEventDetails.Error variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@message);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in RepliedToEventDetails.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeRepliedToEventDetails : FfiConverterRustBuffer<RepliedToEventDetails>
{
    public static FfiConverterRustBuffer<RepliedToEventDetails> INSTANCE = new FfiConverterTypeRepliedToEventDetails();

    public override RepliedToEventDetails Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RepliedToEventDetails.Unavailable();
            case 2:
                return new RepliedToEventDetails.Pending();
            case 3:
                return new RepliedToEventDetails.Ready(
                    FfiConverterTypeTimelineItemContent.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeProfileDetails.INSTANCE.Read(stream)
                );
            case 4:
                return new RepliedToEventDetails.Error(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRepliedToEventDetails.Read()", value)
                );
        }
    }

    public override int AllocationSize(RepliedToEventDetails value)
    {
        switch (value)
        {
            case RepliedToEventDetails.Unavailable variant_value:
                return 4;
            case RepliedToEventDetails.Pending variant_value:
                return 4;
            case RepliedToEventDetails.Ready variant_value:
                return 4
                    + FfiConverterTypeTimelineItemContent.INSTANCE.AllocationSize(variant_value.@content)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@sender)
                    + FfiConverterTypeProfileDetails.INSTANCE.AllocationSize(variant_value.@senderProfile);
            case RepliedToEventDetails.Error variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRepliedToEventDetails.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RepliedToEventDetails value, BigEndianStream stream)
    {
        switch (value)
        {
            case RepliedToEventDetails.Unavailable variant_value:
                stream.WriteInt(1);
                break;
            case RepliedToEventDetails.Pending variant_value:
                stream.WriteInt(2);
                break;
            case RepliedToEventDetails.Ready variant_value:
                stream.WriteInt(3);
                FfiConverterTypeTimelineItemContent.INSTANCE.Write(variant_value.@content, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@sender, stream);
                FfiConverterTypeProfileDetails.INSTANCE.Write(variant_value.@senderProfile, stream);
                break;
            case RepliedToEventDetails.Error variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRepliedToEventDetails.Write()", value)
                );
        }
    }
}

internal record RoomDirectorySearchEntryUpdate
{
    public record Append(List<RoomDescription> @values) : RoomDirectorySearchEntryUpdate { }

    public record Clear : RoomDirectorySearchEntryUpdate { }

    public record PushFront(RoomDescription @value) : RoomDirectorySearchEntryUpdate { }

    public record PushBack(RoomDescription @value) : RoomDirectorySearchEntryUpdate { }

    public record PopFront : RoomDirectorySearchEntryUpdate { }

    public record PopBack : RoomDirectorySearchEntryUpdate { }

    public record Insert(uint @index, RoomDescription @value) : RoomDirectorySearchEntryUpdate { }

    public record Set(uint @index, RoomDescription @value) : RoomDirectorySearchEntryUpdate { }

    public record Remove(uint @index) : RoomDirectorySearchEntryUpdate { }

    public record Truncate(uint @length) : RoomDirectorySearchEntryUpdate { }

    public record Reset(List<RoomDescription> @values) : RoomDirectorySearchEntryUpdate { }
}

class FfiConverterTypeRoomDirectorySearchEntryUpdate : FfiConverterRustBuffer<RoomDirectorySearchEntryUpdate>
{
    public static FfiConverterRustBuffer<RoomDirectorySearchEntryUpdate> INSTANCE =
        new FfiConverterTypeRoomDirectorySearchEntryUpdate();

    public override RoomDirectorySearchEntryUpdate Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomDirectorySearchEntryUpdate.Append(
                    FfiConverterSequenceTypeRoomDescription.INSTANCE.Read(stream)
                );
            case 2:
                return new RoomDirectorySearchEntryUpdate.Clear();
            case 3:
                return new RoomDirectorySearchEntryUpdate.PushFront(
                    FfiConverterTypeRoomDescription.INSTANCE.Read(stream)
                );
            case 4:
                return new RoomDirectorySearchEntryUpdate.PushBack(
                    FfiConverterTypeRoomDescription.INSTANCE.Read(stream)
                );
            case 5:
                return new RoomDirectorySearchEntryUpdate.PopFront();
            case 6:
                return new RoomDirectorySearchEntryUpdate.PopBack();
            case 7:
                return new RoomDirectorySearchEntryUpdate.Insert(
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterTypeRoomDescription.INSTANCE.Read(stream)
                );
            case 8:
                return new RoomDirectorySearchEntryUpdate.Set(
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterTypeRoomDescription.INSTANCE.Read(stream)
                );
            case 9:
                return new RoomDirectorySearchEntryUpdate.Remove(FfiConverterUInt32.INSTANCE.Read(stream));
            case 10:
                return new RoomDirectorySearchEntryUpdate.Truncate(FfiConverterUInt32.INSTANCE.Read(stream));
            case 11:
                return new RoomDirectorySearchEntryUpdate.Reset(
                    FfiConverterSequenceTypeRoomDescription.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomDirectorySearchEntryUpdate.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(RoomDirectorySearchEntryUpdate value)
    {
        switch (value)
        {
            case RoomDirectorySearchEntryUpdate.Append variant_value:
                return 4 + FfiConverterSequenceTypeRoomDescription.INSTANCE.AllocationSize(variant_value.@values);
            case RoomDirectorySearchEntryUpdate.Clear variant_value:
                return 4;
            case RoomDirectorySearchEntryUpdate.PushFront variant_value:
                return 4 + FfiConverterTypeRoomDescription.INSTANCE.AllocationSize(variant_value.@value);
            case RoomDirectorySearchEntryUpdate.PushBack variant_value:
                return 4 + FfiConverterTypeRoomDescription.INSTANCE.AllocationSize(variant_value.@value);
            case RoomDirectorySearchEntryUpdate.PopFront variant_value:
                return 4;
            case RoomDirectorySearchEntryUpdate.PopBack variant_value:
                return 4;
            case RoomDirectorySearchEntryUpdate.Insert variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@index)
                    + FfiConverterTypeRoomDescription.INSTANCE.AllocationSize(variant_value.@value);
            case RoomDirectorySearchEntryUpdate.Set variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@index)
                    + FfiConverterTypeRoomDescription.INSTANCE.AllocationSize(variant_value.@value);
            case RoomDirectorySearchEntryUpdate.Remove variant_value:
                return 4 + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@index);
            case RoomDirectorySearchEntryUpdate.Truncate variant_value:
                return 4 + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@length);
            case RoomDirectorySearchEntryUpdate.Reset variant_value:
                return 4 + FfiConverterSequenceTypeRoomDescription.INSTANCE.AllocationSize(variant_value.@values);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomDirectorySearchEntryUpdate.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RoomDirectorySearchEntryUpdate value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomDirectorySearchEntryUpdate.Append variant_value:
                stream.WriteInt(1);
                FfiConverterSequenceTypeRoomDescription.INSTANCE.Write(variant_value.@values, stream);
                break;
            case RoomDirectorySearchEntryUpdate.Clear variant_value:
                stream.WriteInt(2);
                break;
            case RoomDirectorySearchEntryUpdate.PushFront variant_value:
                stream.WriteInt(3);
                FfiConverterTypeRoomDescription.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomDirectorySearchEntryUpdate.PushBack variant_value:
                stream.WriteInt(4);
                FfiConverterTypeRoomDescription.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomDirectorySearchEntryUpdate.PopFront variant_value:
                stream.WriteInt(5);
                break;
            case RoomDirectorySearchEntryUpdate.PopBack variant_value:
                stream.WriteInt(6);
                break;
            case RoomDirectorySearchEntryUpdate.Insert variant_value:
                stream.WriteInt(7);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@index, stream);
                FfiConverterTypeRoomDescription.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomDirectorySearchEntryUpdate.Set variant_value:
                stream.WriteInt(8);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@index, stream);
                FfiConverterTypeRoomDescription.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomDirectorySearchEntryUpdate.Remove variant_value:
                stream.WriteInt(9);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@index, stream);
                break;
            case RoomDirectorySearchEntryUpdate.Truncate variant_value:
                stream.WriteInt(10);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@length, stream);
                break;
            case RoomDirectorySearchEntryUpdate.Reset variant_value:
                stream.WriteInt(11);
                FfiConverterSequenceTypeRoomDescription.INSTANCE.Write(variant_value.@values, stream);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomDirectorySearchEntryUpdate.Write()",
                        value
                    )
                );
        }
    }
}

internal class RoomException : UniffiException
{
    RoomException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class InvalidAttachmentData : RoomException
    {
        public InvalidAttachmentData(string message)
            : base(message) { }
    }

    public class InvalidAttachmentMimeType : RoomException
    {
        public InvalidAttachmentMimeType(string message)
            : base(message) { }
    }

    public class InvalidMediaInfo : RoomException
    {
        public InvalidMediaInfo(string message)
            : base(message) { }
    }

    public class TimelineUnavailable : RoomException
    {
        public TimelineUnavailable(string message)
            : base(message) { }
    }

    public class InvalidThumbnailData : RoomException
    {
        public InvalidThumbnailData(string message)
            : base(message) { }
    }

    public class InvalidRepliedToEventId : RoomException
    {
        public InvalidRepliedToEventId(string message)
            : base(message) { }
    }

    public class FailedSendingAttachment : RoomException
    {
        public FailedSendingAttachment(string message)
            : base(message) { }
    }
}

class FfiConverterTypeRoomError : FfiConverterRustBuffer<RoomException>, CallStatusErrorHandler<RoomException>
{
    public static FfiConverterTypeRoomError INSTANCE = new FfiConverterTypeRoomError();

    public override RoomException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomException.InvalidAttachmentData(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new RoomException.InvalidAttachmentMimeType(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new RoomException.InvalidMediaInfo(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new RoomException.TimelineUnavailable(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new RoomException.InvalidThumbnailData(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new RoomException.InvalidRepliedToEventId(FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new RoomException.FailedSendingAttachment(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRoomError.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(RoomException value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomException.InvalidAttachmentData:
                stream.WriteInt(1);
                break;
            case RoomException.InvalidAttachmentMimeType:
                stream.WriteInt(2);
                break;
            case RoomException.InvalidMediaInfo:
                stream.WriteInt(3);
                break;
            case RoomException.TimelineUnavailable:
                stream.WriteInt(4);
                break;
            case RoomException.InvalidThumbnailData:
                stream.WriteInt(5);
                break;
            case RoomException.InvalidRepliedToEventId:
                stream.WriteInt(6);
                break;
            case RoomException.FailedSendingAttachment:
                stream.WriteInt(7);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRoomError.Write()", value)
                );
        }
    }
}

internal record RoomHistoryVisibility
{
    /// <summary>
    /// Previous events are accessible to newly joined members from the point
    /// they were invited onwards.
    ///
    /// Events stop being accessible when the member's state changes to
    /// something other than *invite* or *join*.
    /// </summary>
    public record Invited : RoomHistoryVisibility { }

    /// <summary>
    /// Previous events are accessible to newly joined members from the point
    /// they joined the room onwards.
    /// Events stop being accessible when the member's state changes to
    /// something other than *join*.
    /// </summary>
    public record Joined : RoomHistoryVisibility { }

    /// <summary>
    /// Previous events are always accessible to newly joined members.
    ///
    /// All events in the room are accessible, even those sent when the member
    /// was not a part of the room.
    /// </summary>
    public record Shared : RoomHistoryVisibility { }

    /// <summary>
    /// All events while this is the `HistoryVisibility` value may be shared by
    /// any participating homeserver with anyone, regardless of whether they
    /// have ever joined the room.
    /// </summary>
    public record WorldReadable : RoomHistoryVisibility { }

    /// <summary>
    /// A custom visibility value.
    /// </summary>
    public record Custom(string @value) : RoomHistoryVisibility { }
}

class FfiConverterTypeRoomHistoryVisibility : FfiConverterRustBuffer<RoomHistoryVisibility>
{
    public static FfiConverterRustBuffer<RoomHistoryVisibility> INSTANCE = new FfiConverterTypeRoomHistoryVisibility();

    public override RoomHistoryVisibility Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomHistoryVisibility.Invited();
            case 2:
                return new RoomHistoryVisibility.Joined();
            case 3:
                return new RoomHistoryVisibility.Shared();
            case 4:
                return new RoomHistoryVisibility.WorldReadable();
            case 5:
                return new RoomHistoryVisibility.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomHistoryVisibility.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomHistoryVisibility value)
    {
        switch (value)
        {
            case RoomHistoryVisibility.Invited variant_value:
                return 4;
            case RoomHistoryVisibility.Joined variant_value:
                return 4;
            case RoomHistoryVisibility.Shared variant_value:
                return 4;
            case RoomHistoryVisibility.WorldReadable variant_value:
                return 4;
            case RoomHistoryVisibility.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomHistoryVisibility.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RoomHistoryVisibility value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomHistoryVisibility.Invited variant_value:
                stream.WriteInt(1);
                break;
            case RoomHistoryVisibility.Joined variant_value:
                stream.WriteInt(2);
                break;
            case RoomHistoryVisibility.Shared variant_value:
                stream.WriteInt(3);
                break;
            case RoomHistoryVisibility.WorldReadable variant_value:
                stream.WriteInt(4);
                break;
            case RoomHistoryVisibility.Custom variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomHistoryVisibility.Write()", value)
                );
        }
    }
}

internal record RoomListEntriesDynamicFilterKind
{
    public record All(List<RoomListEntriesDynamicFilterKind> @filters) : RoomListEntriesDynamicFilterKind { }

    public record Any(List<RoomListEntriesDynamicFilterKind> @filters) : RoomListEntriesDynamicFilterKind { }

    public record NonLeft : RoomListEntriesDynamicFilterKind { }

    public record Joined : RoomListEntriesDynamicFilterKind { }

    public record Unread : RoomListEntriesDynamicFilterKind { }

    public record Favourite : RoomListEntriesDynamicFilterKind { }

    public record Invite : RoomListEntriesDynamicFilterKind { }

    public record Category(RoomListFilterCategory @expect) : RoomListEntriesDynamicFilterKind { }

    public record None : RoomListEntriesDynamicFilterKind { }

    public record NormalizedMatchRoomName(string @pattern) : RoomListEntriesDynamicFilterKind { }

    public record FuzzyMatchRoomName(string @pattern) : RoomListEntriesDynamicFilterKind { }
}

class FfiConverterTypeRoomListEntriesDynamicFilterKind : FfiConverterRustBuffer<RoomListEntriesDynamicFilterKind>
{
    public static FfiConverterRustBuffer<RoomListEntriesDynamicFilterKind> INSTANCE =
        new FfiConverterTypeRoomListEntriesDynamicFilterKind();

    public override RoomListEntriesDynamicFilterKind Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomListEntriesDynamicFilterKind.All(
                    FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.INSTANCE.Read(stream)
                );
            case 2:
                return new RoomListEntriesDynamicFilterKind.Any(
                    FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.INSTANCE.Read(stream)
                );
            case 3:
                return new RoomListEntriesDynamicFilterKind.NonLeft();
            case 4:
                return new RoomListEntriesDynamicFilterKind.Joined();
            case 5:
                return new RoomListEntriesDynamicFilterKind.Unread();
            case 6:
                return new RoomListEntriesDynamicFilterKind.Favourite();
            case 7:
                return new RoomListEntriesDynamicFilterKind.Invite();
            case 8:
                return new RoomListEntriesDynamicFilterKind.Category(
                    FfiConverterTypeRoomListFilterCategory.INSTANCE.Read(stream)
                );
            case 9:
                return new RoomListEntriesDynamicFilterKind.None();
            case 10:
                return new RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 11:
                return new RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomListEntriesDynamicFilterKind.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(RoomListEntriesDynamicFilterKind value)
    {
        switch (value)
        {
            case RoomListEntriesDynamicFilterKind.All variant_value:
                return 4
                    + FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.INSTANCE.AllocationSize(
                        variant_value.@filters
                    );
            case RoomListEntriesDynamicFilterKind.Any variant_value:
                return 4
                    + FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.INSTANCE.AllocationSize(
                        variant_value.@filters
                    );
            case RoomListEntriesDynamicFilterKind.NonLeft variant_value:
                return 4;
            case RoomListEntriesDynamicFilterKind.Joined variant_value:
                return 4;
            case RoomListEntriesDynamicFilterKind.Unread variant_value:
                return 4;
            case RoomListEntriesDynamicFilterKind.Favourite variant_value:
                return 4;
            case RoomListEntriesDynamicFilterKind.Invite variant_value:
                return 4;
            case RoomListEntriesDynamicFilterKind.Category variant_value:
                return 4 + FfiConverterTypeRoomListFilterCategory.INSTANCE.AllocationSize(variant_value.@expect);
            case RoomListEntriesDynamicFilterKind.None variant_value:
                return 4;
            case RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@pattern);
            case RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@pattern);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomListEntriesDynamicFilterKind.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RoomListEntriesDynamicFilterKind value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomListEntriesDynamicFilterKind.All variant_value:
                stream.WriteInt(1);
                FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.INSTANCE.Write(variant_value.@filters, stream);
                break;
            case RoomListEntriesDynamicFilterKind.Any variant_value:
                stream.WriteInt(2);
                FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.INSTANCE.Write(variant_value.@filters, stream);
                break;
            case RoomListEntriesDynamicFilterKind.NonLeft variant_value:
                stream.WriteInt(3);
                break;
            case RoomListEntriesDynamicFilterKind.Joined variant_value:
                stream.WriteInt(4);
                break;
            case RoomListEntriesDynamicFilterKind.Unread variant_value:
                stream.WriteInt(5);
                break;
            case RoomListEntriesDynamicFilterKind.Favourite variant_value:
                stream.WriteInt(6);
                break;
            case RoomListEntriesDynamicFilterKind.Invite variant_value:
                stream.WriteInt(7);
                break;
            case RoomListEntriesDynamicFilterKind.Category variant_value:
                stream.WriteInt(8);
                FfiConverterTypeRoomListFilterCategory.INSTANCE.Write(variant_value.@expect, stream);
                break;
            case RoomListEntriesDynamicFilterKind.None variant_value:
                stream.WriteInt(9);
                break;
            case RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName variant_value:
                stream.WriteInt(10);
                FfiConverterString.INSTANCE.Write(variant_value.@pattern, stream);
                break;
            case RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName variant_value:
                stream.WriteInt(11);
                FfiConverterString.INSTANCE.Write(variant_value.@pattern, stream);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomListEntriesDynamicFilterKind.Write()",
                        value
                    )
                );
        }
    }
}

internal record RoomListEntriesUpdate : IDisposable
{
    public record Append(List<RoomListItem> @values) : RoomListEntriesUpdate { }

    public record Clear : RoomListEntriesUpdate { }

    public record PushFront(RoomListItem @value) : RoomListEntriesUpdate { }

    public record PushBack(RoomListItem @value) : RoomListEntriesUpdate { }

    public record PopFront : RoomListEntriesUpdate { }

    public record PopBack : RoomListEntriesUpdate { }

    public record Insert(uint @index, RoomListItem @value) : RoomListEntriesUpdate { }

    public record Set(uint @index, RoomListItem @value) : RoomListEntriesUpdate { }

    public record Remove(uint @index) : RoomListEntriesUpdate { }

    public record Truncate(uint @length) : RoomListEntriesUpdate { }

    public record Reset(List<RoomListItem> @values) : RoomListEntriesUpdate { }

    public void Dispose()
    {
        switch (this)
        {
            case RoomListEntriesUpdate.Append variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@values);
                break;
            case RoomListEntriesUpdate.Clear variant_value:
                break;
            case RoomListEntriesUpdate.PushFront variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@value);
                break;
            case RoomListEntriesUpdate.PushBack variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@value);
                break;
            case RoomListEntriesUpdate.PopFront variant_value:
                break;
            case RoomListEntriesUpdate.PopBack variant_value:
                break;
            case RoomListEntriesUpdate.Insert variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@index, variant_value.@value);
                break;
            case RoomListEntriesUpdate.Set variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@index, variant_value.@value);
                break;
            case RoomListEntriesUpdate.Remove variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@index);
                break;
            case RoomListEntriesUpdate.Truncate variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@length);
                break;
            case RoomListEntriesUpdate.Reset variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@values);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in RoomListEntriesUpdate.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeRoomListEntriesUpdate : FfiConverterRustBuffer<RoomListEntriesUpdate>
{
    public static FfiConverterRustBuffer<RoomListEntriesUpdate> INSTANCE = new FfiConverterTypeRoomListEntriesUpdate();

    public override RoomListEntriesUpdate Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomListEntriesUpdate.Append(FfiConverterSequenceTypeRoomListItem.INSTANCE.Read(stream));
            case 2:
                return new RoomListEntriesUpdate.Clear();
            case 3:
                return new RoomListEntriesUpdate.PushFront(FfiConverterTypeRoomListItem.INSTANCE.Read(stream));
            case 4:
                return new RoomListEntriesUpdate.PushBack(FfiConverterTypeRoomListItem.INSTANCE.Read(stream));
            case 5:
                return new RoomListEntriesUpdate.PopFront();
            case 6:
                return new RoomListEntriesUpdate.PopBack();
            case 7:
                return new RoomListEntriesUpdate.Insert(
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterTypeRoomListItem.INSTANCE.Read(stream)
                );
            case 8:
                return new RoomListEntriesUpdate.Set(
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterTypeRoomListItem.INSTANCE.Read(stream)
                );
            case 9:
                return new RoomListEntriesUpdate.Remove(FfiConverterUInt32.INSTANCE.Read(stream));
            case 10:
                return new RoomListEntriesUpdate.Truncate(FfiConverterUInt32.INSTANCE.Read(stream));
            case 11:
                return new RoomListEntriesUpdate.Reset(FfiConverterSequenceTypeRoomListItem.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListEntriesUpdate.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomListEntriesUpdate value)
    {
        switch (value)
        {
            case RoomListEntriesUpdate.Append variant_value:
                return 4 + FfiConverterSequenceTypeRoomListItem.INSTANCE.AllocationSize(variant_value.@values);
            case RoomListEntriesUpdate.Clear variant_value:
                return 4;
            case RoomListEntriesUpdate.PushFront variant_value:
                return 4 + FfiConverterTypeRoomListItem.INSTANCE.AllocationSize(variant_value.@value);
            case RoomListEntriesUpdate.PushBack variant_value:
                return 4 + FfiConverterTypeRoomListItem.INSTANCE.AllocationSize(variant_value.@value);
            case RoomListEntriesUpdate.PopFront variant_value:
                return 4;
            case RoomListEntriesUpdate.PopBack variant_value:
                return 4;
            case RoomListEntriesUpdate.Insert variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@index)
                    + FfiConverterTypeRoomListItem.INSTANCE.AllocationSize(variant_value.@value);
            case RoomListEntriesUpdate.Set variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@index)
                    + FfiConverterTypeRoomListItem.INSTANCE.AllocationSize(variant_value.@value);
            case RoomListEntriesUpdate.Remove variant_value:
                return 4 + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@index);
            case RoomListEntriesUpdate.Truncate variant_value:
                return 4 + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@length);
            case RoomListEntriesUpdate.Reset variant_value:
                return 4 + FfiConverterSequenceTypeRoomListItem.INSTANCE.AllocationSize(variant_value.@values);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomListEntriesUpdate.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RoomListEntriesUpdate value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomListEntriesUpdate.Append variant_value:
                stream.WriteInt(1);
                FfiConverterSequenceTypeRoomListItem.INSTANCE.Write(variant_value.@values, stream);
                break;
            case RoomListEntriesUpdate.Clear variant_value:
                stream.WriteInt(2);
                break;
            case RoomListEntriesUpdate.PushFront variant_value:
                stream.WriteInt(3);
                FfiConverterTypeRoomListItem.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomListEntriesUpdate.PushBack variant_value:
                stream.WriteInt(4);
                FfiConverterTypeRoomListItem.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomListEntriesUpdate.PopFront variant_value:
                stream.WriteInt(5);
                break;
            case RoomListEntriesUpdate.PopBack variant_value:
                stream.WriteInt(6);
                break;
            case RoomListEntriesUpdate.Insert variant_value:
                stream.WriteInt(7);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@index, stream);
                FfiConverterTypeRoomListItem.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomListEntriesUpdate.Set variant_value:
                stream.WriteInt(8);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@index, stream);
                FfiConverterTypeRoomListItem.INSTANCE.Write(variant_value.@value, stream);
                break;
            case RoomListEntriesUpdate.Remove variant_value:
                stream.WriteInt(9);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@index, stream);
                break;
            case RoomListEntriesUpdate.Truncate variant_value:
                stream.WriteInt(10);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@length, stream);
                break;
            case RoomListEntriesUpdate.Reset variant_value:
                stream.WriteInt(11);
                FfiConverterSequenceTypeRoomListItem.INSTANCE.Write(variant_value.@values, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListEntriesUpdate.Write()", value)
                );
        }
    }
}

internal class RoomListException : UniffiException
{
    RoomListException()
        : base() { }

    RoomListException(String @Message)
        : base(@Message) { }

    // Each variant is a nested class

    public class SlidingSync : RoomListException
    {
        // Members
        public string @error;

        // Constructor
        public SlidingSync(string @error)
            : base("@error" + "=" + @error)
        {
            this.@error = @error;
        }
    }

    public class UnknownList : RoomListException
    {
        // Members
        public string @listName;

        // Constructor
        public UnknownList(string @listName)
            : base("@listName" + "=" + @listName)
        {
            this.@listName = @listName;
        }
    }

    public class InputCannotBeApplied : RoomListException
    {
        public InputCannotBeApplied()
            : base() { }
    }

    public class RoomNotFound : RoomListException
    {
        // Members
        public string @roomName;

        // Constructor
        public RoomNotFound(string @roomName)
            : base("@roomName" + "=" + @roomName)
        {
            this.@roomName = @roomName;
        }
    }

    public class InvalidRoomId : RoomListException
    {
        // Members
        public string @error;

        // Constructor
        public InvalidRoomId(string @error)
            : base("@error" + "=" + @error)
        {
            this.@error = @error;
        }
    }

    public class TimelineAlreadyExists : RoomListException
    {
        // Members
        public string @roomName;

        // Constructor
        public TimelineAlreadyExists(string @roomName)
            : base("@roomName" + "=" + @roomName)
        {
            this.@roomName = @roomName;
        }
    }

    public class TimelineNotInitialized : RoomListException
    {
        // Members
        public string @roomName;

        // Constructor
        public TimelineNotInitialized(string @roomName)
            : base("@roomName" + "=" + @roomName)
        {
            this.@roomName = @roomName;
        }
    }

    public class InitializingTimeline : RoomListException
    {
        // Members
        public string @error;

        // Constructor
        public InitializingTimeline(string @error)
            : base("@error" + "=" + @error)
        {
            this.@error = @error;
        }
    }

    public class EventCache : RoomListException
    {
        // Members
        public string @error;

        // Constructor
        public EventCache(string @error)
            : base("@error" + "=" + @error)
        {
            this.@error = @error;
        }
    }

    public class IncorrectRoomMembership : RoomListException
    {
        // Members
        public List<Membership> @expected;
        public Membership @actual;

        // Constructor
        public IncorrectRoomMembership(List<Membership> @expected, Membership @actual)
            : base("@expected" + "=" + @expected + ", " + "@actual" + "=" + @actual)
        {
            this.@expected = @expected;

            this.@actual = @actual;
        }
    }
}

class FfiConverterTypeRoomListError
    : FfiConverterRustBuffer<RoomListException>,
        CallStatusErrorHandler<RoomListException>
{
    public static FfiConverterTypeRoomListError INSTANCE = new FfiConverterTypeRoomListError();

    public override RoomListException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomListException.SlidingSync(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new RoomListException.UnknownList(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new RoomListException.InputCannotBeApplied();
            case 4:
                return new RoomListException.RoomNotFound(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new RoomListException.InvalidRoomId(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new RoomListException.TimelineAlreadyExists(FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new RoomListException.TimelineNotInitialized(FfiConverterString.INSTANCE.Read(stream));
            case 8:
                return new RoomListException.InitializingTimeline(FfiConverterString.INSTANCE.Read(stream));
            case 9:
                return new RoomListException.EventCache(FfiConverterString.INSTANCE.Read(stream));
            case 10:
                return new RoomListException.IncorrectRoomMembership(
                    FfiConverterSequenceTypeMembership.INSTANCE.Read(stream),
                    FfiConverterTypeMembership.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRoomListError.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomListException value)
    {
        switch (value)
        {
            case RoomListException.SlidingSync variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@error);

            case RoomListException.UnknownList variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@listName);

            case RoomListException.InputCannotBeApplied variant_value:
                return 4;

            case RoomListException.RoomNotFound variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomName);

            case RoomListException.InvalidRoomId variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@error);

            case RoomListException.TimelineAlreadyExists variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomName);

            case RoomListException.TimelineNotInitialized variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomName);

            case RoomListException.InitializingTimeline variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@error);

            case RoomListException.EventCache variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@error);

            case RoomListException.IncorrectRoomMembership variant_value:
                return 4
                    + FfiConverterSequenceTypeMembership.INSTANCE.AllocationSize(variant_value.@expected)
                    + FfiConverterTypeMembership.INSTANCE.AllocationSize(variant_value.@actual);
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRoomListError.AllocationSize()", value)
                );
        }
    }

    public override void Write(RoomListException value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomListException.SlidingSync variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@error, stream);
                break;
            case RoomListException.UnknownList variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@listName, stream);
                break;
            case RoomListException.InputCannotBeApplied variant_value:
                stream.WriteInt(3);
                break;
            case RoomListException.RoomNotFound variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@roomName, stream);
                break;
            case RoomListException.InvalidRoomId variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@error, stream);
                break;
            case RoomListException.TimelineAlreadyExists variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@roomName, stream);
                break;
            case RoomListException.TimelineNotInitialized variant_value:
                stream.WriteInt(7);
                FfiConverterString.INSTANCE.Write(variant_value.@roomName, stream);
                break;
            case RoomListException.InitializingTimeline variant_value:
                stream.WriteInt(8);
                FfiConverterString.INSTANCE.Write(variant_value.@error, stream);
                break;
            case RoomListException.EventCache variant_value:
                stream.WriteInt(9);
                FfiConverterString.INSTANCE.Write(variant_value.@error, stream);
                break;
            case RoomListException.IncorrectRoomMembership variant_value:
                stream.WriteInt(10);
                FfiConverterSequenceTypeMembership.INSTANCE.Write(variant_value.@expected, stream);
                FfiConverterTypeMembership.INSTANCE.Write(variant_value.@actual, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeRoomListError.Write()", value)
                );
        }
    }
}

internal enum RoomListFilterCategory : int
{
    Group,
    People,
}

class FfiConverterTypeRoomListFilterCategory : FfiConverterRustBuffer<RoomListFilterCategory>
{
    public static FfiConverterTypeRoomListFilterCategory INSTANCE = new FfiConverterTypeRoomListFilterCategory();

    public override RoomListFilterCategory Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RoomListFilterCategory), value))
        {
            return (RoomListFilterCategory)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListFilterCategory.Read()", value)
            );
        }
    }

    public override int AllocationSize(RoomListFilterCategory value)
    {
        return 4;
    }

    public override void Write(RoomListFilterCategory value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record RoomListLoadingState
{
    public record NotLoaded : RoomListLoadingState { }

    public record Loaded(uint? @maximumNumberOfRooms) : RoomListLoadingState { }
}

class FfiConverterTypeRoomListLoadingState : FfiConverterRustBuffer<RoomListLoadingState>
{
    public static FfiConverterRustBuffer<RoomListLoadingState> INSTANCE = new FfiConverterTypeRoomListLoadingState();

    public override RoomListLoadingState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomListLoadingState.NotLoaded();
            case 2:
                return new RoomListLoadingState.Loaded(FfiConverterOptionalUInt32.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListLoadingState.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomListLoadingState value)
    {
        switch (value)
        {
            case RoomListLoadingState.NotLoaded variant_value:
                return 4;
            case RoomListLoadingState.Loaded variant_value:
                return 4 + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(variant_value.@maximumNumberOfRooms);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomListLoadingState.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RoomListLoadingState value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomListLoadingState.NotLoaded variant_value:
                stream.WriteInt(1);
                break;
            case RoomListLoadingState.Loaded variant_value:
                stream.WriteInt(2);
                FfiConverterOptionalUInt32.INSTANCE.Write(variant_value.@maximumNumberOfRooms, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListLoadingState.Write()", value)
                );
        }
    }
}

internal enum RoomListServiceState : int
{
    Initial,
    SettingUp,
    Recovering,
    Running,
    Error,
    Terminated,
}

class FfiConverterTypeRoomListServiceState : FfiConverterRustBuffer<RoomListServiceState>
{
    public static FfiConverterTypeRoomListServiceState INSTANCE = new FfiConverterTypeRoomListServiceState();

    public override RoomListServiceState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RoomListServiceState), value))
        {
            return (RoomListServiceState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListServiceState.Read()", value)
            );
        }
    }

    public override int AllocationSize(RoomListServiceState value)
    {
        return 4;
    }

    public override void Write(RoomListServiceState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal enum RoomListServiceSyncIndicator : int
{
    Show,
    Hide,
}

class FfiConverterTypeRoomListServiceSyncIndicator : FfiConverterRustBuffer<RoomListServiceSyncIndicator>
{
    public static FfiConverterTypeRoomListServiceSyncIndicator INSTANCE =
        new FfiConverterTypeRoomListServiceSyncIndicator();

    public override RoomListServiceSyncIndicator Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RoomListServiceSyncIndicator), value))
        {
            return (RoomListServiceSyncIndicator)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRoomListServiceSyncIndicator.Read()", value)
            );
        }
    }

    public override int AllocationSize(RoomListServiceSyncIndicator value)
    {
        return 4;
    }

    public override void Write(RoomListServiceSyncIndicator value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// Configure how many rooms will be restored when restoring the session with
/// [`Client::restore_session_with`].
///
/// Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
/// learn more.
/// </summary>
internal record RoomLoadSettings
{
    /// <summary>
    /// Load all rooms from the `StateStore` into the in-memory state store
    /// `BaseStateStore`.
    /// </summary>
    public record All : RoomLoadSettings { }

    /// <summary>
    /// Load a single room from the `StateStore` into the in-memory state
    /// store `BaseStateStore`.
    ///
    /// Please, be careful with this option. Read the documentation of
    /// [`RoomLoadSettings`].
    /// </summary>
    public record One(string @roomId) : RoomLoadSettings { }
}

class FfiConverterTypeRoomLoadSettings : FfiConverterRustBuffer<RoomLoadSettings>
{
    public static FfiConverterRustBuffer<RoomLoadSettings> INSTANCE = new FfiConverterTypeRoomLoadSettings();

    public override RoomLoadSettings Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomLoadSettings.All();
            case 2:
                return new RoomLoadSettings.One(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomLoadSettings.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomLoadSettings value)
    {
        switch (value)
        {
            case RoomLoadSettings.All variant_value:
                return 4;
            case RoomLoadSettings.One variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@roomId);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeRoomLoadSettings.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(RoomLoadSettings value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomLoadSettings.All variant_value:
                stream.WriteInt(1);
                break;
            case RoomLoadSettings.One variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@roomId, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomLoadSettings.Write()", value)
                );
        }
    }
}

internal enum RoomMessageEventMessageType : int
{
    Audio,
    Emote,
    File,
    Image,
    Location,
    Notice,
    ServerNotice,
    Text,
    Video,
    VerificationRequest,
    Other,
}

class FfiConverterTypeRoomMessageEventMessageType : FfiConverterRustBuffer<RoomMessageEventMessageType>
{
    public static FfiConverterTypeRoomMessageEventMessageType INSTANCE =
        new FfiConverterTypeRoomMessageEventMessageType();

    public override RoomMessageEventMessageType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RoomMessageEventMessageType), value))
        {
            return (RoomMessageEventMessageType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRoomMessageEventMessageType.Read()", value)
            );
        }
    }

    public override int AllocationSize(RoomMessageEventMessageType value)
    {
        return 4;
    }

    public override void Write(RoomMessageEventMessageType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// Enum representing the push notification modes for a room.
/// </summary>
internal enum RoomNotificationMode : int
{
    /// <summary>
    /// Receive notifications for all messages.
    /// </summary>
    AllMessages,

    /// <summary>
    /// Receive notifications for mentions and keywords only.
    /// </summary>
    MentionsAndKeywordsOnly,

    /// <summary>
    /// Do not receive any notifications.
    /// </summary>
    Mute,
}

class FfiConverterTypeRoomNotificationMode : FfiConverterRustBuffer<RoomNotificationMode>
{
    public static FfiConverterTypeRoomNotificationMode INSTANCE = new FfiConverterTypeRoomNotificationMode();

    public override RoomNotificationMode Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RoomNotificationMode), value))
        {
            return (RoomNotificationMode)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRoomNotificationMode.Read()", value)
            );
        }
    }

    public override int AllocationSize(RoomNotificationMode value)
    {
        return 4;
    }

    public override void Write(RoomNotificationMode value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal enum RoomPreset : int
{
    /// <summary>
    /// `join_rules` is set to `invite` and `history_visibility` is set to
    /// `shared`.
    /// </summary>
    PrivateChat,

    /// <summary>
    /// `join_rules` is set to `public` and `history_visibility` is set to
    /// `shared`.
    /// </summary>
    PublicChat,

    /// <summary>
    /// Same as `PrivateChat`, but all initial invitees get the same power level
    /// as the creator.
    /// </summary>
    TrustedPrivateChat,
}

class FfiConverterTypeRoomPreset : FfiConverterRustBuffer<RoomPreset>
{
    public static FfiConverterTypeRoomPreset INSTANCE = new FfiConverterTypeRoomPreset();

    public override RoomPreset Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RoomPreset), value))
        {
            return (RoomPreset)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRoomPreset.Read()", value)
            );
        }
    }

    public override int AllocationSize(RoomPreset value)
    {
        return 4;
    }

    public override void Write(RoomPreset value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// The type of room for a [`RoomPreviewInfo`].
/// </summary>
internal record RoomType
{
    /// <summary>
    /// It's a plain chat room.
    /// </summary>
    public record Room : RoomType { }

    /// <summary>
    /// It's a space that can group several rooms.
    /// </summary>
    public record Space : RoomType { }

    /// <summary>
    /// It's a custom implementation.
    /// </summary>
    public record Custom(string @value) : RoomType { }
}

class FfiConverterTypeRoomType : FfiConverterRustBuffer<RoomType>
{
    public static FfiConverterRustBuffer<RoomType> INSTANCE = new FfiConverterTypeRoomType();

    public override RoomType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomType.Room();
            case 2:
                return new RoomType.Space();
            case 3:
                return new RoomType.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomType.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomType value)
    {
        switch (value)
        {
            case RoomType.Room variant_value:
                return 4;
            case RoomType.Space variant_value:
                return 4;
            case RoomType.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomType.AllocationSize()", value)
                );
        }
    }

    public override void Write(RoomType value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomType.Room variant_value:
                stream.WriteInt(1);
                break;
            case RoomType.Space variant_value:
                stream.WriteInt(2);
                break;
            case RoomType.Custom variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomType.Write()", value)
                );
        }
    }
}

internal record RoomVisibility
{
    /// <summary>
    /// Indicates that the room will be shown in the published room list.
    /// </summary>
    public record Public : RoomVisibility { }

    /// <summary>
    /// Indicates that the room will not be shown in the published room list.
    /// </summary>
    public record Private : RoomVisibility { }

    /// <summary>
    /// A custom value that's not present in the spec.
    /// </summary>
    public record Custom(string @value) : RoomVisibility { }
}

class FfiConverterTypeRoomVisibility : FfiConverterRustBuffer<RoomVisibility>
{
    public static FfiConverterRustBuffer<RoomVisibility> INSTANCE = new FfiConverterTypeRoomVisibility();

    public override RoomVisibility Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RoomVisibility.Public();
            case 2:
                return new RoomVisibility.Private();
            case 3:
                return new RoomVisibility.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomVisibility.Read()", value)
                );
        }
    }

    public override int AllocationSize(RoomVisibility value)
    {
        switch (value)
        {
            case RoomVisibility.Public variant_value:
                return 4;
            case RoomVisibility.Private variant_value:
                return 4;
            case RoomVisibility.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomVisibility.AllocationSize()", value)
                );
        }
    }

    public override void Write(RoomVisibility value, BigEndianStream stream)
    {
        switch (value)
        {
            case RoomVisibility.Public variant_value:
                stream.WriteInt(1);
                break;
            case RoomVisibility.Private variant_value:
                stream.WriteInt(2);
                break;
            case RoomVisibility.Custom variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRoomVisibility.Write()", value)
                );
        }
    }
}

internal enum RtcApplicationType : int
{
    Call,
}

class FfiConverterTypeRtcApplicationType : FfiConverterRustBuffer<RtcApplicationType>
{
    public static FfiConverterTypeRtcApplicationType INSTANCE = new FfiConverterTypeRtcApplicationType();

    public override RtcApplicationType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(RtcApplicationType), value))
        {
            return (RtcApplicationType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeRtcApplicationType.Read()", value)
            );
        }
    }

    public override int AllocationSize(RtcApplicationType value)
    {
        return 4;
    }

    public override void Write(RtcApplicationType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record RuleKind
{
    /// <summary>
    /// User-configured rules that override all other kinds.
    /// </summary>
    public record Override : RuleKind { }

    /// <summary>
    /// Lowest priority user-defined rules.
    /// </summary>
    public record Underride : RuleKind { }

    /// <summary>
    /// Sender-specific rules.
    /// </summary>
    public record Sender : RuleKind { }

    /// <summary>
    /// Room-specific rules.
    /// </summary>
    public record Room : RuleKind { }

    /// <summary>
    /// Content-specific rules.
    /// </summary>
    public record Content : RuleKind { }

    public record Custom(string @value) : RuleKind { }
}

class FfiConverterTypeRuleKind : FfiConverterRustBuffer<RuleKind>
{
    public static FfiConverterRustBuffer<RuleKind> INSTANCE = new FfiConverterTypeRuleKind();

    public override RuleKind Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new RuleKind.Override();
            case 2:
                return new RuleKind.Underride();
            case 3:
                return new RuleKind.Sender();
            case 4:
                return new RuleKind.Room();
            case 5:
                return new RuleKind.Content();
            case 6:
                return new RuleKind.Custom(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRuleKind.Read()", value)
                );
        }
    }

    public override int AllocationSize(RuleKind value)
    {
        switch (value)
        {
            case RuleKind.Override variant_value:
                return 4;
            case RuleKind.Underride variant_value:
                return 4;
            case RuleKind.Sender variant_value:
                return 4;
            case RuleKind.Room variant_value:
                return 4;
            case RuleKind.Content variant_value:
                return 4;
            case RuleKind.Custom variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRuleKind.AllocationSize()", value)
                );
        }
    }

    public override void Write(RuleKind value, BigEndianStream stream)
    {
        switch (value)
        {
            case RuleKind.Override variant_value:
                stream.WriteInt(1);
                break;
            case RuleKind.Underride variant_value:
                stream.WriteInt(2);
                break;
            case RuleKind.Sender variant_value:
                stream.WriteInt(3);
                break;
            case RuleKind.Room variant_value:
                stream.WriteInt(4);
                break;
            case RuleKind.Content variant_value:
                stream.WriteInt(5);
                break;
            case RuleKind.Custom variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeRuleKind.Write()", value)
                );
        }
    }
}

internal record SessionVerificationData : IDisposable
{
    public record Emojis(List<SessionVerificationEmoji> @emojis, byte[] @indices) : SessionVerificationData { }

    public record Decimals(List<ushort> @values) : SessionVerificationData { }

    public void Dispose()
    {
        switch (this)
        {
            case SessionVerificationData.Emojis variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@emojis, variant_value.@indices);
                break;
            case SessionVerificationData.Decimals variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@values);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in SessionVerificationData.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeSessionVerificationData : FfiConverterRustBuffer<SessionVerificationData>
{
    public static FfiConverterRustBuffer<SessionVerificationData> INSTANCE =
        new FfiConverterTypeSessionVerificationData();

    public override SessionVerificationData Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new SessionVerificationData.Emojis(
                    FfiConverterSequenceTypeSessionVerificationEmoji.INSTANCE.Read(stream),
                    FfiConverterByteArray.INSTANCE.Read(stream)
                );
            case 2:
                return new SessionVerificationData.Decimals(FfiConverterSequenceUInt16.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeSessionVerificationData.Read()", value)
                );
        }
    }

    public override int AllocationSize(SessionVerificationData value)
    {
        switch (value)
        {
            case SessionVerificationData.Emojis variant_value:
                return 4
                    + FfiConverterSequenceTypeSessionVerificationEmoji.INSTANCE.AllocationSize(variant_value.@emojis)
                    + FfiConverterByteArray.INSTANCE.AllocationSize(variant_value.@indices);
            case SessionVerificationData.Decimals variant_value:
                return 4 + FfiConverterSequenceUInt16.INSTANCE.AllocationSize(variant_value.@values);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeSessionVerificationData.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(SessionVerificationData value, BigEndianStream stream)
    {
        switch (value)
        {
            case SessionVerificationData.Emojis variant_value:
                stream.WriteInt(1);
                FfiConverterSequenceTypeSessionVerificationEmoji.INSTANCE.Write(variant_value.@emojis, stream);
                FfiConverterByteArray.INSTANCE.Write(variant_value.@indices, stream);
                break;
            case SessionVerificationData.Decimals variant_value:
                stream.WriteInt(2);
                FfiConverterSequenceUInt16.INSTANCE.Write(variant_value.@values, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeSessionVerificationData.Write()", value)
                );
        }
    }
}

/// <summary>
/// Recommended decorations for decrypted messages, representing the message's
/// authenticity properties.
/// </summary>
internal record ShieldState
{
    /// <summary>
    /// A red shield with a tooltip containing the associated message should be
    /// presented.
    /// </summary>
    public record Red(ShieldStateCode @code, string @message) : ShieldState { }

    /// <summary>
    /// A grey shield with a tooltip containing the associated message should be
    /// presented.
    /// </summary>
    public record Grey(ShieldStateCode @code, string @message) : ShieldState { }

    /// <summary>
    /// No shield should be presented.
    /// </summary>
    public record None : ShieldState { }
}

class FfiConverterTypeShieldState : FfiConverterRustBuffer<ShieldState>
{
    public static FfiConverterRustBuffer<ShieldState> INSTANCE = new FfiConverterTypeShieldState();

    public override ShieldState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new ShieldState.Red(
                    FfiConverterTypeShieldStateCode.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new ShieldState.Grey(
                    FfiConverterTypeShieldStateCode.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new ShieldState.None();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeShieldState.Read()", value)
                );
        }
    }

    public override int AllocationSize(ShieldState value)
    {
        switch (value)
        {
            case ShieldState.Red variant_value:
                return 4
                    + FfiConverterTypeShieldStateCode.INSTANCE.AllocationSize(variant_value.@code)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
            case ShieldState.Grey variant_value:
                return 4
                    + FfiConverterTypeShieldStateCode.INSTANCE.AllocationSize(variant_value.@code)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
            case ShieldState.None variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeShieldState.AllocationSize()", value)
                );
        }
    }

    public override void Write(ShieldState value, BigEndianStream stream)
    {
        switch (value)
        {
            case ShieldState.Red variant_value:
                stream.WriteInt(1);
                FfiConverterTypeShieldStateCode.INSTANCE.Write(variant_value.@code, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case ShieldState.Grey variant_value:
                stream.WriteInt(2);
                FfiConverterTypeShieldStateCode.INSTANCE.Write(variant_value.@code, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case ShieldState.None variant_value:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeShieldState.Write()", value)
                );
        }
    }
}

internal enum SlidingSyncVersion : int
{
    None,
    Native,
}

class FfiConverterTypeSlidingSyncVersion : FfiConverterRustBuffer<SlidingSyncVersion>
{
    public static FfiConverterTypeSlidingSyncVersion INSTANCE = new FfiConverterTypeSlidingSyncVersion();

    public override SlidingSyncVersion Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SlidingSyncVersion), value))
        {
            return (SlidingSyncVersion)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeSlidingSyncVersion.Read()", value)
            );
        }
    }

    public override int AllocationSize(SlidingSyncVersion value)
    {
        return 4;
    }

    public override void Write(SlidingSyncVersion value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal enum SlidingSyncVersionBuilder : int
{
    None,
    Native,
    DiscoverNative,
}

class FfiConverterTypeSlidingSyncVersionBuilder : FfiConverterRustBuffer<SlidingSyncVersionBuilder>
{
    public static FfiConverterTypeSlidingSyncVersionBuilder INSTANCE = new FfiConverterTypeSlidingSyncVersionBuilder();

    public override SlidingSyncVersionBuilder Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SlidingSyncVersionBuilder), value))
        {
            return (SlidingSyncVersionBuilder)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeSlidingSyncVersionBuilder.Read()", value)
            );
        }
    }

    public override int AllocationSize(SlidingSyncVersionBuilder value)
    {
        return 4;
    }

    public override void Write(SlidingSyncVersionBuilder value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal class SsoException : UniffiException
{
    SsoException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class CallbackUrlInvalid : SsoException
    {
        public CallbackUrlInvalid(string message)
            : base(message) { }
    }

    public class LoginWithTokenFailed : SsoException
    {
        public LoginWithTokenFailed(string message)
            : base(message) { }
    }

    public class Generic : SsoException
    {
        public Generic(string message)
            : base(message) { }
    }
}

class FfiConverterTypeSsoError : FfiConverterRustBuffer<SsoException>, CallStatusErrorHandler<SsoException>
{
    public static FfiConverterTypeSsoError INSTANCE = new FfiConverterTypeSsoError();

    public override SsoException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new SsoException.CallbackUrlInvalid(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new SsoException.LoginWithTokenFailed(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new SsoException.Generic(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeSsoError.Read()", value)
                );
        }
    }

    public override int AllocationSize(SsoException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(SsoException value, BigEndianStream stream)
    {
        switch (value)
        {
            case SsoException.CallbackUrlInvalid:
                stream.WriteInt(1);
                break;
            case SsoException.LoginWithTokenFailed:
                stream.WriteInt(2);
                break;
            case SsoException.Generic:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeSsoError.Write()", value)
                );
        }
    }
}

internal record StateEventContent
{
    public record PolicyRuleRoom : StateEventContent { }

    public record PolicyRuleServer : StateEventContent { }

    public record PolicyRuleUser : StateEventContent { }

    public record RoomAliases : StateEventContent { }

    public record RoomAvatar : StateEventContent { }

    public record RoomCanonicalAlias : StateEventContent { }

    public record RoomCreate : StateEventContent { }

    public record RoomEncryption : StateEventContent { }

    public record RoomGuestAccess : StateEventContent { }

    public record RoomHistoryVisibility : StateEventContent { }

    public record RoomJoinRules : StateEventContent { }

    public record RoomMemberContent(string @userId, MembershipState @membershipState) : StateEventContent { }

    public record RoomName : StateEventContent { }

    public record RoomPinnedEvents : StateEventContent { }

    public record RoomPowerLevels : StateEventContent { }

    public record RoomServerAcl : StateEventContent { }

    public record RoomThirdPartyInvite : StateEventContent { }

    public record RoomTombstone : StateEventContent { }

    public record RoomTopic : StateEventContent { }

    public record SpaceChild : StateEventContent { }

    public record SpaceParent : StateEventContent { }
}

class FfiConverterTypeStateEventContent : FfiConverterRustBuffer<StateEventContent>
{
    public static FfiConverterRustBuffer<StateEventContent> INSTANCE = new FfiConverterTypeStateEventContent();

    public override StateEventContent Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new StateEventContent.PolicyRuleRoom();
            case 2:
                return new StateEventContent.PolicyRuleServer();
            case 3:
                return new StateEventContent.PolicyRuleUser();
            case 4:
                return new StateEventContent.RoomAliases();
            case 5:
                return new StateEventContent.RoomAvatar();
            case 6:
                return new StateEventContent.RoomCanonicalAlias();
            case 7:
                return new StateEventContent.RoomCreate();
            case 8:
                return new StateEventContent.RoomEncryption();
            case 9:
                return new StateEventContent.RoomGuestAccess();
            case 10:
                return new StateEventContent.RoomHistoryVisibility();
            case 11:
                return new StateEventContent.RoomJoinRules();
            case 12:
                return new StateEventContent.RoomMemberContent(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeMembershipState.INSTANCE.Read(stream)
                );
            case 13:
                return new StateEventContent.RoomName();
            case 14:
                return new StateEventContent.RoomPinnedEvents();
            case 15:
                return new StateEventContent.RoomPowerLevels();
            case 16:
                return new StateEventContent.RoomServerAcl();
            case 17:
                return new StateEventContent.RoomThirdPartyInvite();
            case 18:
                return new StateEventContent.RoomTombstone();
            case 19:
                return new StateEventContent.RoomTopic();
            case 20:
                return new StateEventContent.SpaceChild();
            case 21:
                return new StateEventContent.SpaceParent();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeStateEventContent.Read()", value)
                );
        }
    }

    public override int AllocationSize(StateEventContent value)
    {
        switch (value)
        {
            case StateEventContent.PolicyRuleRoom variant_value:
                return 4;
            case StateEventContent.PolicyRuleServer variant_value:
                return 4;
            case StateEventContent.PolicyRuleUser variant_value:
                return 4;
            case StateEventContent.RoomAliases variant_value:
                return 4;
            case StateEventContent.RoomAvatar variant_value:
                return 4;
            case StateEventContent.RoomCanonicalAlias variant_value:
                return 4;
            case StateEventContent.RoomCreate variant_value:
                return 4;
            case StateEventContent.RoomEncryption variant_value:
                return 4;
            case StateEventContent.RoomGuestAccess variant_value:
                return 4;
            case StateEventContent.RoomHistoryVisibility variant_value:
                return 4;
            case StateEventContent.RoomJoinRules variant_value:
                return 4;
            case StateEventContent.RoomMemberContent variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@userId)
                    + FfiConverterTypeMembershipState.INSTANCE.AllocationSize(variant_value.@membershipState);
            case StateEventContent.RoomName variant_value:
                return 4;
            case StateEventContent.RoomPinnedEvents variant_value:
                return 4;
            case StateEventContent.RoomPowerLevels variant_value:
                return 4;
            case StateEventContent.RoomServerAcl variant_value:
                return 4;
            case StateEventContent.RoomThirdPartyInvite variant_value:
                return 4;
            case StateEventContent.RoomTombstone variant_value:
                return 4;
            case StateEventContent.RoomTopic variant_value:
                return 4;
            case StateEventContent.SpaceChild variant_value:
                return 4;
            case StateEventContent.SpaceParent variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeStateEventContent.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(StateEventContent value, BigEndianStream stream)
    {
        switch (value)
        {
            case StateEventContent.PolicyRuleRoom variant_value:
                stream.WriteInt(1);
                break;
            case StateEventContent.PolicyRuleServer variant_value:
                stream.WriteInt(2);
                break;
            case StateEventContent.PolicyRuleUser variant_value:
                stream.WriteInt(3);
                break;
            case StateEventContent.RoomAliases variant_value:
                stream.WriteInt(4);
                break;
            case StateEventContent.RoomAvatar variant_value:
                stream.WriteInt(5);
                break;
            case StateEventContent.RoomCanonicalAlias variant_value:
                stream.WriteInt(6);
                break;
            case StateEventContent.RoomCreate variant_value:
                stream.WriteInt(7);
                break;
            case StateEventContent.RoomEncryption variant_value:
                stream.WriteInt(8);
                break;
            case StateEventContent.RoomGuestAccess variant_value:
                stream.WriteInt(9);
                break;
            case StateEventContent.RoomHistoryVisibility variant_value:
                stream.WriteInt(10);
                break;
            case StateEventContent.RoomJoinRules variant_value:
                stream.WriteInt(11);
                break;
            case StateEventContent.RoomMemberContent variant_value:
                stream.WriteInt(12);
                FfiConverterString.INSTANCE.Write(variant_value.@userId, stream);
                FfiConverterTypeMembershipState.INSTANCE.Write(variant_value.@membershipState, stream);
                break;
            case StateEventContent.RoomName variant_value:
                stream.WriteInt(13);
                break;
            case StateEventContent.RoomPinnedEvents variant_value:
                stream.WriteInt(14);
                break;
            case StateEventContent.RoomPowerLevels variant_value:
                stream.WriteInt(15);
                break;
            case StateEventContent.RoomServerAcl variant_value:
                stream.WriteInt(16);
                break;
            case StateEventContent.RoomThirdPartyInvite variant_value:
                stream.WriteInt(17);
                break;
            case StateEventContent.RoomTombstone variant_value:
                stream.WriteInt(18);
                break;
            case StateEventContent.RoomTopic variant_value:
                stream.WriteInt(19);
                break;
            case StateEventContent.SpaceChild variant_value:
                stream.WriteInt(20);
                break;
            case StateEventContent.SpaceParent variant_value:
                stream.WriteInt(21);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeStateEventContent.Write()", value)
                );
        }
    }
}

internal enum StateEventType : int
{
    CallMember,
    PolicyRuleRoom,
    PolicyRuleServer,
    PolicyRuleUser,
    RoomAliases,
    RoomAvatar,
    RoomCanonicalAlias,
    RoomCreate,
    RoomEncryption,
    RoomGuestAccess,
    RoomHistoryVisibility,
    RoomJoinRules,
    RoomMemberEvent,
    RoomName,
    RoomPinnedEvents,
    RoomPowerLevels,
    RoomServerAcl,
    RoomThirdPartyInvite,
    RoomTombstone,
    RoomTopic,
    SpaceChild,
    SpaceParent,
}

class FfiConverterTypeStateEventType : FfiConverterRustBuffer<StateEventType>
{
    public static FfiConverterTypeStateEventType INSTANCE = new FfiConverterTypeStateEventType();

    public override StateEventType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(StateEventType), value))
        {
            return (StateEventType)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeStateEventType.Read()", value)
            );
        }
    }

    public override int AllocationSize(StateEventType value)
    {
        return 4;
    }

    public override void Write(StateEventType value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal class SteadyStateException : UniffiException
{
    SteadyStateException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class BackupDisabled : SteadyStateException
    {
        public BackupDisabled(string message)
            : base(message) { }
    }

    public class Connection : SteadyStateException
    {
        public Connection(string message)
            : base(message) { }
    }

    public class Lagged : SteadyStateException
    {
        public Lagged(string message)
            : base(message) { }
    }
}

class FfiConverterTypeSteadyStateError
    : FfiConverterRustBuffer<SteadyStateException>,
        CallStatusErrorHandler<SteadyStateException>
{
    public static FfiConverterTypeSteadyStateError INSTANCE = new FfiConverterTypeSteadyStateError();

    public override SteadyStateException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new SteadyStateException.BackupDisabled(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new SteadyStateException.Connection(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new SteadyStateException.Lagged(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeSteadyStateError.Read()", value)
                );
        }
    }

    public override int AllocationSize(SteadyStateException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(SteadyStateException value, BigEndianStream stream)
    {
        switch (value)
        {
            case SteadyStateException.BackupDisabled:
                stream.WriteInt(1);
                break;
            case SteadyStateException.Connection:
                stream.WriteInt(2);
                break;
            case SteadyStateException.Lagged:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeSteadyStateError.Write()", value)
                );
        }
    }
}

internal enum SyncServiceState : int
{
    Idle,
    Running,
    Terminated,
    Error,
    Offline,
}

class FfiConverterTypeSyncServiceState : FfiConverterRustBuffer<SyncServiceState>
{
    public static FfiConverterTypeSyncServiceState INSTANCE = new FfiConverterTypeSyncServiceState();

    public override SyncServiceState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SyncServiceState), value))
        {
            return (SyncServiceState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeSyncServiceState.Read()", value)
            );
        }
    }

    public override int AllocationSize(SyncServiceState value)
    {
        return 4;
    }

    public override void Write(SyncServiceState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal enum TimelineChange : int
{
    Append,
    Clear,
    Insert,
    Set,
    Remove,
    PushBack,
    PushFront,
    PopBack,
    PopFront,
    Truncate,
    Reset,
}

class FfiConverterTypeTimelineChange : FfiConverterRustBuffer<TimelineChange>
{
    public static FfiConverterTypeTimelineChange INSTANCE = new FfiConverterTypeTimelineChange();

    public override TimelineChange Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(TimelineChange), value))
        {
            return (TimelineChange)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineChange.Read()", value)
            );
        }
    }

    public override int AllocationSize(TimelineChange value)
    {
        return 4;
    }

    public override void Write(TimelineChange value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal record TimelineEventType : IDisposable
{
    public record MessageLike(MessageLikeEventContent @content) : TimelineEventType { }

    public record State(StateEventContent @content) : TimelineEventType { }

    public void Dispose()
    {
        switch (this)
        {
            case TimelineEventType.MessageLike variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case TimelineEventType.State variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in TimelineEventType.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeTimelineEventType : FfiConverterRustBuffer<TimelineEventType>
{
    public static FfiConverterRustBuffer<TimelineEventType> INSTANCE = new FfiConverterTypeTimelineEventType();

    public override TimelineEventType Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new TimelineEventType.MessageLike(FfiConverterTypeMessageLikeEventContent.INSTANCE.Read(stream));
            case 2:
                return new TimelineEventType.State(FfiConverterTypeStateEventContent.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineEventType.Read()", value)
                );
        }
    }

    public override int AllocationSize(TimelineEventType value)
    {
        switch (value)
        {
            case TimelineEventType.MessageLike variant_value:
                return 4 + FfiConverterTypeMessageLikeEventContent.INSTANCE.AllocationSize(variant_value.@content);
            case TimelineEventType.State variant_value:
                return 4 + FfiConverterTypeStateEventContent.INSTANCE.AllocationSize(variant_value.@content);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeTimelineEventType.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(TimelineEventType value, BigEndianStream stream)
    {
        switch (value)
        {
            case TimelineEventType.MessageLike variant_value:
                stream.WriteInt(1);
                FfiConverterTypeMessageLikeEventContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case TimelineEventType.State variant_value:
                stream.WriteInt(2);
                FfiConverterTypeStateEventContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineEventType.Write()", value)
                );
        }
    }
}

internal record TimelineFilter : IDisposable
{
    /// <summary>
    /// Show all the events in the timeline, independent of their type.
    /// </summary>
    public record All : TimelineFilter { }

    /// <summary>
    /// Show only `m.room.messages` of the given room message types.
    /// </summary>
    public record OnlyMessage(List<RoomMessageEventMessageType> @types) : TimelineFilter { }

    /// <summary>
    /// Show only events which match this filter.
    /// </summary>
    public record EventTypeFilter(TimelineEventTypeFilter @filter) : TimelineFilter { }

    public void Dispose()
    {
        switch (this)
        {
            case TimelineFilter.All variant_value:
                break;
            case TimelineFilter.OnlyMessage variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@types);
                break;
            case TimelineFilter.EventTypeFilter variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@filter);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in TimelineFilter.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeTimelineFilter : FfiConverterRustBuffer<TimelineFilter>
{
    public static FfiConverterRustBuffer<TimelineFilter> INSTANCE = new FfiConverterTypeTimelineFilter();

    public override TimelineFilter Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new TimelineFilter.All();
            case 2:
                return new TimelineFilter.OnlyMessage(
                    FfiConverterSequenceTypeRoomMessageEventMessageType.INSTANCE.Read(stream)
                );
            case 3:
                return new TimelineFilter.EventTypeFilter(
                    FfiConverterTypeTimelineEventTypeFilter.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineFilter.Read()", value)
                );
        }
    }

    public override int AllocationSize(TimelineFilter value)
    {
        switch (value)
        {
            case TimelineFilter.All variant_value:
                return 4;
            case TimelineFilter.OnlyMessage variant_value:
                return 4
                    + FfiConverterSequenceTypeRoomMessageEventMessageType.INSTANCE.AllocationSize(variant_value.@types);
            case TimelineFilter.EventTypeFilter variant_value:
                return 4 + FfiConverterTypeTimelineEventTypeFilter.INSTANCE.AllocationSize(variant_value.@filter);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineFilter.AllocationSize()", value)
                );
        }
    }

    public override void Write(TimelineFilter value, BigEndianStream stream)
    {
        switch (value)
        {
            case TimelineFilter.All variant_value:
                stream.WriteInt(1);
                break;
            case TimelineFilter.OnlyMessage variant_value:
                stream.WriteInt(2);
                FfiConverterSequenceTypeRoomMessageEventMessageType.INSTANCE.Write(variant_value.@types, stream);
                break;
            case TimelineFilter.EventTypeFilter variant_value:
                stream.WriteInt(3);
                FfiConverterTypeTimelineEventTypeFilter.INSTANCE.Write(variant_value.@filter, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineFilter.Write()", value)
                );
        }
    }
}

internal record TimelineFocus
{
    public record Live : TimelineFocus { }

    public record Event(string @eventId, ushort @numContextEvents) : TimelineFocus { }

    public record PinnedEvents(ushort @maxEventsToLoad, ushort @maxConcurrentRequests) : TimelineFocus { }
}

class FfiConverterTypeTimelineFocus : FfiConverterRustBuffer<TimelineFocus>
{
    public static FfiConverterRustBuffer<TimelineFocus> INSTANCE = new FfiConverterTypeTimelineFocus();

    public override TimelineFocus Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new TimelineFocus.Live();
            case 2:
                return new TimelineFocus.Event(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterUInt16.INSTANCE.Read(stream)
                );
            case 3:
                return new TimelineFocus.PinnedEvents(
                    FfiConverterUInt16.INSTANCE.Read(stream),
                    FfiConverterUInt16.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineFocus.Read()", value)
                );
        }
    }

    public override int AllocationSize(TimelineFocus value)
    {
        switch (value)
        {
            case TimelineFocus.Live variant_value:
                return 4;
            case TimelineFocus.Event variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventId)
                    + FfiConverterUInt16.INSTANCE.AllocationSize(variant_value.@numContextEvents);
            case TimelineFocus.PinnedEvents variant_value:
                return 4
                    + FfiConverterUInt16.INSTANCE.AllocationSize(variant_value.@maxEventsToLoad)
                    + FfiConverterUInt16.INSTANCE.AllocationSize(variant_value.@maxConcurrentRequests);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineFocus.AllocationSize()", value)
                );
        }
    }

    public override void Write(TimelineFocus value, BigEndianStream stream)
    {
        switch (value)
        {
            case TimelineFocus.Live variant_value:
                stream.WriteInt(1);
                break;
            case TimelineFocus.Event variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@eventId, stream);
                FfiConverterUInt16.INSTANCE.Write(variant_value.@numContextEvents, stream);
                break;
            case TimelineFocus.PinnedEvents variant_value:
                stream.WriteInt(3);
                FfiConverterUInt16.INSTANCE.Write(variant_value.@maxEventsToLoad, stream);
                FfiConverterUInt16.INSTANCE.Write(variant_value.@maxConcurrentRequests, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineFocus.Write()", value)
                );
        }
    }
}

internal record TimelineItemContent : IDisposable
{
    public record MsgLike(MsgLikeContent @content) : TimelineItemContent { }

    public record CallInvite : TimelineItemContent { }

    public record CallNotify : TimelineItemContent { }

    public record RoomMembership(string @userId, string? @userDisplayName, MembershipChange? @change, string? @reason)
        : TimelineItemContent { }

    public record ProfileChange(
        string? @displayName,
        string? @prevDisplayName,
        string? @avatarUrl,
        string? @prevAvatarUrl
    ) : TimelineItemContent { }

    public record State(string @stateKey, OtherState @content) : TimelineItemContent { }

    public record FailedToParseMessageLike(string @eventType, string @error) : TimelineItemContent { }

    public record FailedToParseState(string @eventType, string @stateKey, string @error) : TimelineItemContent { }

    public void Dispose()
    {
        switch (this)
        {
            case TimelineItemContent.MsgLike variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@content);
                break;
            case TimelineItemContent.CallInvite variant_value:
                break;
            case TimelineItemContent.CallNotify variant_value:
                break;
            case TimelineItemContent.RoomMembership variant_value:

                FFIObjectUtil.DisposeAll(
                    variant_value.@userId,
                    variant_value.@userDisplayName,
                    variant_value.@change,
                    variant_value.@reason
                );
                break;
            case TimelineItemContent.ProfileChange variant_value:

                FFIObjectUtil.DisposeAll(
                    variant_value.@displayName,
                    variant_value.@prevDisplayName,
                    variant_value.@avatarUrl,
                    variant_value.@prevAvatarUrl
                );
                break;
            case TimelineItemContent.State variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@stateKey, variant_value.@content);
                break;
            case TimelineItemContent.FailedToParseMessageLike variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@eventType, variant_value.@error);
                break;
            case TimelineItemContent.FailedToParseState variant_value:

                FFIObjectUtil.DisposeAll(variant_value.@eventType, variant_value.@stateKey, variant_value.@error);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in TimelineItemContent.Dispose()", this)
                );
        }
    }
}

class FfiConverterTypeTimelineItemContent : FfiConverterRustBuffer<TimelineItemContent>
{
    public static FfiConverterRustBuffer<TimelineItemContent> INSTANCE = new FfiConverterTypeTimelineItemContent();

    public override TimelineItemContent Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new TimelineItemContent.MsgLike(FfiConverterTypeMsgLikeContent.INSTANCE.Read(stream));
            case 2:
                return new TimelineItemContent.CallInvite();
            case 3:
                return new TimelineItemContent.CallNotify();
            case 4:
                return new TimelineItemContent.RoomMembership(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeMembershipChange.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 5:
                return new TimelineItemContent.ProfileChange(
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 6:
                return new TimelineItemContent.State(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeOtherState.INSTANCE.Read(stream)
                );
            case 7:
                return new TimelineItemContent.FailedToParseMessageLike(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 8:
                return new TimelineItemContent.FailedToParseState(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineItemContent.Read()", value)
                );
        }
    }

    public override int AllocationSize(TimelineItemContent value)
    {
        switch (value)
        {
            case TimelineItemContent.MsgLike variant_value:
                return 4 + FfiConverterTypeMsgLikeContent.INSTANCE.AllocationSize(variant_value.@content);
            case TimelineItemContent.CallInvite variant_value:
                return 4;
            case TimelineItemContent.CallNotify variant_value:
                return 4;
            case TimelineItemContent.RoomMembership variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@userId)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@userDisplayName)
                    + FfiConverterOptionalTypeMembershipChange.INSTANCE.AllocationSize(variant_value.@change)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@reason);
            case TimelineItemContent.ProfileChange variant_value:
                return 4
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@displayName)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@prevDisplayName)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@avatarUrl)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@prevAvatarUrl);
            case TimelineItemContent.State variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@stateKey)
                    + FfiConverterTypeOtherState.INSTANCE.AllocationSize(variant_value.@content);
            case TimelineItemContent.FailedToParseMessageLike variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventType)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@error);
            case TimelineItemContent.FailedToParseState variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventType)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@stateKey)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@error);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeTimelineItemContent.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(TimelineItemContent value, BigEndianStream stream)
    {
        switch (value)
        {
            case TimelineItemContent.MsgLike variant_value:
                stream.WriteInt(1);
                FfiConverterTypeMsgLikeContent.INSTANCE.Write(variant_value.@content, stream);
                break;
            case TimelineItemContent.CallInvite variant_value:
                stream.WriteInt(2);
                break;
            case TimelineItemContent.CallNotify variant_value:
                stream.WriteInt(3);
                break;
            case TimelineItemContent.RoomMembership variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@userId, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@userDisplayName, stream);
                FfiConverterOptionalTypeMembershipChange.INSTANCE.Write(variant_value.@change, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@reason, stream);
                break;
            case TimelineItemContent.ProfileChange variant_value:
                stream.WriteInt(5);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@displayName, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@prevDisplayName, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@avatarUrl, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@prevAvatarUrl, stream);
                break;
            case TimelineItemContent.State variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@stateKey, stream);
                FfiConverterTypeOtherState.INSTANCE.Write(variant_value.@content, stream);
                break;
            case TimelineItemContent.FailedToParseMessageLike variant_value:
                stream.WriteInt(7);
                FfiConverterString.INSTANCE.Write(variant_value.@eventType, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@error, stream);
                break;
            case TimelineItemContent.FailedToParseState variant_value:
                stream.WriteInt(8);
                FfiConverterString.INSTANCE.Write(variant_value.@eventType, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@stateKey, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@error, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTimelineItemContent.Write()", value)
                );
        }
    }
}

/// <summary>
/// A log pack can be used to set the trace log level for a group of multiple
/// log targets at once, for debugging purposes.
/// </summary>
internal enum TraceLogPacks : int
{
    /// <summary>
    /// Enables all the logs relevant to the event cache.
    /// </summary>
    EventCache,

    /// <summary>
    /// Enables all the logs relevant to the send queue.
    /// </summary>
    SendQueue,

    /// <summary>
    /// Enables all the logs relevant to the timeline.
    /// </summary>
    Timeline,
}

class FfiConverterTypeTraceLogPacks : FfiConverterRustBuffer<TraceLogPacks>
{
    public static FfiConverterTypeTraceLogPacks INSTANCE = new FfiConverterTypeTraceLogPacks();

    public override TraceLogPacks Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(TraceLogPacks), value))
        {
            return (TraceLogPacks)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeTraceLogPacks.Read()", value)
            );
        }
    }

    public override int AllocationSize(TraceLogPacks value)
    {
        return 4;
    }

    public override void Write(TraceLogPacks value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// Enum representing the push notification tweaks for a rule.
/// </summary>
internal record Tweak
{
    /// <summary>
    /// A string representing the sound to be played when this notification
    /// arrives.
    ///
    /// A value of "default" means to play a default sound. A device may choose
    /// to alert the user by some other means if appropriate, eg. vibration.
    /// </summary>
    public record Sound(string @value) : Tweak { }

    /// <summary>
    /// A boolean representing whether or not this message should be highlighted
    /// in the UI.
    /// </summary>
    public record Highlight(bool @value) : Tweak { }

    /// <summary>
    /// A custom tweak
    /// </summary>
    public record Custom(string @name, string @value) : Tweak { }
}

class FfiConverterTypeTweak : FfiConverterRustBuffer<Tweak>
{
    public static FfiConverterRustBuffer<Tweak> INSTANCE = new FfiConverterTypeTweak();

    public override Tweak Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new Tweak.Sound(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new Tweak.Highlight(FfiConverterBoolean.INSTANCE.Read(stream));
            case 3:
                return new Tweak.Custom(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTweak.Read()", value)
                );
        }
    }

    public override int AllocationSize(Tweak value)
    {
        switch (value)
        {
            case Tweak.Sound variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            case Tweak.Highlight variant_value:
                return 4 + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@value);
            case Tweak.Custom variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@name)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTweak.AllocationSize()", value)
                );
        }
    }

    public override void Write(Tweak value, BigEndianStream stream)
    {
        switch (value)
        {
            case Tweak.Sound variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Tweak.Highlight variant_value:
                stream.WriteInt(2);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Tweak.Custom variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@name, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeTweak.Write()", value)
                );
        }
    }
}

internal enum VerificationState : int
{
    Unknown,
    Verified,
    Unverified,
}

class FfiConverterTypeVerificationState : FfiConverterRustBuffer<VerificationState>
{
    public static FfiConverterTypeVerificationState INSTANCE = new FfiConverterTypeVerificationState();

    public override VerificationState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(VerificationState), value))
        {
            return (VerificationState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeVerificationState.Read()", value)
            );
        }
    }

    public override int AllocationSize(VerificationState value)
    {
        return 4;
    }

    public override void Write(VerificationState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
/// </summary>
internal record VirtualTimelineItem
{
    /// <summary>
    /// A divider between messages of different day or month depending on
    /// timeline settings.
    /// </summary>
    public record DateDivider(Timestamp @ts) : VirtualTimelineItem { }

    /// <summary>
    /// The user's own read marker.
    /// </summary>
    public record ReadMarker : VirtualTimelineItem { }

    /// <summary>
    /// The timeline start, that is, the *oldest* event in time for that room.
    /// </summary>
    public record TimelineStart : VirtualTimelineItem { }
}

class FfiConverterTypeVirtualTimelineItem : FfiConverterRustBuffer<VirtualTimelineItem>
{
    public static FfiConverterRustBuffer<VirtualTimelineItem> INSTANCE = new FfiConverterTypeVirtualTimelineItem();

    public override VirtualTimelineItem Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new VirtualTimelineItem.DateDivider(FfiConverterTypeTimestamp.INSTANCE.Read(stream));
            case 2:
                return new VirtualTimelineItem.ReadMarker();
            case 3:
                return new VirtualTimelineItem.TimelineStart();
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeVirtualTimelineItem.Read()", value)
                );
        }
    }

    public override int AllocationSize(VirtualTimelineItem value)
    {
        switch (value)
        {
            case VirtualTimelineItem.DateDivider variant_value:
                return 4 + FfiConverterTypeTimestamp.INSTANCE.AllocationSize(variant_value.@ts);
            case VirtualTimelineItem.ReadMarker variant_value:
                return 4;
            case VirtualTimelineItem.TimelineStart variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeVirtualTimelineItem.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(VirtualTimelineItem value, BigEndianStream stream)
    {
        switch (value)
        {
            case VirtualTimelineItem.DateDivider variant_value:
                stream.WriteInt(1);
                FfiConverterTypeTimestamp.INSTANCE.Write(variant_value.@ts, stream);
                break;
            case VirtualTimelineItem.ReadMarker variant_value:
                stream.WriteInt(2);
                break;
            case VirtualTimelineItem.TimelineStart variant_value:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeVirtualTimelineItem.Write()", value)
                );
        }
    }
}

/// <summary>
/// Different kinds of filters that could be applied to the timeline events.
/// </summary>
internal record WidgetEventFilter
{
    /// <summary>
    /// Matches message-like events with the given `type`.
    /// </summary>
    public record MessageLikeWithType(string @eventType) : WidgetEventFilter { }

    /// <summary>
    /// Matches `m.room.message` events with the given `msgtype`.
    /// </summary>
    public record RoomMessageWithMsgtype(string @msgtype) : WidgetEventFilter { }

    /// <summary>
    /// Matches state events with the given `type`, regardless of `state_key`.
    /// </summary>
    public record StateWithType(string @eventType) : WidgetEventFilter { }

    /// <summary>
    /// Matches state events with the given `type` and `state_key`.
    /// </summary>
    public record StateWithTypeAndStateKey(string @eventType, string @stateKey) : WidgetEventFilter { }
}

class FfiConverterTypeWidgetEventFilter : FfiConverterRustBuffer<WidgetEventFilter>
{
    public static FfiConverterRustBuffer<WidgetEventFilter> INSTANCE = new FfiConverterTypeWidgetEventFilter();

    public override WidgetEventFilter Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new WidgetEventFilter.MessageLikeWithType(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new WidgetEventFilter.RoomMessageWithMsgtype(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new WidgetEventFilter.StateWithType(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new WidgetEventFilter.StateWithTypeAndStateKey(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeWidgetEventFilter.Read()", value)
                );
        }
    }

    public override int AllocationSize(WidgetEventFilter value)
    {
        switch (value)
        {
            case WidgetEventFilter.MessageLikeWithType variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventType);
            case WidgetEventFilter.RoomMessageWithMsgtype variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msgtype);
            case WidgetEventFilter.StateWithType variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventType);
            case WidgetEventFilter.StateWithTypeAndStateKey variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@eventType)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@stateKey);
            default:
                throw new InternalException(
                    String.Format(
                        "invalid enum value '{0}' in FfiConverterTypeWidgetEventFilter.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(WidgetEventFilter value, BigEndianStream stream)
    {
        switch (value)
        {
            case WidgetEventFilter.MessageLikeWithType variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@eventType, stream);
                break;
            case WidgetEventFilter.RoomMessageWithMsgtype variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@msgtype, stream);
                break;
            case WidgetEventFilter.StateWithType variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@eventType, stream);
                break;
            case WidgetEventFilter.StateWithTypeAndStateKey variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@eventType, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@stateKey, stream);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid enum value '{0}' in FfiConverterTypeWidgetEventFilter.Write()", value)
                );
        }
    }
}

internal interface BackupStateListener
{
    void OnUpdate(BackupState @status);
}

class UniffiCallbackInterfaceBackupStateListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeBackupStateListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeBackupState.INSTANCE.Lift(@status));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeBackupStateListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceBackupStateListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceBackupStateListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceBackupStateListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceBackupStateListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(
            ref UniffiCallbackInterfaceBackupStateListener._vtable
        );
    }
}

class ConcurrentHandleMap<T>
    where T : notnull
{
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj)
    {
        lock (lock_)
        {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result)
    {
        lock (lock_)
        {
#pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
#pragma warning restore 8601
        }
    }

    public T Get(ulong handle)
    {
        if (TryGet(handle, out var result))
        {
            return result;
        }
        else
        {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle)
    {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result)
    {
        lock (lock_)
        {
            // Possible null reference assignment
#pragma warning disable 8601
            if (map.TryGetValue(handle, out result))
            {
#pragma warning restore 8601
                map.Remove(handle);
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}

static class UniffiCallbackResponseStatus
{
    public static sbyte SUCCESS = 0;
    public static sbyte ERROR = 1;
    public static sbyte UNEXPECTED_ERROR = 2;
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeBackupStateListener : FfiConverter<BackupStateListener, ulong>
{
    public static FfiConverterTypeBackupStateListener INSTANCE = new FfiConverterTypeBackupStateListener();

    public ConcurrentHandleMap<BackupStateListener> handleMap = new ConcurrentHandleMap<BackupStateListener>();

    public override ulong Lower(BackupStateListener value)
    {
        return handleMap.Insert(value);
    }

    public override BackupStateListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override BackupStateListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(BackupStateListener value)
    {
        return 8;
    }

    public override void Write(BackupStateListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface BackupSteadyStateListener
{
    void OnUpdate(BackupUploadState @status);
}

class UniffiCallbackInterfaceBackupSteadyStateListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeBackupSteadyStateListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeBackupUploadState.INSTANCE.Lift(@status));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeBackupSteadyStateListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceBackupSteadyStateListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceBackupSteadyStateListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceBackupSteadyStateListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceBackupSteadyStateListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(
            ref UniffiCallbackInterfaceBackupSteadyStateListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeBackupSteadyStateListener : FfiConverter<BackupSteadyStateListener, ulong>
{
    public static FfiConverterTypeBackupSteadyStateListener INSTANCE = new FfiConverterTypeBackupSteadyStateListener();

    public ConcurrentHandleMap<BackupSteadyStateListener> handleMap =
        new ConcurrentHandleMap<BackupSteadyStateListener>();

    public override ulong Lower(BackupSteadyStateListener value)
    {
        return handleMap.Insert(value);
    }

    public override BackupSteadyStateListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override BackupSteadyStateListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(BackupSteadyStateListener value)
    {
        return 8;
    }

    public override void Write(BackupSteadyStateListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface ClientDelegate
{
    void DidReceiveAuthError(bool @isSoftLogout);
    void DidRefreshTokens();
}

class UniffiCallbackInterfaceClientDelegate
{
    static void DidReceiveAuthError(
        ulong @uniffiHandle,
        sbyte @isSoftLogout,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeClientDelegate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.DidReceiveAuthError(FfiConverterBoolean.INSTANCE.Lift(@isSoftLogout));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidRefreshTokens(ulong @uniffiHandle, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeClientDelegate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.DidRefreshTokens();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeClientDelegate.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceClientDelegateMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceClientDelegateMethod0(DidReceiveAuthError);
    static _UniFFILib.UniffiCallbackInterfaceClientDelegateMethod1 _m1 =
        new _UniFFILib.UniffiCallbackInterfaceClientDelegateMethod1(DidRefreshTokens);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceClientDelegate _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceClientDelegate
        {
            @didReceiveAuthError = Marshal.GetFunctionPointerForDelegate(_m0),
            @didRefreshTokens = Marshal.GetFunctionPointerForDelegate(_m1),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(
            ref UniffiCallbackInterfaceClientDelegate._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeClientDelegate : FfiConverter<ClientDelegate, ulong>
{
    public static FfiConverterTypeClientDelegate INSTANCE = new FfiConverterTypeClientDelegate();

    public ConcurrentHandleMap<ClientDelegate> handleMap = new ConcurrentHandleMap<ClientDelegate>();

    public override ulong Lower(ClientDelegate value)
    {
        return handleMap.Insert(value);
    }

    public override ClientDelegate Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override ClientDelegate Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(ClientDelegate value)
    {
        return 8;
    }

    public override void Write(ClientDelegate value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface ClientSessionDelegate
{
    /// <exception cref="ClientException"></exception>
    Session RetrieveSessionFromKeychain(string @userId);
    void SaveSessionInKeychain(Session @session);
}

class UniffiCallbackInterfaceClientSessionDelegate
{
    static void RetrieveSessionFromKeychain(
        ulong @uniffiHandle,
        RustBuffer @userId,
        ref RustBuffer @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeClientSessionDelegate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            try
            {
                var result = uniffiObject.RetrieveSessionFromKeychain(FfiConverterString.INSTANCE.Lift(@userId));
                @uniffiOutReturn = FfiConverterTypeSession.INSTANCE.Lower(result);
                _uniffi_out_err.code = UniffiCallbackResponseStatus.SUCCESS;
            }
            catch (ClientException e)
            {
                _uniffi_out_err.code = UniffiCallbackResponseStatus.ERROR;
                _uniffi_out_err.error_buf = FfiConverterTypeClientError.INSTANCE.Lower(e);
            }
            catch (System.Exception e)
            {
                _uniffi_out_err.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                try
                {
                    _uniffi_out_err.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                }
                catch { }
            }
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void SaveSessionInKeychain(
        ulong @uniffiHandle,
        RustBuffer @session,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeClientSessionDelegate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.SaveSessionInKeychain(FfiConverterTypeSession.INSTANCE.Lift(@session));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeClientSessionDelegate.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceClientSessionDelegateMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceClientSessionDelegateMethod0(RetrieveSessionFromKeychain);
    static _UniFFILib.UniffiCallbackInterfaceClientSessionDelegateMethod1 _m1 =
        new _UniFFILib.UniffiCallbackInterfaceClientSessionDelegateMethod1(SaveSessionInKeychain);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceClientSessionDelegate _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceClientSessionDelegate
        {
            @retrieveSessionFromKeychain = Marshal.GetFunctionPointerForDelegate(_m0),
            @saveSessionInKeychain = Marshal.GetFunctionPointerForDelegate(_m1),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(
            ref UniffiCallbackInterfaceClientSessionDelegate._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeClientSessionDelegate : FfiConverter<ClientSessionDelegate, ulong>
{
    public static FfiConverterTypeClientSessionDelegate INSTANCE = new FfiConverterTypeClientSessionDelegate();

    public ConcurrentHandleMap<ClientSessionDelegate> handleMap = new ConcurrentHandleMap<ClientSessionDelegate>();

    public override ulong Lower(ClientSessionDelegate value)
    {
        return handleMap.Insert(value);
    }

    public override ClientSessionDelegate Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override ClientSessionDelegate Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(ClientSessionDelegate value)
    {
        return 8;
    }

    public override void Write(ClientSessionDelegate value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface EnableRecoveryProgressListener
{
    void OnUpdate(EnableRecoveryProgress @status);
}

class UniffiCallbackInterfaceEnableRecoveryProgressListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeEnableRecoveryProgressListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeEnableRecoveryProgress.INSTANCE.Lift(@status));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeEnableRecoveryProgressListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceEnableRecoveryProgressListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceEnableRecoveryProgressListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(
            ref UniffiCallbackInterfaceEnableRecoveryProgressListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeEnableRecoveryProgressListener : FfiConverter<EnableRecoveryProgressListener, ulong>
{
    public static FfiConverterTypeEnableRecoveryProgressListener INSTANCE =
        new FfiConverterTypeEnableRecoveryProgressListener();

    public ConcurrentHandleMap<EnableRecoveryProgressListener> handleMap =
        new ConcurrentHandleMap<EnableRecoveryProgressListener>();

    public override ulong Lower(EnableRecoveryProgressListener value)
    {
        return handleMap.Insert(value);
    }

    public override EnableRecoveryProgressListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override EnableRecoveryProgressListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(EnableRecoveryProgressListener value)
    {
        return 8;
    }

    public override void Write(EnableRecoveryProgressListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface IdentityStatusChangeListener
{
    void Call(List<IdentityStatusChange> @identityStatusChange);
}

class UniffiCallbackInterfaceIdentityStatusChangeListener
{
    static void Call(
        ulong @uniffiHandle,
        RustBuffer @identityStatusChange,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeIdentityStatusChangeListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.Call(FfiConverterSequenceTypeIdentityStatusChange.INSTANCE.Lift(@identityStatusChange));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeIdentityStatusChangeListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0(Call);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceIdentityStatusChangeListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceIdentityStatusChangeListener
        {
            @call = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(
            ref UniffiCallbackInterfaceIdentityStatusChangeListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeIdentityStatusChangeListener : FfiConverter<IdentityStatusChangeListener, ulong>
{
    public static FfiConverterTypeIdentityStatusChangeListener INSTANCE =
        new FfiConverterTypeIdentityStatusChangeListener();

    public ConcurrentHandleMap<IdentityStatusChangeListener> handleMap =
        new ConcurrentHandleMap<IdentityStatusChangeListener>();

    public override ulong Lower(IdentityStatusChangeListener value)
    {
        return handleMap.Insert(value);
    }

    public override IdentityStatusChangeListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override IdentityStatusChangeListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(IdentityStatusChangeListener value)
    {
        return 8;
    }

    public override void Write(IdentityStatusChangeListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface IgnoredUsersListener
{
    void Call(List<string> @ignoredUserIds);
}

class UniffiCallbackInterfaceIgnoredUsersListener
{
    static void Call(
        ulong @uniffiHandle,
        RustBuffer @ignoredUserIds,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeIgnoredUsersListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.Call(FfiConverterSequenceString.INSTANCE.Lift(@ignoredUserIds));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeIgnoredUsersListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceIgnoredUsersListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceIgnoredUsersListenerMethod0(Call);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceIgnoredUsersListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceIgnoredUsersListener
        {
            @call = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(
            ref UniffiCallbackInterfaceIgnoredUsersListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeIgnoredUsersListener : FfiConverter<IgnoredUsersListener, ulong>
{
    public static FfiConverterTypeIgnoredUsersListener INSTANCE = new FfiConverterTypeIgnoredUsersListener();

    public ConcurrentHandleMap<IgnoredUsersListener> handleMap = new ConcurrentHandleMap<IgnoredUsersListener>();

    public override ulong Lower(IgnoredUsersListener value)
    {
        return handleMap.Insert(value);
    }

    public override IgnoredUsersListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override IgnoredUsersListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(IgnoredUsersListener value)
    {
        return 8;
    }

    public override void Write(IgnoredUsersListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

/// <summary>
/// A listener for receiving new requests to a join a room.
/// </summary>
internal interface KnockRequestsListener
{
    void Call(List<KnockRequest> @joinRequests);
}

class UniffiCallbackInterfaceKnockRequestsListener
{
    static void Call(
        ulong @uniffiHandle,
        RustBuffer @joinRequests,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeKnockRequestsListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.Call(FfiConverterSequenceTypeKnockRequest.INSTANCE.Lift(@joinRequests));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeKnockRequestsListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceKnockRequestsListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceKnockRequestsListenerMethod0(Call);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceKnockRequestsListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceKnockRequestsListener
        {
            @call = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(
            ref UniffiCallbackInterfaceKnockRequestsListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeKnockRequestsListener : FfiConverter<KnockRequestsListener, ulong>
{
    public static FfiConverterTypeKnockRequestsListener INSTANCE = new FfiConverterTypeKnockRequestsListener();

    public ConcurrentHandleMap<KnockRequestsListener> handleMap = new ConcurrentHandleMap<KnockRequestsListener>();

    public override ulong Lower(KnockRequestsListener value)
    {
        return handleMap.Insert(value);
    }

    public override KnockRequestsListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override KnockRequestsListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(KnockRequestsListener value)
    {
        return 8;
    }

    public override void Write(KnockRequestsListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

/// <summary>
/// A listener for receiving new live location shares in a room.
/// </summary>
internal interface LiveLocationShareListener
{
    void Call(List<LiveLocationShare> @liveLocationShares);
}

class UniffiCallbackInterfaceLiveLocationShareListener
{
    static void Call(
        ulong @uniffiHandle,
        RustBuffer @liveLocationShares,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeLiveLocationShareListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.Call(FfiConverterSequenceTypeLiveLocationShare.INSTANCE.Lift(@liveLocationShares));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeLiveLocationShareListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceLiveLocationShareListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceLiveLocationShareListenerMethod0(Call);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceLiveLocationShareListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceLiveLocationShareListener
        {
            @call = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(
            ref UniffiCallbackInterfaceLiveLocationShareListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeLiveLocationShareListener : FfiConverter<LiveLocationShareListener, ulong>
{
    public static FfiConverterTypeLiveLocationShareListener INSTANCE = new FfiConverterTypeLiveLocationShareListener();

    public ConcurrentHandleMap<LiveLocationShareListener> handleMap =
        new ConcurrentHandleMap<LiveLocationShareListener>();

    public override ulong Lower(LiveLocationShareListener value)
    {
        return handleMap.Insert(value);
    }

    public override LiveLocationShareListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override LiveLocationShareListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(LiveLocationShareListener value)
    {
        return 8;
    }

    public override void Write(LiveLocationShareListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

/// <summary>
/// Delegate to notify of changes in push rules
/// </summary>
internal interface NotificationSettingsDelegate
{
    void SettingsDidChange();
}

class UniffiCallbackInterfaceNotificationSettingsDelegate
{
    static void SettingsDidChange(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeNotificationSettingsDelegate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.SettingsDidChange();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeNotificationSettingsDelegate.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceNotificationSettingsDelegateMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceNotificationSettingsDelegateMethod0(SettingsDidChange);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceNotificationSettingsDelegate _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceNotificationSettingsDelegate
        {
            @settingsDidChange = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(
            ref UniffiCallbackInterfaceNotificationSettingsDelegate._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeNotificationSettingsDelegate : FfiConverter<NotificationSettingsDelegate, ulong>
{
    public static FfiConverterTypeNotificationSettingsDelegate INSTANCE =
        new FfiConverterTypeNotificationSettingsDelegate();

    public ConcurrentHandleMap<NotificationSettingsDelegate> handleMap =
        new ConcurrentHandleMap<NotificationSettingsDelegate>();

    public override ulong Lower(NotificationSettingsDelegate value)
    {
        return handleMap.Insert(value);
    }

    public override NotificationSettingsDelegate Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override NotificationSettingsDelegate Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(NotificationSettingsDelegate value)
    {
        return 8;
    }

    public override void Write(NotificationSettingsDelegate value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface PaginationStatusListener
{
    void OnUpdate(RoomPaginationStatus @status);
}

class UniffiCallbackInterfacePaginationStatusListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypePaginationStatusListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeRoomPaginationStatus.INSTANCE.Lift(@status));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypePaginationStatusListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfacePaginationStatusListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfacePaginationStatusListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfacePaginationStatusListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfacePaginationStatusListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(
            ref UniffiCallbackInterfacePaginationStatusListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypePaginationStatusListener : FfiConverter<PaginationStatusListener, ulong>
{
    public static FfiConverterTypePaginationStatusListener INSTANCE = new FfiConverterTypePaginationStatusListener();

    public ConcurrentHandleMap<PaginationStatusListener> handleMap =
        new ConcurrentHandleMap<PaginationStatusListener>();

    public override ulong Lower(PaginationStatusListener value)
    {
        return handleMap.Insert(value);
    }

    public override PaginationStatusListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override PaginationStatusListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(PaginationStatusListener value)
    {
        return 8;
    }

    public override void Write(PaginationStatusListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface ProgressWatcher
{
    void TransmissionProgress(TransmissionProgress @progress);
}

class UniffiCallbackInterfaceProgressWatcher
{
    static void TransmissionProgress(
        ulong @uniffiHandle,
        RustBuffer @progress,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeProgressWatcher.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.TransmissionProgress(FfiConverterTypeTransmissionProgress.INSTANCE.Lift(@progress));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeProgressWatcher.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceProgressWatcherMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceProgressWatcherMethod0(TransmissionProgress);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceProgressWatcher _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceProgressWatcher
        {
            @transmissionProgress = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(
            ref UniffiCallbackInterfaceProgressWatcher._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeProgressWatcher : FfiConverter<ProgressWatcher, ulong>
{
    public static FfiConverterTypeProgressWatcher INSTANCE = new FfiConverterTypeProgressWatcher();

    public ConcurrentHandleMap<ProgressWatcher> handleMap = new ConcurrentHandleMap<ProgressWatcher>();

    public override ulong Lower(ProgressWatcher value)
    {
        return handleMap.Insert(value);
    }

    public override ProgressWatcher Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override ProgressWatcher Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(ProgressWatcher value)
    {
        return 8;
    }

    public override void Write(ProgressWatcher value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface QrLoginProgressListener
{
    void OnUpdate(QrLoginProgress @state);
}

class UniffiCallbackInterfaceQrLoginProgressListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeQrLoginProgressListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeQrLoginProgress.INSTANCE.Lift(@state));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeQrLoginProgressListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceQrLoginProgressListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceQrLoginProgressListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceQrLoginProgressListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceQrLoginProgressListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(
            ref UniffiCallbackInterfaceQrLoginProgressListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeQrLoginProgressListener : FfiConverter<QrLoginProgressListener, ulong>
{
    public static FfiConverterTypeQrLoginProgressListener INSTANCE = new FfiConverterTypeQrLoginProgressListener();

    public ConcurrentHandleMap<QrLoginProgressListener> handleMap = new ConcurrentHandleMap<QrLoginProgressListener>();

    public override ulong Lower(QrLoginProgressListener value)
    {
        return handleMap.Insert(value);
    }

    public override QrLoginProgressListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override QrLoginProgressListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(QrLoginProgressListener value)
    {
        return 8;
    }

    public override void Write(QrLoginProgressListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RecoveryStateListener
{
    void OnUpdate(RecoveryState @status);
}

class UniffiCallbackInterfaceRecoveryStateListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRecoveryStateListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeRecoveryState.INSTANCE.Lift(@status));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRecoveryStateListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRecoveryStateListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRecoveryStateListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRecoveryStateListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRecoveryStateListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(
            ref UniffiCallbackInterfaceRecoveryStateListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRecoveryStateListener : FfiConverter<RecoveryStateListener, ulong>
{
    public static FfiConverterTypeRecoveryStateListener INSTANCE = new FfiConverterTypeRecoveryStateListener();

    public ConcurrentHandleMap<RecoveryStateListener> handleMap = new ConcurrentHandleMap<RecoveryStateListener>();

    public override ulong Lower(RecoveryStateListener value)
    {
        return handleMap.Insert(value);
    }

    public override RecoveryStateListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RecoveryStateListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RecoveryStateListener value)
    {
        return 8;
    }

    public override void Write(RecoveryStateListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RoomDirectorySearchEntriesListener
{
    void OnUpdate(List<RoomDirectorySearchEntryUpdate> @roomEntriesUpdate);
}

class UniffiCallbackInterfaceRoomDirectorySearchEntriesListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @roomEntriesUpdate,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRoomDirectorySearchEntriesListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(
                FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate.INSTANCE.Lift(@roomEntriesUpdate)
            );
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRoomDirectorySearchEntriesListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(
            ref UniffiCallbackInterfaceRoomDirectorySearchEntriesListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRoomDirectorySearchEntriesListener : FfiConverter<RoomDirectorySearchEntriesListener, ulong>
{
    public static FfiConverterTypeRoomDirectorySearchEntriesListener INSTANCE =
        new FfiConverterTypeRoomDirectorySearchEntriesListener();

    public ConcurrentHandleMap<RoomDirectorySearchEntriesListener> handleMap =
        new ConcurrentHandleMap<RoomDirectorySearchEntriesListener>();

    public override ulong Lower(RoomDirectorySearchEntriesListener value)
    {
        return handleMap.Insert(value);
    }

    public override RoomDirectorySearchEntriesListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RoomDirectorySearchEntriesListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RoomDirectorySearchEntriesListener value)
    {
        return 8;
    }

    public override void Write(RoomDirectorySearchEntriesListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RoomInfoListener
{
    void Call(RoomInfo @roomInfo);
}

class UniffiCallbackInterfaceRoomInfoListener
{
    static void Call(
        ulong @uniffiHandle,
        RustBuffer @roomInfo,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRoomInfoListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.Call(FfiConverterTypeRoomInfo.INSTANCE.Lift(@roomInfo));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRoomInfoListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRoomInfoListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRoomInfoListenerMethod0(Call);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRoomInfoListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRoomInfoListener
        {
            @call = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(
            ref UniffiCallbackInterfaceRoomInfoListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRoomInfoListener : FfiConverter<RoomInfoListener, ulong>
{
    public static FfiConverterTypeRoomInfoListener INSTANCE = new FfiConverterTypeRoomInfoListener();

    public ConcurrentHandleMap<RoomInfoListener> handleMap = new ConcurrentHandleMap<RoomInfoListener>();

    public override ulong Lower(RoomInfoListener value)
    {
        return handleMap.Insert(value);
    }

    public override RoomInfoListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RoomInfoListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RoomInfoListener value)
    {
        return 8;
    }

    public override void Write(RoomInfoListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RoomListEntriesListener
{
    void OnUpdate(List<RoomListEntriesUpdate> @roomEntriesUpdate);
}

class UniffiCallbackInterfaceRoomListEntriesListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @roomEntriesUpdate,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRoomListEntriesListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterSequenceTypeRoomListEntriesUpdate.INSTANCE.Lift(@roomEntriesUpdate));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRoomListEntriesListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRoomListEntriesListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRoomListEntriesListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRoomListEntriesListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRoomListEntriesListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(
            ref UniffiCallbackInterfaceRoomListEntriesListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRoomListEntriesListener : FfiConverter<RoomListEntriesListener, ulong>
{
    public static FfiConverterTypeRoomListEntriesListener INSTANCE = new FfiConverterTypeRoomListEntriesListener();

    public ConcurrentHandleMap<RoomListEntriesListener> handleMap = new ConcurrentHandleMap<RoomListEntriesListener>();

    public override ulong Lower(RoomListEntriesListener value)
    {
        return handleMap.Insert(value);
    }

    public override RoomListEntriesListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RoomListEntriesListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RoomListEntriesListener value)
    {
        return 8;
    }

    public override void Write(RoomListEntriesListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RoomListLoadingStateListener
{
    void OnUpdate(RoomListLoadingState @state);
}

class UniffiCallbackInterfaceRoomListLoadingStateListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRoomListLoadingStateListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeRoomListLoadingState.INSTANCE.Lift(@state));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRoomListLoadingStateListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRoomListLoadingStateListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRoomListLoadingStateListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(
            ref UniffiCallbackInterfaceRoomListLoadingStateListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRoomListLoadingStateListener : FfiConverter<RoomListLoadingStateListener, ulong>
{
    public static FfiConverterTypeRoomListLoadingStateListener INSTANCE =
        new FfiConverterTypeRoomListLoadingStateListener();

    public ConcurrentHandleMap<RoomListLoadingStateListener> handleMap =
        new ConcurrentHandleMap<RoomListLoadingStateListener>();

    public override ulong Lower(RoomListLoadingStateListener value)
    {
        return handleMap.Insert(value);
    }

    public override RoomListLoadingStateListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RoomListLoadingStateListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RoomListLoadingStateListener value)
    {
        return 8;
    }

    public override void Write(RoomListLoadingStateListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RoomListServiceStateListener
{
    void OnUpdate(RoomListServiceState @state);
}

class UniffiCallbackInterfaceRoomListServiceStateListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRoomListServiceStateListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeRoomListServiceState.INSTANCE.Lift(@state));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRoomListServiceStateListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRoomListServiceStateListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRoomListServiceStateListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRoomListServiceStateListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRoomListServiceStateListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(
            ref UniffiCallbackInterfaceRoomListServiceStateListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRoomListServiceStateListener : FfiConverter<RoomListServiceStateListener, ulong>
{
    public static FfiConverterTypeRoomListServiceStateListener INSTANCE =
        new FfiConverterTypeRoomListServiceStateListener();

    public ConcurrentHandleMap<RoomListServiceStateListener> handleMap =
        new ConcurrentHandleMap<RoomListServiceStateListener>();

    public override ulong Lower(RoomListServiceStateListener value)
    {
        return handleMap.Insert(value);
    }

    public override RoomListServiceStateListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RoomListServiceStateListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RoomListServiceStateListener value)
    {
        return 8;
    }

    public override void Write(RoomListServiceStateListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface RoomListServiceSyncIndicatorListener
{
    void OnUpdate(RoomListServiceSyncIndicator @syncIndicator);
}

class UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @syncIndicator,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeRoomListServiceSyncIndicatorListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)
        )
        {
            uniffiObject.OnUpdate(FfiConverterTypeRoomListServiceSyncIndicator.INSTANCE.Lift(@syncIndicator));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeRoomListServiceSyncIndicatorListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(
            ref UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeRoomListServiceSyncIndicatorListener : FfiConverter<RoomListServiceSyncIndicatorListener, ulong>
{
    public static FfiConverterTypeRoomListServiceSyncIndicatorListener INSTANCE =
        new FfiConverterTypeRoomListServiceSyncIndicatorListener();

    public ConcurrentHandleMap<RoomListServiceSyncIndicatorListener> handleMap =
        new ConcurrentHandleMap<RoomListServiceSyncIndicatorListener>();

    public override ulong Lower(RoomListServiceSyncIndicatorListener value)
    {
        return handleMap.Insert(value);
    }

    public override RoomListServiceSyncIndicatorListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override RoomListServiceSyncIndicatorListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(RoomListServiceSyncIndicatorListener value)
    {
        return 8;
    }

    public override void Write(RoomListServiceSyncIndicatorListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

/// <summary>
/// A listener to the global (client-wide) error reporter of the send queue.
/// </summary>
internal interface SendQueueRoomErrorListener
{
    /// <summary>
    /// Called every time the send queue has ran into an error for a given room,
    /// which will disable the send queue for that particular room.
    /// </summary>
    void OnError(string @roomId, ClientException @error);
}

class UniffiCallbackInterfaceSendQueueRoomErrorListener
{
    static void OnError(
        ulong @uniffiHandle,
        RustBuffer @roomId,
        RustBuffer @error,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSendQueueRoomErrorListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@roomId),
                FfiConverterTypeClientError.INSTANCE.Lift(@error)
            );
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeSendQueueRoomErrorListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0(OnError);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceSendQueueRoomErrorListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceSendQueueRoomErrorListener
        {
            @onError = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(
            ref UniffiCallbackInterfaceSendQueueRoomErrorListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeSendQueueRoomErrorListener : FfiConverter<SendQueueRoomErrorListener, ulong>
{
    public static FfiConverterTypeSendQueueRoomErrorListener INSTANCE =
        new FfiConverterTypeSendQueueRoomErrorListener();

    public ConcurrentHandleMap<SendQueueRoomErrorListener> handleMap =
        new ConcurrentHandleMap<SendQueueRoomErrorListener>();

    public override ulong Lower(SendQueueRoomErrorListener value)
    {
        return handleMap.Insert(value);
    }

    public override SendQueueRoomErrorListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override SendQueueRoomErrorListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(SendQueueRoomErrorListener value)
    {
        return 8;
    }

    public override void Write(SendQueueRoomErrorListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface SessionVerificationControllerDelegate
{
    void DidReceiveVerificationRequest(SessionVerificationRequestDetails @details);
    void DidAcceptVerificationRequest();
    void DidStartSasVerification();
    void DidReceiveVerificationData(SessionVerificationData @data);
    void DidFail();
    void DidCancel();
    void DidFinish();
}

class UniffiCallbackInterfaceSessionVerificationControllerDelegate
{
    static void DidReceiveVerificationRequest(
        ulong @uniffiHandle,
        RustBuffer @details,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidReceiveVerificationRequest(
                FfiConverterTypeSessionVerificationRequestDetails.INSTANCE.Lift(@details)
            );
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidAcceptVerificationRequest(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidAcceptVerificationRequest();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidStartSasVerification(
        ulong @uniffiHandle,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidStartSasVerification();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidReceiveVerificationData(
        ulong @uniffiHandle,
        RustBuffer @data,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidReceiveVerificationData(FfiConverterTypeSessionVerificationData.INSTANCE.Lift(@data));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidFail(ulong @uniffiHandle, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidFail();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidCancel(ulong @uniffiHandle, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidCancel();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void DidFinish(ulong @uniffiHandle, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
    {
        var handle = @uniffiHandle;
        if (
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.TryGet(
                handle,
                out var uniffiObject
            )
        )
        {
            uniffiObject.DidFinish();
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0(
            DidReceiveVerificationRequest
        );
    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1 _m1 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1(
            DidAcceptVerificationRequest
        );
    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2 _m2 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2(DidStartSasVerification);
    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3 _m3 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3(DidReceiveVerificationData);
    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4 _m4 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4(DidFail);
    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5 _m5 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5(DidCancel);
    static _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6 _m6 =
        new _UniFFILib.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6(DidFinish);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate
        {
            @didReceiveVerificationRequest = Marshal.GetFunctionPointerForDelegate(_m0),
            @didAcceptVerificationRequest = Marshal.GetFunctionPointerForDelegate(_m1),
            @didStartSasVerification = Marshal.GetFunctionPointerForDelegate(_m2),
            @didReceiveVerificationData = Marshal.GetFunctionPointerForDelegate(_m3),
            @didFail = Marshal.GetFunctionPointerForDelegate(_m4),
            @didCancel = Marshal.GetFunctionPointerForDelegate(_m5),
            @didFinish = Marshal.GetFunctionPointerForDelegate(_m6),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(
            ref UniffiCallbackInterfaceSessionVerificationControllerDelegate._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeSessionVerificationControllerDelegate : FfiConverter<SessionVerificationControllerDelegate, ulong>
{
    public static FfiConverterTypeSessionVerificationControllerDelegate INSTANCE =
        new FfiConverterTypeSessionVerificationControllerDelegate();

    public ConcurrentHandleMap<SessionVerificationControllerDelegate> handleMap =
        new ConcurrentHandleMap<SessionVerificationControllerDelegate>();

    public override ulong Lower(SessionVerificationControllerDelegate value)
    {
        return handleMap.Insert(value);
    }

    public override SessionVerificationControllerDelegate Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override SessionVerificationControllerDelegate Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(SessionVerificationControllerDelegate value)
    {
        return 8;
    }

    public override void Write(SessionVerificationControllerDelegate value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface SyncServiceStateObserver
{
    void OnUpdate(SyncServiceState @state);
}

class UniffiCallbackInterfaceSyncServiceStateObserver
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @state,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncServiceStateObserver.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeSyncServiceState.INSTANCE.Lift(@state));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeSyncServiceStateObserver.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceSyncServiceStateObserverMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceSyncServiceStateObserverMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceSyncServiceStateObserver _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceSyncServiceStateObserver
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(
            ref UniffiCallbackInterfaceSyncServiceStateObserver._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeSyncServiceStateObserver : FfiConverter<SyncServiceStateObserver, ulong>
{
    public static FfiConverterTypeSyncServiceStateObserver INSTANCE = new FfiConverterTypeSyncServiceStateObserver();

    public ConcurrentHandleMap<SyncServiceStateObserver> handleMap =
        new ConcurrentHandleMap<SyncServiceStateObserver>();

    public override ulong Lower(SyncServiceStateObserver value)
    {
        return handleMap.Insert(value);
    }

    public override SyncServiceStateObserver Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override SyncServiceStateObserver Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(SyncServiceStateObserver value)
    {
        return 8;
    }

    public override void Write(SyncServiceStateObserver value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface TimelineListener
{
    void OnUpdate(List<TimelineDiff> @diff);
}

class UniffiCallbackInterfaceTimelineListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @diff,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTimelineListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterSequenceTypeTimelineDiff.INSTANCE.Lift(@diff));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeTimelineListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceTimelineListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceTimelineListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceTimelineListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceTimelineListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(
            ref UniffiCallbackInterfaceTimelineListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeTimelineListener : FfiConverter<TimelineListener, ulong>
{
    public static FfiConverterTypeTimelineListener INSTANCE = new FfiConverterTypeTimelineListener();

    public ConcurrentHandleMap<TimelineListener> handleMap = new ConcurrentHandleMap<TimelineListener>();

    public override ulong Lower(TimelineListener value)
    {
        return handleMap.Insert(value);
    }

    public override TimelineListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override TimelineListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(TimelineListener value)
    {
        return 8;
    }

    public override void Write(TimelineListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface TypingNotificationsListener
{
    void Call(List<string> @typingUserIds);
}

class UniffiCallbackInterfaceTypingNotificationsListener
{
    static void Call(
        ulong @uniffiHandle,
        RustBuffer @typingUserIds,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTypingNotificationsListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.Call(FfiConverterSequenceString.INSTANCE.Lift(@typingUserIds));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeTypingNotificationsListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceTypingNotificationsListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceTypingNotificationsListenerMethod0(Call);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceTypingNotificationsListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceTypingNotificationsListener
        {
            @call = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(
            ref UniffiCallbackInterfaceTypingNotificationsListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeTypingNotificationsListener : FfiConverter<TypingNotificationsListener, ulong>
{
    public static FfiConverterTypeTypingNotificationsListener INSTANCE =
        new FfiConverterTypeTypingNotificationsListener();

    public ConcurrentHandleMap<TypingNotificationsListener> handleMap =
        new ConcurrentHandleMap<TypingNotificationsListener>();

    public override ulong Lower(TypingNotificationsListener value)
    {
        return handleMap.Insert(value);
    }

    public override TypingNotificationsListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override TypingNotificationsListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(TypingNotificationsListener value)
    {
        return 8;
    }

    public override void Write(TypingNotificationsListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface UnableToDecryptDelegate
{
    void OnUtd(UnableToDecryptInfo @info);
}

class UniffiCallbackInterfaceUnableToDecryptDelegate
{
    static void OnUtd(
        ulong @uniffiHandle,
        RustBuffer @info,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeUnableToDecryptDelegate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUtd(FfiConverterTypeUnableToDecryptInfo.INSTANCE.Lift(@info));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeUnableToDecryptDelegate.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceUnableToDecryptDelegateMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceUnableToDecryptDelegateMethod0(OnUtd);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceUnableToDecryptDelegate _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceUnableToDecryptDelegate
        {
            @onUtd = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(
            ref UniffiCallbackInterfaceUnableToDecryptDelegate._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeUnableToDecryptDelegate : FfiConverter<UnableToDecryptDelegate, ulong>
{
    public static FfiConverterTypeUnableToDecryptDelegate INSTANCE = new FfiConverterTypeUnableToDecryptDelegate();

    public ConcurrentHandleMap<UnableToDecryptDelegate> handleMap = new ConcurrentHandleMap<UnableToDecryptDelegate>();

    public override ulong Lower(UnableToDecryptDelegate value)
    {
        return handleMap.Insert(value);
    }

    public override UnableToDecryptDelegate Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override UnableToDecryptDelegate Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(UnableToDecryptDelegate value)
    {
        return 8;
    }

    public override void Write(UnableToDecryptDelegate value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface VerificationStateListener
{
    void OnUpdate(VerificationState @status);
}

class UniffiCallbackInterfaceVerificationStateListener
{
    static void OnUpdate(
        ulong @uniffiHandle,
        RustBuffer @status,
        IntPtr @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeVerificationStateListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            uniffiObject.OnUpdate(FfiConverterTypeVerificationState.INSTANCE.Lift(@status));
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeVerificationStateListener.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceVerificationStateListenerMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceVerificationStateListenerMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceVerificationStateListener _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceVerificationStateListener
        {
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(
            ref UniffiCallbackInterfaceVerificationStateListener._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeVerificationStateListener : FfiConverter<VerificationStateListener, ulong>
{
    public static FfiConverterTypeVerificationStateListener INSTANCE = new FfiConverterTypeVerificationStateListener();

    public ConcurrentHandleMap<VerificationStateListener> handleMap =
        new ConcurrentHandleMap<VerificationStateListener>();

    public override ulong Lower(VerificationStateListener value)
    {
        return handleMap.Insert(value);
    }

    public override VerificationStateListener Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override VerificationStateListener Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(VerificationStateListener value)
    {
        return 8;
    }

    public override void Write(VerificationStateListener value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface WidgetCapabilitiesProvider
{
    WidgetCapabilities AcquireCapabilities(WidgetCapabilities @capabilities);
}

class UniffiCallbackInterfaceWidgetCapabilitiesProvider
{
    static void AcquireCapabilities(
        ulong @uniffiHandle,
        RustBuffer @capabilities,
        ref RustBuffer @uniffiOutReturn,
        ref UniffiRustCallStatus _uniffi_out_err
    )
    {
        var handle = @uniffiHandle;
        if (FfiConverterTypeWidgetCapabilitiesProvider.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
        {
            var result = uniffiObject.AcquireCapabilities(
                FfiConverterTypeWidgetCapabilities.INSTANCE.Lift(@capabilities)
            );
            @uniffiOutReturn = FfiConverterTypeWidgetCapabilities.INSTANCE.Lower(result);
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle)
    {
        FfiConverterTypeWidgetCapabilitiesProvider.INSTANCE.handleMap.Remove(@handle);
    }

    static _UniFFILib.UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0 _m0 =
        new _UniFFILib.UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0(AcquireCapabilities);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(
        UniffiFree
    );

    public static _UniFFILib.UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider _vtable =
        new _UniFFILib.UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider
        {
            @acquireCapabilities = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
        };

    public static void Register()
    {
        _UniFFILib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(
            ref UniffiCallbackInterfaceWidgetCapabilitiesProvider._vtable
        );
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeWidgetCapabilitiesProvider : FfiConverter<WidgetCapabilitiesProvider, ulong>
{
    public static FfiConverterTypeWidgetCapabilitiesProvider INSTANCE =
        new FfiConverterTypeWidgetCapabilitiesProvider();

    public ConcurrentHandleMap<WidgetCapabilitiesProvider> handleMap =
        new ConcurrentHandleMap<WidgetCapabilitiesProvider>();

    public override ulong Lower(WidgetCapabilitiesProvider value)
    {
        return handleMap.Insert(value);
    }

    public override WidgetCapabilitiesProvider Lift(ulong value)
    {
        if (handleMap.TryGet(value, out var uniffiCallback))
        {
            return uniffiCallback;
        }
        else
        {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override WidgetCapabilitiesProvider Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(WidgetCapabilitiesProvider value)
    {
        return 8;
    }

    public override void Write(WidgetCapabilitiesProvider value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

class FfiConverterOptionalUInt8 : FfiConverterRustBuffer<byte?>
{
    public static FfiConverterOptionalUInt8 INSTANCE = new FfiConverterOptionalUInt8();

    public override byte? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterUInt8.INSTANCE.Read(stream);
    }

    public override int AllocationSize(byte? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterUInt8.INSTANCE.AllocationSize((byte)value);
        }
    }

    public override void Write(byte? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterUInt8.INSTANCE.Write((byte)value, stream);
        }
    }
}

class FfiConverterOptionalUInt16 : FfiConverterRustBuffer<ushort?>
{
    public static FfiConverterOptionalUInt16 INSTANCE = new FfiConverterOptionalUInt16();

    public override ushort? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterUInt16.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ushort? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterUInt16.INSTANCE.AllocationSize((ushort)value);
        }
    }

    public override void Write(ushort? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterUInt16.INSTANCE.Write((ushort)value, stream);
        }
    }
}

class FfiConverterOptionalUInt32 : FfiConverterRustBuffer<uint?>
{
    public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

    public override uint? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterUInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(uint? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
        }
    }

    public override void Write(uint? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
        }
    }
}

class FfiConverterOptionalInt32 : FfiConverterRustBuffer<int?>
{
    public static FfiConverterOptionalInt32 INSTANCE = new FfiConverterOptionalInt32();

    public override int? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(int? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterInt32.INSTANCE.AllocationSize((int)value);
        }
    }

    public override void Write(int? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterInt32.INSTANCE.Write((int)value, stream);
        }
    }
}

class FfiConverterOptionalUInt64 : FfiConverterRustBuffer<ulong?>
{
    public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

    public override ulong? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterUInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ulong? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
        }
    }

    public override void Write(ulong? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
        }
    }
}

class FfiConverterOptionalDouble : FfiConverterRustBuffer<double?>
{
    public static FfiConverterOptionalDouble INSTANCE = new FfiConverterOptionalDouble();

    public override double? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterDouble.INSTANCE.Read(stream);
    }

    public override int AllocationSize(double? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterDouble.INSTANCE.AllocationSize((double)value);
        }
    }

    public override void Write(double? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterDouble.INSTANCE.Write((double)value, stream);
        }
    }
}

class FfiConverterOptionalBoolean : FfiConverterRustBuffer<bool?>
{
    public static FfiConverterOptionalBoolean INSTANCE = new FfiConverterOptionalBoolean();

    public override bool? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterBoolean.INSTANCE.Read(stream);
    }

    public override int AllocationSize(bool? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterBoolean.INSTANCE.AllocationSize((bool)value);
        }
    }

    public override void Write(bool? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterBoolean.INSTANCE.Write((bool)value, stream);
        }
    }
}

class FfiConverterOptionalString : FfiConverterRustBuffer<string?>
{
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}

class FfiConverterOptionalDuration : FfiConverterRustBuffer<TimeSpan?>
{
    public static FfiConverterOptionalDuration INSTANCE = new FfiConverterOptionalDuration();

    public override TimeSpan? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterDuration.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TimeSpan? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterDuration.INSTANCE.AllocationSize((TimeSpan)value);
        }
    }

    public override void Write(TimeSpan? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterDuration.INSTANCE.Write((TimeSpan)value, stream);
        }
    }
}

class FfiConverterOptionalTypeIdentityResetHandle : FfiConverterRustBuffer<IdentityResetHandle?>
{
    public static FfiConverterOptionalTypeIdentityResetHandle INSTANCE =
        new FfiConverterOptionalTypeIdentityResetHandle();

    public override IdentityResetHandle? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeIdentityResetHandle.INSTANCE.Read(stream);
    }

    public override int AllocationSize(IdentityResetHandle? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeIdentityResetHandle.INSTANCE.AllocationSize((IdentityResetHandle)value);
        }
    }

    public override void Write(IdentityResetHandle? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeIdentityResetHandle.INSTANCE.Write((IdentityResetHandle)value, stream);
        }
    }
}

class FfiConverterOptionalTypeInReplyToDetails : FfiConverterRustBuffer<InReplyToDetails?>
{
    public static FfiConverterOptionalTypeInReplyToDetails INSTANCE = new FfiConverterOptionalTypeInReplyToDetails();

    public override InReplyToDetails? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeInReplyToDetails.INSTANCE.Read(stream);
    }

    public override int AllocationSize(InReplyToDetails? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeInReplyToDetails.INSTANCE.AllocationSize((InReplyToDetails)value);
        }
    }

    public override void Write(InReplyToDetails? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeInReplyToDetails.INSTANCE.Write((InReplyToDetails)value, stream);
        }
    }
}

class FfiConverterOptionalTypeMediaSource : FfiConverterRustBuffer<MediaSource?>
{
    public static FfiConverterOptionalTypeMediaSource INSTANCE = new FfiConverterOptionalTypeMediaSource();

    public override MediaSource? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeMediaSource.INSTANCE.Read(stream);
    }

    public override int AllocationSize(MediaSource? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeMediaSource.INSTANCE.AllocationSize((MediaSource)value);
        }
    }

    public override void Write(MediaSource? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeMediaSource.INSTANCE.Write((MediaSource)value, stream);
        }
    }
}

class FfiConverterOptionalTypeRoom : FfiConverterRustBuffer<Room?>
{
    public static FfiConverterOptionalTypeRoom INSTANCE = new FfiConverterOptionalTypeRoom();

    public override Room? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRoom.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Room? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeRoom.INSTANCE.AllocationSize((Room)value);
        }
    }

    public override void Write(Room? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRoom.INSTANCE.Write((Room)value, stream);
        }
    }
}

class FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation
    : FfiConverterRustBuffer<RoomMessageEventContentWithoutRelation?>
{
    public static FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation INSTANCE =
        new FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation();

    public override RoomMessageEventContentWithoutRelation? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RoomMessageEventContentWithoutRelation? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.AllocationSize(
                    (RoomMessageEventContentWithoutRelation)value
                );
        }
    }

    public override void Write(RoomMessageEventContentWithoutRelation? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Write(
                (RoomMessageEventContentWithoutRelation)value,
                stream
            );
        }
    }
}

class FfiConverterOptionalTypeSendHandle : FfiConverterRustBuffer<SendHandle?>
{
    public static FfiConverterOptionalTypeSendHandle INSTANCE = new FfiConverterOptionalTypeSendHandle();

    public override SendHandle? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeSendHandle.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SendHandle? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeSendHandle.INSTANCE.AllocationSize((SendHandle)value);
        }
    }

    public override void Write(SendHandle? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeSendHandle.INSTANCE.Write((SendHandle)value, stream);
        }
    }
}

class FfiConverterOptionalTypeTaskHandle : FfiConverterRustBuffer<TaskHandle?>
{
    public static FfiConverterOptionalTypeTaskHandle INSTANCE = new FfiConverterOptionalTypeTaskHandle();

    public override TaskHandle? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeTaskHandle.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TaskHandle? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeTaskHandle.INSTANCE.AllocationSize((TaskHandle)value);
        }
    }

    public override void Write(TaskHandle? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeTaskHandle.INSTANCE.Write((TaskHandle)value, stream);
        }
    }
}

class FfiConverterOptionalTypeTimelineEventTypeFilter : FfiConverterRustBuffer<TimelineEventTypeFilter?>
{
    public static FfiConverterOptionalTypeTimelineEventTypeFilter INSTANCE =
        new FfiConverterOptionalTypeTimelineEventTypeFilter();

    public override TimelineEventTypeFilter? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeTimelineEventTypeFilter.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TimelineEventTypeFilter? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeTimelineEventTypeFilter.INSTANCE.AllocationSize((TimelineEventTypeFilter)value);
        }
    }

    public override void Write(TimelineEventTypeFilter? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeTimelineEventTypeFilter.INSTANCE.Write((TimelineEventTypeFilter)value, stream);
        }
    }
}

class FfiConverterOptionalTypeTimelineItem : FfiConverterRustBuffer<TimelineItem?>
{
    public static FfiConverterOptionalTypeTimelineItem INSTANCE = new FfiConverterOptionalTypeTimelineItem();

    public override TimelineItem? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeTimelineItem.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TimelineItem? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeTimelineItem.INSTANCE.AllocationSize((TimelineItem)value);
        }
    }

    public override void Write(TimelineItem? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeTimelineItem.INSTANCE.Write((TimelineItem)value, stream);
        }
    }
}

class FfiConverterOptionalTypeUserIdentity : FfiConverterRustBuffer<UserIdentity?>
{
    public static FfiConverterOptionalTypeUserIdentity INSTANCE = new FfiConverterOptionalTypeUserIdentity();

    public override UserIdentity? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeUserIdentity.INSTANCE.Read(stream);
    }

    public override int AllocationSize(UserIdentity? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeUserIdentity.INSTANCE.AllocationSize((UserIdentity)value);
        }
    }

    public override void Write(UserIdentity? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeUserIdentity.INSTANCE.Write((UserIdentity)value, stream);
        }
    }
}

class FfiConverterOptionalTypeAudioInfo : FfiConverterRustBuffer<AudioInfo?>
{
    public static FfiConverterOptionalTypeAudioInfo INSTANCE = new FfiConverterOptionalTypeAudioInfo();

    public override AudioInfo? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeAudioInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(AudioInfo? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeAudioInfo.INSTANCE.AllocationSize((AudioInfo)value);
        }
    }

    public override void Write(AudioInfo? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeAudioInfo.INSTANCE.Write((AudioInfo)value, stream);
        }
    }
}

class FfiConverterOptionalTypeComposerDraft : FfiConverterRustBuffer<ComposerDraft?>
{
    public static FfiConverterOptionalTypeComposerDraft INSTANCE = new FfiConverterOptionalTypeComposerDraft();

    public override ComposerDraft? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeComposerDraft.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ComposerDraft? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeComposerDraft.INSTANCE.AllocationSize((ComposerDraft)value);
        }
    }

    public override void Write(ComposerDraft? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeComposerDraft.INSTANCE.Write((ComposerDraft)value, stream);
        }
    }
}

class FfiConverterOptionalTypeElementCallWellKnown : FfiConverterRustBuffer<ElementCallWellKnown?>
{
    public static FfiConverterOptionalTypeElementCallWellKnown INSTANCE =
        new FfiConverterOptionalTypeElementCallWellKnown();

    public override ElementCallWellKnown? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeElementCallWellKnown.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ElementCallWellKnown? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeElementCallWellKnown.INSTANCE.AllocationSize((ElementCallWellKnown)value);
        }
    }

    public override void Write(ElementCallWellKnown? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeElementCallWellKnown.INSTANCE.Write((ElementCallWellKnown)value, stream);
        }
    }
}

class FfiConverterOptionalTypeEventTimelineItem : FfiConverterRustBuffer<EventTimelineItem?>
{
    public static FfiConverterOptionalTypeEventTimelineItem INSTANCE = new FfiConverterOptionalTypeEventTimelineItem();

    public override EventTimelineItem? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeEventTimelineItem.INSTANCE.Read(stream);
    }

    public override int AllocationSize(EventTimelineItem? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeEventTimelineItem.INSTANCE.AllocationSize((EventTimelineItem)value);
        }
    }

    public override void Write(EventTimelineItem? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeEventTimelineItem.INSTANCE.Write((EventTimelineItem)value, stream);
        }
    }
}

class FfiConverterOptionalTypeFileInfo : FfiConverterRustBuffer<FileInfo?>
{
    public static FfiConverterOptionalTypeFileInfo INSTANCE = new FfiConverterOptionalTypeFileInfo();

    public override FileInfo? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeFileInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(FileInfo? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeFileInfo.INSTANCE.AllocationSize((FileInfo)value);
        }
    }

    public override void Write(FileInfo? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeFileInfo.INSTANCE.Write((FileInfo)value, stream);
        }
    }
}

class FfiConverterOptionalTypeFormattedBody : FfiConverterRustBuffer<FormattedBody?>
{
    public static FfiConverterOptionalTypeFormattedBody INSTANCE = new FfiConverterOptionalTypeFormattedBody();

    public override FormattedBody? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeFormattedBody.INSTANCE.Read(stream);
    }

    public override int AllocationSize(FormattedBody? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeFormattedBody.INSTANCE.AllocationSize((FormattedBody)value);
        }
    }

    public override void Write(FormattedBody? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeFormattedBody.INSTANCE.Write((FormattedBody)value, stream);
        }
    }
}

class FfiConverterOptionalTypeImageInfo : FfiConverterRustBuffer<ImageInfo?>
{
    public static FfiConverterOptionalTypeImageInfo INSTANCE = new FfiConverterOptionalTypeImageInfo();

    public override ImageInfo? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeImageInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ImageInfo? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeImageInfo.INSTANCE.AllocationSize((ImageInfo)value);
        }
    }

    public override void Write(ImageInfo? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeImageInfo.INSTANCE.Write((ImageInfo)value, stream);
        }
    }
}

class FfiConverterOptionalTypeInsertData : FfiConverterRustBuffer<InsertData?>
{
    public static FfiConverterOptionalTypeInsertData INSTANCE = new FfiConverterOptionalTypeInsertData();

    public override InsertData? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeInsertData.INSTANCE.Read(stream);
    }

    public override int AllocationSize(InsertData? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeInsertData.INSTANCE.AllocationSize((InsertData)value);
        }
    }

    public override void Write(InsertData? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeInsertData.INSTANCE.Write((InsertData)value, stream);
        }
    }
}

class FfiConverterOptionalTypeMatrixEntity : FfiConverterRustBuffer<MatrixEntity?>
{
    public static FfiConverterOptionalTypeMatrixEntity INSTANCE = new FfiConverterOptionalTypeMatrixEntity();

    public override MatrixEntity? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeMatrixEntity.INSTANCE.Read(stream);
    }

    public override int AllocationSize(MatrixEntity? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeMatrixEntity.INSTANCE.AllocationSize((MatrixEntity)value);
        }
    }

    public override void Write(MatrixEntity? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeMatrixEntity.INSTANCE.Write((MatrixEntity)value, stream);
        }
    }
}

class FfiConverterOptionalTypeMentions : FfiConverterRustBuffer<Mentions?>
{
    public static FfiConverterOptionalTypeMentions INSTANCE = new FfiConverterOptionalTypeMentions();

    public override Mentions? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeMentions.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Mentions? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeMentions.INSTANCE.AllocationSize((Mentions)value);
        }
    }

    public override void Write(Mentions? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeMentions.INSTANCE.Write((Mentions)value, stream);
        }
    }
}

class FfiConverterOptionalTypeNotificationItem : FfiConverterRustBuffer<NotificationItem?>
{
    public static FfiConverterOptionalTypeNotificationItem INSTANCE = new FfiConverterOptionalTypeNotificationItem();

    public override NotificationItem? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeNotificationItem.INSTANCE.Read(stream);
    }

    public override int AllocationSize(NotificationItem? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeNotificationItem.INSTANCE.AllocationSize((NotificationItem)value);
        }
    }

    public override void Write(NotificationItem? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeNotificationItem.INSTANCE.Write((NotificationItem)value, stream);
        }
    }
}

class FfiConverterOptionalTypeNotificationPowerLevels : FfiConverterRustBuffer<NotificationPowerLevels?>
{
    public static FfiConverterOptionalTypeNotificationPowerLevels INSTANCE =
        new FfiConverterOptionalTypeNotificationPowerLevels();

    public override NotificationPowerLevels? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeNotificationPowerLevels.INSTANCE.Read(stream);
    }

    public override int AllocationSize(NotificationPowerLevels? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeNotificationPowerLevels.INSTANCE.AllocationSize((NotificationPowerLevels)value);
        }
    }

    public override void Write(NotificationPowerLevels? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeNotificationPowerLevels.INSTANCE.Write((NotificationPowerLevels)value, stream);
        }
    }
}

class FfiConverterOptionalTypePowerLevels : FfiConverterRustBuffer<PowerLevels?>
{
    public static FfiConverterOptionalTypePowerLevels INSTANCE = new FfiConverterOptionalTypePowerLevels();

    public override PowerLevels? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypePowerLevels.INSTANCE.Read(stream);
    }

    public override int AllocationSize(PowerLevels? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypePowerLevels.INSTANCE.AllocationSize((PowerLevels)value);
        }
    }

    public override void Write(PowerLevels? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypePowerLevels.INSTANCE.Write((PowerLevels)value, stream);
        }
    }
}

class FfiConverterOptionalTypeReplyParameters : FfiConverterRustBuffer<ReplyParameters?>
{
    public static FfiConverterOptionalTypeReplyParameters INSTANCE = new FfiConverterOptionalTypeReplyParameters();

    public override ReplyParameters? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeReplyParameters.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ReplyParameters? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeReplyParameters.INSTANCE.AllocationSize((ReplyParameters)value);
        }
    }

    public override void Write(ReplyParameters? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeReplyParameters.INSTANCE.Write((ReplyParameters)value, stream);
        }
    }
}

class FfiConverterOptionalTypeResolvedRoomAlias : FfiConverterRustBuffer<ResolvedRoomAlias?>
{
    public static FfiConverterOptionalTypeResolvedRoomAlias INSTANCE = new FfiConverterOptionalTypeResolvedRoomAlias();

    public override ResolvedRoomAlias? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeResolvedRoomAlias.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ResolvedRoomAlias? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeResolvedRoomAlias.INSTANCE.AllocationSize((ResolvedRoomAlias)value);
        }
    }

    public override void Write(ResolvedRoomAlias? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeResolvedRoomAlias.INSTANCE.Write((ResolvedRoomAlias)value, stream);
        }
    }
}

class FfiConverterOptionalTypeRoomMember : FfiConverterRustBuffer<RoomMember?>
{
    public static FfiConverterOptionalTypeRoomMember INSTANCE = new FfiConverterOptionalTypeRoomMember();

    public override RoomMember? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRoomMember.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RoomMember? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeRoomMember.INSTANCE.AllocationSize((RoomMember)value);
        }
    }

    public override void Write(RoomMember? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRoomMember.INSTANCE.Write((RoomMember)value, stream);
        }
    }
}

class FfiConverterOptionalTypeRoomMembershipDetails : FfiConverterRustBuffer<RoomMembershipDetails?>
{
    public static FfiConverterOptionalTypeRoomMembershipDetails INSTANCE =
        new FfiConverterOptionalTypeRoomMembershipDetails();

    public override RoomMembershipDetails? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRoomMembershipDetails.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RoomMembershipDetails? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeRoomMembershipDetails.INSTANCE.AllocationSize((RoomMembershipDetails)value);
        }
    }

    public override void Write(RoomMembershipDetails? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRoomMembershipDetails.INSTANCE.Write((RoomMembershipDetails)value, stream);
        }
    }
}

class FfiConverterOptionalTypeSetData : FfiConverterRustBuffer<SetData?>
{
    public static FfiConverterOptionalTypeSetData INSTANCE = new FfiConverterOptionalTypeSetData();

    public override SetData? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeSetData.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SetData? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeSetData.INSTANCE.AllocationSize((SetData)value);
        }
    }

    public override void Write(SetData? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeSetData.INSTANCE.Write((SetData)value, stream);
        }
    }
}

class FfiConverterOptionalTypeThumbnailInfo : FfiConverterRustBuffer<ThumbnailInfo?>
{
    public static FfiConverterOptionalTypeThumbnailInfo INSTANCE = new FfiConverterOptionalTypeThumbnailInfo();

    public override ThumbnailInfo? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeThumbnailInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ThumbnailInfo? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeThumbnailInfo.INSTANCE.AllocationSize((ThumbnailInfo)value);
        }
    }

    public override void Write(ThumbnailInfo? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeThumbnailInfo.INSTANCE.Write((ThumbnailInfo)value, stream);
        }
    }
}

class FfiConverterOptionalTypeTracingFileConfiguration : FfiConverterRustBuffer<TracingFileConfiguration?>
{
    public static FfiConverterOptionalTypeTracingFileConfiguration INSTANCE =
        new FfiConverterOptionalTypeTracingFileConfiguration();

    public override TracingFileConfiguration? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeTracingFileConfiguration.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TracingFileConfiguration? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeTracingFileConfiguration.INSTANCE.AllocationSize((TracingFileConfiguration)value);
        }
    }

    public override void Write(TracingFileConfiguration? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeTracingFileConfiguration.INSTANCE.Write((TracingFileConfiguration)value, stream);
        }
    }
}

class FfiConverterOptionalTypeUnstableAudioDetailsContent : FfiConverterRustBuffer<UnstableAudioDetailsContent?>
{
    public static FfiConverterOptionalTypeUnstableAudioDetailsContent INSTANCE =
        new FfiConverterOptionalTypeUnstableAudioDetailsContent();

    public override UnstableAudioDetailsContent? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeUnstableAudioDetailsContent.INSTANCE.Read(stream);
    }

    public override int AllocationSize(UnstableAudioDetailsContent? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeUnstableAudioDetailsContent.INSTANCE.AllocationSize(
                    (UnstableAudioDetailsContent)value
                );
        }
    }

    public override void Write(UnstableAudioDetailsContent? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeUnstableAudioDetailsContent.INSTANCE.Write((UnstableAudioDetailsContent)value, stream);
        }
    }
}

class FfiConverterOptionalTypeUnstableVoiceContent : FfiConverterRustBuffer<UnstableVoiceContent?>
{
    public static FfiConverterOptionalTypeUnstableVoiceContent INSTANCE =
        new FfiConverterOptionalTypeUnstableVoiceContent();

    public override UnstableVoiceContent? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeUnstableVoiceContent.INSTANCE.Read(stream);
    }

    public override int AllocationSize(UnstableVoiceContent? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeUnstableVoiceContent.INSTANCE.AllocationSize((UnstableVoiceContent)value);
        }
    }

    public override void Write(UnstableVoiceContent? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeUnstableVoiceContent.INSTANCE.Write((UnstableVoiceContent)value, stream);
        }
    }
}

class FfiConverterOptionalTypeVideoInfo : FfiConverterRustBuffer<VideoInfo?>
{
    public static FfiConverterOptionalTypeVideoInfo INSTANCE = new FfiConverterOptionalTypeVideoInfo();

    public override VideoInfo? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeVideoInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(VideoInfo? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeVideoInfo.INSTANCE.AllocationSize((VideoInfo)value);
        }
    }

    public override void Write(VideoInfo? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeVideoInfo.INSTANCE.Write((VideoInfo)value, stream);
        }
    }
}

class FfiConverterOptionalTypeAccountManagementAction : FfiConverterRustBuffer<AccountManagementAction?>
{
    public static FfiConverterOptionalTypeAccountManagementAction INSTANCE =
        new FfiConverterOptionalTypeAccountManagementAction();

    public override AccountManagementAction? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeAccountManagementAction.INSTANCE.Read(stream);
    }

    public override int AllocationSize(AccountManagementAction? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeAccountManagementAction.INSTANCE.AllocationSize((AccountManagementAction)value);
        }
    }

    public override void Write(AccountManagementAction? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeAccountManagementAction.INSTANCE.Write((AccountManagementAction)value, stream);
        }
    }
}

class FfiConverterOptionalTypeAssetType : FfiConverterRustBuffer<AssetType?>
{
    public static FfiConverterOptionalTypeAssetType INSTANCE = new FfiConverterOptionalTypeAssetType();

    public override AssetType? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeAssetType.INSTANCE.Read(stream);
    }

    public override int AllocationSize(AssetType? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeAssetType.INSTANCE.AllocationSize((AssetType)value);
        }
    }

    public override void Write(AssetType? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeAssetType.INSTANCE.Write((AssetType)value, stream);
        }
    }
}

class FfiConverterOptionalTypeAuthData : FfiConverterRustBuffer<AuthData?>
{
    public static FfiConverterOptionalTypeAuthData INSTANCE = new FfiConverterOptionalTypeAuthData();

    public override AuthData? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeAuthData.INSTANCE.Read(stream);
    }

    public override int AllocationSize(AuthData? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeAuthData.INSTANCE.AllocationSize((AuthData)value);
        }
    }

    public override void Write(AuthData? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeAuthData.INSTANCE.Write((AuthData)value, stream);
        }
    }
}

class FfiConverterOptionalTypeEventSendState : FfiConverterRustBuffer<EventSendState?>
{
    public static FfiConverterOptionalTypeEventSendState INSTANCE = new FfiConverterOptionalTypeEventSendState();

    public override EventSendState? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeEventSendState.INSTANCE.Read(stream);
    }

    public override int AllocationSize(EventSendState? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeEventSendState.INSTANCE.AllocationSize((EventSendState)value);
        }
    }

    public override void Write(EventSendState? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeEventSendState.INSTANCE.Write((EventSendState)value, stream);
        }
    }
}

class FfiConverterOptionalTypeIntent : FfiConverterRustBuffer<Intent?>
{
    public static FfiConverterOptionalTypeIntent INSTANCE = new FfiConverterOptionalTypeIntent();

    public override Intent? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeIntent.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Intent? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeIntent.INSTANCE.AllocationSize((Intent)value);
        }
    }

    public override void Write(Intent? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeIntent.INSTANCE.Write((Intent)value, stream);
        }
    }
}

class FfiConverterOptionalTypeJoinRule : FfiConverterRustBuffer<JoinRule?>
{
    public static FfiConverterOptionalTypeJoinRule INSTANCE = new FfiConverterOptionalTypeJoinRule();

    public override JoinRule? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeJoinRule.INSTANCE.Read(stream);
    }

    public override int AllocationSize(JoinRule? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeJoinRule.INSTANCE.AllocationSize((JoinRule)value);
        }
    }

    public override void Write(JoinRule? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeJoinRule.INSTANCE.Write((JoinRule)value, stream);
        }
    }
}

class FfiConverterOptionalTypeMembership : FfiConverterRustBuffer<Membership?>
{
    public static FfiConverterOptionalTypeMembership INSTANCE = new FfiConverterOptionalTypeMembership();

    public override Membership? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeMembership.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Membership? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeMembership.INSTANCE.AllocationSize((Membership)value);
        }
    }

    public override void Write(Membership? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeMembership.INSTANCE.Write((Membership)value, stream);
        }
    }
}

class FfiConverterOptionalTypeMembershipChange : FfiConverterRustBuffer<MembershipChange?>
{
    public static FfiConverterOptionalTypeMembershipChange INSTANCE = new FfiConverterOptionalTypeMembershipChange();

    public override MembershipChange? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeMembershipChange.INSTANCE.Read(stream);
    }

    public override int AllocationSize(MembershipChange? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeMembershipChange.INSTANCE.AllocationSize((MembershipChange)value);
        }
    }

    public override void Write(MembershipChange? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeMembershipChange.INSTANCE.Write((MembershipChange)value, stream);
        }
    }
}

class FfiConverterOptionalTypeOidcPrompt : FfiConverterRustBuffer<OidcPrompt?>
{
    public static FfiConverterOptionalTypeOidcPrompt INSTANCE = new FfiConverterOptionalTypeOidcPrompt();

    public override OidcPrompt? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeOidcPrompt.INSTANCE.Read(stream);
    }

    public override int AllocationSize(OidcPrompt? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeOidcPrompt.INSTANCE.AllocationSize((OidcPrompt)value);
        }
    }

    public override void Write(OidcPrompt? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeOidcPrompt.INSTANCE.Write((OidcPrompt)value, stream);
        }
    }
}

class FfiConverterOptionalTypePublicRoomJoinRule : FfiConverterRustBuffer<PublicRoomJoinRule?>
{
    public static FfiConverterOptionalTypePublicRoomJoinRule INSTANCE =
        new FfiConverterOptionalTypePublicRoomJoinRule();

    public override PublicRoomJoinRule? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypePublicRoomJoinRule.INSTANCE.Read(stream);
    }

    public override int AllocationSize(PublicRoomJoinRule? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypePublicRoomJoinRule.INSTANCE.AllocationSize((PublicRoomJoinRule)value);
        }
    }

    public override void Write(PublicRoomJoinRule? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypePublicRoomJoinRule.INSTANCE.Write((PublicRoomJoinRule)value, stream);
        }
    }
}

class FfiConverterOptionalTypePushFormat : FfiConverterRustBuffer<PushFormat?>
{
    public static FfiConverterOptionalTypePushFormat INSTANCE = new FfiConverterOptionalTypePushFormat();

    public override PushFormat? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypePushFormat.INSTANCE.Read(stream);
    }

    public override int AllocationSize(PushFormat? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypePushFormat.INSTANCE.AllocationSize((PushFormat)value);
        }
    }

    public override void Write(PushFormat? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypePushFormat.INSTANCE.Write((PushFormat)value, stream);
        }
    }
}

class FfiConverterOptionalTypeRoomHistoryVisibility : FfiConverterRustBuffer<RoomHistoryVisibility?>
{
    public static FfiConverterOptionalTypeRoomHistoryVisibility INSTANCE =
        new FfiConverterOptionalTypeRoomHistoryVisibility();

    public override RoomHistoryVisibility? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRoomHistoryVisibility.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RoomHistoryVisibility? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeRoomHistoryVisibility.INSTANCE.AllocationSize((RoomHistoryVisibility)value);
        }
    }

    public override void Write(RoomHistoryVisibility? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRoomHistoryVisibility.INSTANCE.Write((RoomHistoryVisibility)value, stream);
        }
    }
}

class FfiConverterOptionalTypeRoomNotificationMode : FfiConverterRustBuffer<RoomNotificationMode?>
{
    public static FfiConverterOptionalTypeRoomNotificationMode INSTANCE =
        new FfiConverterOptionalTypeRoomNotificationMode();

    public override RoomNotificationMode? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRoomNotificationMode.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RoomNotificationMode? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeRoomNotificationMode.INSTANCE.AllocationSize((RoomNotificationMode)value);
        }
    }

    public override void Write(RoomNotificationMode? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRoomNotificationMode.INSTANCE.Write((RoomNotificationMode)value, stream);
        }
    }
}

class FfiConverterOptionalTypeShieldState : FfiConverterRustBuffer<ShieldState?>
{
    public static FfiConverterOptionalTypeShieldState INSTANCE = new FfiConverterOptionalTypeShieldState();

    public override ShieldState? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeShieldState.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ShieldState? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeShieldState.INSTANCE.AllocationSize((ShieldState)value);
        }
    }

    public override void Write(ShieldState? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeShieldState.INSTANCE.Write((ShieldState)value, stream);
        }
    }
}

class FfiConverterOptionalTypeVirtualTimelineItem : FfiConverterRustBuffer<VirtualTimelineItem?>
{
    public static FfiConverterOptionalTypeVirtualTimelineItem INSTANCE =
        new FfiConverterOptionalTypeVirtualTimelineItem();

    public override VirtualTimelineItem? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeVirtualTimelineItem.INSTANCE.Read(stream);
    }

    public override int AllocationSize(VirtualTimelineItem? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeVirtualTimelineItem.INSTANCE.AllocationSize((VirtualTimelineItem)value);
        }
    }

    public override void Write(VirtualTimelineItem? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeVirtualTimelineItem.INSTANCE.Write((VirtualTimelineItem)value, stream);
        }
    }
}

class FfiConverterOptionalTypeBackupSteadyStateListener : FfiConverterRustBuffer<BackupSteadyStateListener?>
{
    public static FfiConverterOptionalTypeBackupSteadyStateListener INSTANCE =
        new FfiConverterOptionalTypeBackupSteadyStateListener();

    public override BackupSteadyStateListener? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeBackupSteadyStateListener.INSTANCE.Read(stream);
    }

    public override int AllocationSize(BackupSteadyStateListener? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeBackupSteadyStateListener.INSTANCE.AllocationSize((BackupSteadyStateListener)value);
        }
    }

    public override void Write(BackupSteadyStateListener? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeBackupSteadyStateListener.INSTANCE.Write((BackupSteadyStateListener)value, stream);
        }
    }
}

class FfiConverterOptionalTypeClientDelegate : FfiConverterRustBuffer<ClientDelegate?>
{
    public static FfiConverterOptionalTypeClientDelegate INSTANCE = new FfiConverterOptionalTypeClientDelegate();

    public override ClientDelegate? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeClientDelegate.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ClientDelegate? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeClientDelegate.INSTANCE.AllocationSize((ClientDelegate)value);
        }
    }

    public override void Write(ClientDelegate? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeClientDelegate.INSTANCE.Write((ClientDelegate)value, stream);
        }
    }
}

class FfiConverterOptionalTypeNotificationSettingsDelegate : FfiConverterRustBuffer<NotificationSettingsDelegate?>
{
    public static FfiConverterOptionalTypeNotificationSettingsDelegate INSTANCE =
        new FfiConverterOptionalTypeNotificationSettingsDelegate();

    public override NotificationSettingsDelegate? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeNotificationSettingsDelegate.INSTANCE.Read(stream);
    }

    public override int AllocationSize(NotificationSettingsDelegate? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeNotificationSettingsDelegate.INSTANCE.AllocationSize(
                    (NotificationSettingsDelegate)value
                );
        }
    }

    public override void Write(NotificationSettingsDelegate? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeNotificationSettingsDelegate.INSTANCE.Write((NotificationSettingsDelegate)value, stream);
        }
    }
}

class FfiConverterOptionalTypeProgressWatcher : FfiConverterRustBuffer<ProgressWatcher?>
{
    public static FfiConverterOptionalTypeProgressWatcher INSTANCE = new FfiConverterOptionalTypeProgressWatcher();

    public override ProgressWatcher? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeProgressWatcher.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ProgressWatcher? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeProgressWatcher.INSTANCE.AllocationSize((ProgressWatcher)value);
        }
    }

    public override void Write(ProgressWatcher? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeProgressWatcher.INSTANCE.Write((ProgressWatcher)value, stream);
        }
    }
}

class FfiConverterOptionalTypeSessionVerificationControllerDelegate
    : FfiConverterRustBuffer<SessionVerificationControllerDelegate?>
{
    public static FfiConverterOptionalTypeSessionVerificationControllerDelegate INSTANCE =
        new FfiConverterOptionalTypeSessionVerificationControllerDelegate();

    public override SessionVerificationControllerDelegate? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SessionVerificationControllerDelegate? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.AllocationSize(
                    (SessionVerificationControllerDelegate)value
                );
        }
    }

    public override void Write(SessionVerificationControllerDelegate? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeSessionVerificationControllerDelegate.INSTANCE.Write(
                (SessionVerificationControllerDelegate)value,
                stream
            );
        }
    }
}

class FfiConverterOptionalSequenceString : FfiConverterRustBuffer<List<string>?>
{
    public static FfiConverterOptionalSequenceString INSTANCE = new FfiConverterOptionalSequenceString();

    public override List<string>? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterSequenceString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<string>? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterSequenceString.INSTANCE.AllocationSize((List<string>)value);
        }
    }

    public override void Write(List<string>? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterSequenceString.INSTANCE.Write((List<string>)value, stream);
        }
    }
}

class FfiConverterOptionalSequenceTypeTimelineItem : FfiConverterRustBuffer<List<TimelineItem>?>
{
    public static FfiConverterOptionalSequenceTypeTimelineItem INSTANCE =
        new FfiConverterOptionalSequenceTypeTimelineItem();

    public override List<TimelineItem>? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterSequenceTypeTimelineItem.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<TimelineItem>? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterSequenceTypeTimelineItem.INSTANCE.AllocationSize((List<TimelineItem>)value);
        }
    }

    public override void Write(List<TimelineItem>? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterSequenceTypeTimelineItem.INSTANCE.Write((List<TimelineItem>)value, stream);
        }
    }
}

class FfiConverterOptionalSequenceTypeRoomHero : FfiConverterRustBuffer<List<RoomHero>?>
{
    public static FfiConverterOptionalSequenceTypeRoomHero INSTANCE = new FfiConverterOptionalSequenceTypeRoomHero();

    public override List<RoomHero>? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterSequenceTypeRoomHero.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<RoomHero>? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterSequenceTypeRoomHero.INSTANCE.AllocationSize((List<RoomHero>)value);
        }
    }

    public override void Write(List<RoomHero>? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterSequenceTypeRoomHero.INSTANCE.Write((List<RoomHero>)value, stream);
        }
    }
}

class FfiConverterOptionalSequenceTypeRoomMember : FfiConverterRustBuffer<List<RoomMember>?>
{
    public static FfiConverterOptionalSequenceTypeRoomMember INSTANCE =
        new FfiConverterOptionalSequenceTypeRoomMember();

    public override List<RoomMember>? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterSequenceTypeRoomMember.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<RoomMember>? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterSequenceTypeRoomMember.INSTANCE.AllocationSize((List<RoomMember>)value);
        }
    }

    public override void Write(List<RoomMember>? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterSequenceTypeRoomMember.INSTANCE.Write((List<RoomMember>)value, stream);
        }
    }
}

class FfiConverterOptionalDictionaryStringInt64 : FfiConverterRustBuffer<Dictionary<string, long>?>
{
    public static FfiConverterOptionalDictionaryStringInt64 INSTANCE = new FfiConverterOptionalDictionaryStringInt64();

    public override Dictionary<string, long>? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterDictionaryStringInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Dictionary<string, long>? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterDictionaryStringInt64.INSTANCE.AllocationSize((Dictionary<string, long>)value);
        }
    }

    public override void Write(Dictionary<string, long>? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterDictionaryStringInt64.INSTANCE.Write((Dictionary<string, long>)value, stream);
        }
    }
}

class FfiConverterOptionalTypeEventItemOrigin : FfiConverterRustBuffer<EventItemOrigin?>
{
    public static FfiConverterOptionalTypeEventItemOrigin INSTANCE = new FfiConverterOptionalTypeEventItemOrigin();

    public override EventItemOrigin? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeEventItemOrigin.INSTANCE.Read(stream);
    }

    public override int AllocationSize(EventItemOrigin? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeEventItemOrigin.INSTANCE.AllocationSize((EventItemOrigin)value);
        }
    }

    public override void Write(EventItemOrigin? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeEventItemOrigin.INSTANCE.Write((EventItemOrigin)value, stream);
        }
    }
}

class FfiConverterOptionalTypeTimestamp : FfiConverterRustBuffer<Timestamp?>
{
    public static FfiConverterOptionalTypeTimestamp INSTANCE = new FfiConverterOptionalTypeTimestamp();

    public override Timestamp? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeTimestamp.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Timestamp? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeTimestamp.INSTANCE.AllocationSize((Timestamp)value);
        }
    }

    public override void Write(Timestamp? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeTimestamp.INSTANCE.Write((Timestamp)value, stream);
        }
    }
}

class FfiConverterSequenceUInt16 : FfiConverterRustBuffer<List<ushort>>
{
    public static FfiConverterSequenceUInt16 INSTANCE = new FfiConverterSequenceUInt16();

    public override List<ushort> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<ushort>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterUInt16.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ushort> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterUInt16.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ushort> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterUInt16.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceString : FfiConverterRustBuffer<List<string>>
{
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override List<string> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<string>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterString.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<string> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterString.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<string> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterString.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceByteArray : FfiConverterRustBuffer<List<byte[]>>
{
    public static FfiConverterSequenceByteArray INSTANCE = new FfiConverterSequenceByteArray();

    public override List<byte[]> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<byte[]>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterByteArray.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<byte[]> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterByteArray.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<byte[]> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterByteArray.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoom : FfiConverterRustBuffer<List<Room>>
{
    public static FfiConverterSequenceTypeRoom INSTANCE = new FfiConverterSequenceTypeRoom();

    public override List<Room> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<Room>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoom.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Room> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeRoom.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Room> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoom.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomListItem : FfiConverterRustBuffer<List<RoomListItem>>
{
    public static FfiConverterSequenceTypeRoomListItem INSTANCE = new FfiConverterSequenceTypeRoomListItem();

    public override List<RoomListItem> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomListItem>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomListItem.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomListItem> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeRoomListItem.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomListItem> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomListItem.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeSessionVerificationEmoji : FfiConverterRustBuffer<List<SessionVerificationEmoji>>
{
    public static FfiConverterSequenceTypeSessionVerificationEmoji INSTANCE =
        new FfiConverterSequenceTypeSessionVerificationEmoji();

    public override List<SessionVerificationEmoji> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<SessionVerificationEmoji>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeSessionVerificationEmoji.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<SessionVerificationEmoji> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeSessionVerificationEmoji.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<SessionVerificationEmoji> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeSessionVerificationEmoji.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeTimelineDiff : FfiConverterRustBuffer<List<TimelineDiff>>
{
    public static FfiConverterSequenceTypeTimelineDiff INSTANCE = new FfiConverterSequenceTypeTimelineDiff();

    public override List<TimelineDiff> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<TimelineDiff>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeTimelineDiff.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<TimelineDiff> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeTimelineDiff.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<TimelineDiff> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeTimelineDiff.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeTimelineItem : FfiConverterRustBuffer<List<TimelineItem>>
{
    public static FfiConverterSequenceTypeTimelineItem INSTANCE = new FfiConverterSequenceTypeTimelineItem();

    public override List<TimelineItem> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<TimelineItem>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeTimelineItem.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<TimelineItem> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeTimelineItem.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<TimelineItem> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeTimelineItem.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeIdentityStatusChange : FfiConverterRustBuffer<List<IdentityStatusChange>>
{
    public static FfiConverterSequenceTypeIdentityStatusChange INSTANCE =
        new FfiConverterSequenceTypeIdentityStatusChange();

    public override List<IdentityStatusChange> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<IdentityStatusChange>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeIdentityStatusChange.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<IdentityStatusChange> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeIdentityStatusChange.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<IdentityStatusChange> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeIdentityStatusChange.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeKnockRequest : FfiConverterRustBuffer<List<KnockRequest>>
{
    public static FfiConverterSequenceTypeKnockRequest INSTANCE = new FfiConverterSequenceTypeKnockRequest();

    public override List<KnockRequest> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<KnockRequest>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeKnockRequest.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<KnockRequest> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeKnockRequest.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<KnockRequest> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeKnockRequest.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeLiveLocationShare : FfiConverterRustBuffer<List<LiveLocationShare>>
{
    public static FfiConverterSequenceTypeLiveLocationShare INSTANCE = new FfiConverterSequenceTypeLiveLocationShare();

    public override List<LiveLocationShare> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<LiveLocationShare>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeLiveLocationShare.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<LiveLocationShare> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeLiveLocationShare.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<LiveLocationShare> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeLiveLocationShare.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypePollAnswer : FfiConverterRustBuffer<List<PollAnswer>>
{
    public static FfiConverterSequenceTypePollAnswer INSTANCE = new FfiConverterSequenceTypePollAnswer();

    public override List<PollAnswer> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<PollAnswer>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypePollAnswer.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<PollAnswer> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypePollAnswer.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<PollAnswer> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypePollAnswer.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeReaction : FfiConverterRustBuffer<List<Reaction>>
{
    public static FfiConverterSequenceTypeReaction INSTANCE = new FfiConverterSequenceTypeReaction();

    public override List<Reaction> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<Reaction>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeReaction.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Reaction> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeReaction.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Reaction> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeReaction.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeReactionSenderData : FfiConverterRustBuffer<List<ReactionSenderData>>
{
    public static FfiConverterSequenceTypeReactionSenderData INSTANCE =
        new FfiConverterSequenceTypeReactionSenderData();

    public override List<ReactionSenderData> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<ReactionSenderData>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeReactionSenderData.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ReactionSenderData> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeReactionSenderData.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ReactionSenderData> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeReactionSenderData.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomDescription : FfiConverterRustBuffer<List<RoomDescription>>
{
    public static FfiConverterSequenceTypeRoomDescription INSTANCE = new FfiConverterSequenceTypeRoomDescription();

    public override List<RoomDescription> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomDescription>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomDescription.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomDescription> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeRoomDescription.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomDescription> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomDescription.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomHero : FfiConverterRustBuffer<List<RoomHero>>
{
    public static FfiConverterSequenceTypeRoomHero INSTANCE = new FfiConverterSequenceTypeRoomHero();

    public override List<RoomHero> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomHero>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomHero.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomHero> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeRoomHero.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomHero> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomHero.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomMember : FfiConverterRustBuffer<List<RoomMember>>
{
    public static FfiConverterSequenceTypeRoomMember INSTANCE = new FfiConverterSequenceTypeRoomMember();

    public override List<RoomMember> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomMember>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomMember.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomMember> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeRoomMember.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomMember> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomMember.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeUserPowerLevelUpdate : FfiConverterRustBuffer<List<UserPowerLevelUpdate>>
{
    public static FfiConverterSequenceTypeUserPowerLevelUpdate INSTANCE =
        new FfiConverterSequenceTypeUserPowerLevelUpdate();

    public override List<UserPowerLevelUpdate> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<UserPowerLevelUpdate>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeUserPowerLevelUpdate.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<UserPowerLevelUpdate> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeUserPowerLevelUpdate.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<UserPowerLevelUpdate> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeUserPowerLevelUpdate.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeUserProfile : FfiConverterRustBuffer<List<UserProfile>>
{
    public static FfiConverterSequenceTypeUserProfile INSTANCE = new FfiConverterSequenceTypeUserProfile();

    public override List<UserProfile> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<UserProfile>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeUserProfile.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<UserProfile> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeUserProfile.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<UserProfile> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeUserProfile.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeAction : FfiConverterRustBuffer<List<Action>>
{
    public static FfiConverterSequenceTypeAction INSTANCE = new FfiConverterSequenceTypeAction();

    public override List<Action> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<Action>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeAction.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Action> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeAction.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Action> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeAction.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeAllowRule : FfiConverterRustBuffer<List<AllowRule>>
{
    public static FfiConverterSequenceTypeAllowRule INSTANCE = new FfiConverterSequenceTypeAllowRule();

    public override List<AllowRule> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<AllowRule>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeAllowRule.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<AllowRule> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeAllowRule.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<AllowRule> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeAllowRule.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeFilterTimelineEventType : FfiConverterRustBuffer<List<FilterTimelineEventType>>
{
    public static FfiConverterSequenceTypeFilterTimelineEventType INSTANCE =
        new FfiConverterSequenceTypeFilterTimelineEventType();

    public override List<FilterTimelineEventType> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<FilterTimelineEventType>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeFilterTimelineEventType.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<FilterTimelineEventType> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeFilterTimelineEventType.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<FilterTimelineEventType> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeFilterTimelineEventType.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeMembership : FfiConverterRustBuffer<List<Membership>>
{
    public static FfiConverterSequenceTypeMembership INSTANCE = new FfiConverterSequenceTypeMembership();

    public override List<Membership> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<Membership>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeMembership.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Membership> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeMembership.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Membership> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeMembership.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeOidcPrompt : FfiConverterRustBuffer<List<OidcPrompt>>
{
    public static FfiConverterSequenceTypeOidcPrompt INSTANCE = new FfiConverterSequenceTypeOidcPrompt();

    public override List<OidcPrompt> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<OidcPrompt>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeOidcPrompt.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<OidcPrompt> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeOidcPrompt.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<OidcPrompt> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeOidcPrompt.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypePushCondition : FfiConverterRustBuffer<List<PushCondition>>
{
    public static FfiConverterSequenceTypePushCondition INSTANCE = new FfiConverterSequenceTypePushCondition();

    public override List<PushCondition> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<PushCondition>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypePushCondition.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<PushCondition> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypePushCondition.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<PushCondition> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypePushCondition.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate
    : FfiConverterRustBuffer<List<RoomDirectorySearchEntryUpdate>>
{
    public static FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate INSTANCE =
        new FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate();

    public override List<RoomDirectorySearchEntryUpdate> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomDirectorySearchEntryUpdate>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomDirectorySearchEntryUpdate.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomDirectorySearchEntryUpdate> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeRoomDirectorySearchEntryUpdate.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomDirectorySearchEntryUpdate> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomDirectorySearchEntryUpdate.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind
    : FfiConverterRustBuffer<List<RoomListEntriesDynamicFilterKind>>
{
    public static FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind INSTANCE =
        new FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind();

    public override List<RoomListEntriesDynamicFilterKind> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomListEntriesDynamicFilterKind>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomListEntriesDynamicFilterKind.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomListEntriesDynamicFilterKind> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeRoomListEntriesDynamicFilterKind.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomListEntriesDynamicFilterKind> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomListEntriesDynamicFilterKind.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomListEntriesUpdate : FfiConverterRustBuffer<List<RoomListEntriesUpdate>>
{
    public static FfiConverterSequenceTypeRoomListEntriesUpdate INSTANCE =
        new FfiConverterSequenceTypeRoomListEntriesUpdate();

    public override List<RoomListEntriesUpdate> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomListEntriesUpdate>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomListEntriesUpdate.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomListEntriesUpdate> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeRoomListEntriesUpdate.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomListEntriesUpdate> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomListEntriesUpdate.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeRoomMessageEventMessageType : FfiConverterRustBuffer<List<RoomMessageEventMessageType>>
{
    public static FfiConverterSequenceTypeRoomMessageEventMessageType INSTANCE =
        new FfiConverterSequenceTypeRoomMessageEventMessageType();

    public override List<RoomMessageEventMessageType> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<RoomMessageEventMessageType>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeRoomMessageEventMessageType.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<RoomMessageEventMessageType> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterTypeRoomMessageEventMessageType.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<RoomMessageEventMessageType> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRoomMessageEventMessageType.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeSlidingSyncVersion : FfiConverterRustBuffer<List<SlidingSyncVersion>>
{
    public static FfiConverterSequenceTypeSlidingSyncVersion INSTANCE =
        new FfiConverterSequenceTypeSlidingSyncVersion();

    public override List<SlidingSyncVersion> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<SlidingSyncVersion>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeSlidingSyncVersion.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<SlidingSyncVersion> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeSlidingSyncVersion.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<SlidingSyncVersion> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeSlidingSyncVersion.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeTraceLogPacks : FfiConverterRustBuffer<List<TraceLogPacks>>
{
    public static FfiConverterSequenceTypeTraceLogPacks INSTANCE = new FfiConverterSequenceTypeTraceLogPacks();

    public override List<TraceLogPacks> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<TraceLogPacks>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeTraceLogPacks.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<TraceLogPacks> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeTraceLogPacks.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<TraceLogPacks> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeTraceLogPacks.INSTANCE.Write(item, stream));
    }
}

class FfiConverterSequenceTypeWidgetEventFilter : FfiConverterRustBuffer<List<WidgetEventFilter>>
{
    public static FfiConverterSequenceTypeWidgetEventFilter INSTANCE = new FfiConverterSequenceTypeWidgetEventFilter();

    public override List<WidgetEventFilter> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<WidgetEventFilter>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeWidgetEventFilter.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<WidgetEventFilter> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeWidgetEventFilter.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<WidgetEventFilter> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeWidgetEventFilter.INSTANCE.Write(item, stream));
    }
}

class FfiConverterDictionaryStringInt32 : FfiConverterRustBuffer<Dictionary<string, int>>
{
    public static FfiConverterDictionaryStringInt32 INSTANCE = new FfiConverterDictionaryStringInt32();

    public override Dictionary<string, int> Read(BigEndianStream stream)
    {
        var result = new Dictionary<string, int>();
        var len = stream.ReadInt();
        for (int i = 0; i < len; i++)
        {
            var key = FfiConverterString.INSTANCE.Read(stream);
            var value = FfiConverterInt32.INSTANCE.Read(stream);
            result[key] = value;
        }
        return result;
    }

    public override int AllocationSize(Dictionary<string, int> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item =>
            {
                return FfiConverterString.INSTANCE.AllocationSize(item.Key)
                    + FfiConverterInt32.INSTANCE.AllocationSize(item.Value);
            })
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, int> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        foreach (var item in value)
        {
            FfiConverterString.INSTANCE.Write(item.Key, stream);
            FfiConverterInt32.INSTANCE.Write(item.Value, stream);
        }
    }
}

class FfiConverterDictionaryStringInt64 : FfiConverterRustBuffer<Dictionary<string, long>>
{
    public static FfiConverterDictionaryStringInt64 INSTANCE = new FfiConverterDictionaryStringInt64();

    public override Dictionary<string, long> Read(BigEndianStream stream)
    {
        var result = new Dictionary<string, long>();
        var len = stream.ReadInt();
        for (int i = 0; i < len; i++)
        {
            var key = FfiConverterString.INSTANCE.Read(stream);
            var value = FfiConverterInt64.INSTANCE.Read(stream);
            result[key] = value;
        }
        return result;
    }

    public override int AllocationSize(Dictionary<string, long> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item =>
            {
                return FfiConverterString.INSTANCE.AllocationSize(item.Key)
                    + FfiConverterInt64.INSTANCE.AllocationSize(item.Value);
            })
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, long> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        foreach (var item in value)
        {
            FfiConverterString.INSTANCE.Write(item.Key, stream);
            FfiConverterInt64.INSTANCE.Write(item.Value, stream);
        }
    }
}

class FfiConverterDictionaryStringString : FfiConverterRustBuffer<Dictionary<string, string>>
{
    public static FfiConverterDictionaryStringString INSTANCE = new FfiConverterDictionaryStringString();

    public override Dictionary<string, string> Read(BigEndianStream stream)
    {
        var result = new Dictionary<string, string>();
        var len = stream.ReadInt();
        for (int i = 0; i < len; i++)
        {
            var key = FfiConverterString.INSTANCE.Read(stream);
            var value = FfiConverterString.INSTANCE.Read(stream);
            result[key] = value;
        }
        return result;
    }

    public override int AllocationSize(Dictionary<string, string> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item =>
            {
                return FfiConverterString.INSTANCE.AllocationSize(item.Key)
                    + FfiConverterString.INSTANCE.AllocationSize(item.Value);
            })
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, string> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        foreach (var item in value)
        {
            FfiConverterString.INSTANCE.Write(item.Key, stream);
            FfiConverterString.INSTANCE.Write(item.Value, stream);
        }
    }
}

class FfiConverterDictionaryStringTypeReceipt : FfiConverterRustBuffer<Dictionary<string, Receipt>>
{
    public static FfiConverterDictionaryStringTypeReceipt INSTANCE = new FfiConverterDictionaryStringTypeReceipt();

    public override Dictionary<string, Receipt> Read(BigEndianStream stream)
    {
        var result = new Dictionary<string, Receipt>();
        var len = stream.ReadInt();
        for (int i = 0; i < len; i++)
        {
            var key = FfiConverterString.INSTANCE.Read(stream);
            var value = FfiConverterTypeReceipt.INSTANCE.Read(stream);
            result[key] = value;
        }
        return result;
    }

    public override int AllocationSize(Dictionary<string, Receipt> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item =>
            {
                return FfiConverterString.INSTANCE.AllocationSize(item.Key)
                    + FfiConverterTypeReceipt.INSTANCE.AllocationSize(item.Value);
            })
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, Receipt> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        foreach (var item in value)
        {
            FfiConverterString.INSTANCE.Write(item.Key, stream);
            FfiConverterTypeReceipt.INSTANCE.Write(item.Value, stream);
        }
    }
}

class FfiConverterDictionaryStringSequenceString : FfiConverterRustBuffer<Dictionary<string, List<string>>>
{
    public static FfiConverterDictionaryStringSequenceString INSTANCE =
        new FfiConverterDictionaryStringSequenceString();

    public override Dictionary<string, List<string>> Read(BigEndianStream stream)
    {
        var result = new Dictionary<string, List<string>>();
        var len = stream.ReadInt();
        for (int i = 0; i < len; i++)
        {
            var key = FfiConverterString.INSTANCE.Read(stream);
            var value = FfiConverterSequenceString.INSTANCE.Read(stream);
            result[key] = value;
        }
        return result;
    }

    public override int AllocationSize(Dictionary<string, List<string>> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item =>
            {
                return FfiConverterString.INSTANCE.AllocationSize(item.Key)
                    + FfiConverterSequenceString.INSTANCE.AllocationSize(item.Value);
            })
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, List<string>> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        foreach (var item in value)
        {
            FfiConverterString.INSTANCE.Write(item.Key, stream);
            FfiConverterSequenceString.INSTANCE.Write(item.Value, stream);
        }
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

internal static class _UniFFIAsync
{
    internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;

    // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

    internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map =
        new ConcurrentHandleMap<TaskCompletionSource<byte>>();
    public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map =
        new ConcurrentHandleMap<CancellationTokenSource>();

    // FFI type for Rust future continuations
    internal class UniffiRustFutureContinuationCallback
    {
        public static UniFfiFutureCallback callback = Callback;

        public static void Callback(IntPtr continuationHandle, byte pollResult)
        {
            if (_async_handle_map.Remove((ulong)continuationHandle.ToInt64(), out TaskCompletionSource<byte> task))
            {
                task.SetResult(pollResult);
            }
            else
            {
                throw new InternalException($"Unable to find continuation handle: {continuationHandle}");
            }
        }
    }

    public class UniffiForeignFutureFreeCallback
    {
        public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

        public static void Callback(ulong handle)
        {
            if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
            {
                task.Cancel();
            }
            else
            {
                throw new InternalException($"Unable to find cancellation token: {handle}");
            }
        }
    }

    public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

    public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

    private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
    {
        byte pollResult;
        do
        {
            var tcs = new TaskCompletionSource<byte>(TaskCreationOptions.RunContinuationsAsynchronously);
            IntPtr callback = Marshal.GetFunctionPointerForDelegate(UniffiRustFutureContinuationCallback.callback);
            ulong mapEntry = _async_handle_map.Insert(tcs);
            pollFunc(rustFuture, callback, (IntPtr)mapEntry);
            pollResult = await tcs.Task;
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
    }

    public static async Task<T> UniffiRustCallAsync<T, F, E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteFuncDelegate<F> completeFunc,
        Action<IntPtr> freeFunc,
        Func<F, T> liftFunc,
        CallStatusErrorHandler<E> errorHandler
    )
        where E : UniffiException
    {
        try
        {
            await PollFuture(rustFuture, pollFunc);
            var result = _UniffiHelpers.RustCallWithError(
                errorHandler,
                (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status)
            );
            return liftFunc(result);
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }

    public static async Task UniffiRustCallAsync<E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteActionDelegate completeFunc,
        Action<IntPtr> freeFunc,
        CallStatusErrorHandler<E> errorHandler
    )
        where E : UniffiException
    {
        try
        {
            await PollFuture(rustFuture, pollFunc);
            _UniffiHelpers.RustCallWithError(
                errorHandler,
                (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status)
            );
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }
}
#pragma warning restore 8625
internal static class MatrixSdkFfiMethods
{
    /// <summary>
    /// Creates a [`RoomMessageEventContentWithoutRelation`] given a
    /// [`MessageContent`] value.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public static RoomMessageEventContentWithoutRelation ContentWithoutRelationFromMessage(MessageContent @message)
    {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
                        FfiConverterTypeMessageContent.INSTANCE.Lower(@message),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Create a caption edit.
    ///
    /// If no `formatted_caption` is provided, then it's assumed the `caption`
    /// represents valid Markdown that can be used as the formatted caption.
    /// </summary>
    public static EditedContent CreateCaptionEdit(
        string? @caption,
        FormattedBody? @formattedCaption,
        Mentions? @mentions
    )
    {
        return FfiConverterTypeEditedContent.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
                        FfiConverterOptionalString.INSTANCE.Lower(@caption),
                        FfiConverterOptionalTypeFormattedBody.INSTANCE.Lower(@formattedCaption),
                        FfiConverterOptionalTypeMentions.INSTANCE.Lower(@mentions),
                        ref _status
                    )
            )
        );
    }

    public static string GenTransactionId()
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(ref _status)
            )
        );
    }

    /// <summary>
    /// Create the actual url that can be used to setup the WebView or IFrame
    /// that contains the widget.
    ///
    /// # Arguments
    /// * `widget_settings` - The widget settings to generate the url for.
    /// * `room` - A matrix room which is used to query the logged in username
    /// * `props` - Properties from the client that can be used by a widget to adapt
    /// to the client. e.g. language, font-scale...
    /// </summary>
    /// <exception cref="ParseException"></exception>
    public static async Task<string> GenerateWebviewUrl(
        WidgetSettings @widgetSettings,
        Room @room,
        ClientProperties @props
    )
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(
                FfiConverterTypeWidgetSettings.INSTANCE.Lower(@widgetSettings),
                FfiConverterTypeRoom.INSTANCE.Lower(@room),
                FfiConverterTypeClientProperties.INSTANCE.Lower(@props)
            ),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterString.INSTANCE.Lift(result),
            // Error
            FfiConverterTypeParseError.INSTANCE
        );
    }

    /// <summary>
    /// The Capabilities required to run a element call widget.
    ///
    /// This is intended to be used in combination with: `acquire_capabilities` of
    /// the `CapabilitiesProvider`.
    ///
    /// `acquire_capabilities` can simply return the `WidgetCapabilities` from this
    /// function. Even if there are non intersecting permissions to what the widget
    /// requested.
    ///
    /// Editing and extending the capabilities from this function is also possible,
    /// but should only be done as temporal workarounds until this function is
    /// adjusted
    /// </summary>
    public static WidgetCapabilities GetElementCallRequiredPermissions(string @ownUserId, string @ownDeviceId)
    {
        return FfiConverterTypeWidgetCapabilities.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
                        FfiConverterString.INSTANCE.Lower(@ownUserId),
                        FfiConverterString.INSTANCE.Lower(@ownDeviceId),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Sets up logs and the tokio runtime for the current application.
    ///
    /// If `use_lightweight_tokio_runtime` is set to true, this will set up a
    /// lightweight tokio runtime, for processes that have memory limitations (like
    /// the NSE process on iOS). Otherwise, this can remain false, in which case a
    /// multithreaded tokio runtime will be set up.
    /// </summary>
    public static void InitPlatform(TracingConfiguration @config, bool @useLightweightTokioRuntime)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus _status) =>
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_init_platform(
                    FfiConverterTypeTracingConfiguration.INSTANCE.Lower(@config),
                    FfiConverterBoolean.INSTANCE.Lower(@useLightweightTokioRuntime),
                    ref _status
                )
        );
    }

    /// <summary>
    /// Verifies the passed `String` matches the expected room alias format:
    ///
    /// This means it's lowercase, with no whitespace chars, has a single leading
    /// `#` char and a single `:` separator between the local and domain parts, and
    /// the local part only contains characters that can't be percent encoded.
    /// </summary>
    public static bool IsRoomAliasFormatValid(string @alias)
    {
        return FfiConverterBoolean.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
                        FfiConverterString.INSTANCE.Lower(@alias),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Log an event.
    ///
    /// The target should be something like a module path, and can be referenced in
    /// the filter string given to `setup_tracing`. `level` and `target` for a
    /// callsite are fixed at the first `log_event` call for that callsite and can
    /// not be changed afterwards, i.e. the level and target passed for second and
    /// following `log_event`s with the same callsite will be ignored.
    ///
    /// This function leaks a little bit of memory for each unique (file + line +
    /// level + target) it is called with. Please make sure that the number of
    /// different combinations of those parameters this can be called with is
    /// constant in the final executable.
    /// </summary>
    public static void LogEvent(string @file, uint? @line, LogLevel @level, string @target, string @message)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus _status) =>
                _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_log_event(
                    FfiConverterString.INSTANCE.Lower(@file),
                    FfiConverterOptionalUInt32.INSTANCE.Lower(@line),
                    FfiConverterTypeLogLevel.INSTANCE.Lower(@level),
                    FfiConverterString.INSTANCE.Lower(@target),
                    FfiConverterString.INSTANCE.Lower(@message),
                    ref _status
                )
        );
    }

    /// <summary>
    /// Helper function to parse a string into a ElementWellKnown struct
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public static ElementWellKnown MakeElementWellKnown(string @string)
    {
        return FfiConverterTypeElementWellKnown.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_make_element_well_known(
                        FfiConverterString.INSTANCE.Lower(@string),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="ParseException"></exception>
    public static WidgetDriverAndHandle MakeWidgetDriver(WidgetSettings @settings)
    {
        return FfiConverterTypeWidgetDriverAndHandle.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeParseError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
                        FfiConverterTypeWidgetSettings.INSTANCE.Lower(@settings),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Generates a `matrix.to` permalink to the given room alias.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public static string MatrixToRoomAliasPermalink(string @roomAlias)
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
                        FfiConverterString.INSTANCE.Lower(@roomAlias),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Generates a `matrix.to` permalink to the given userID.
    /// </summary>
    /// <exception cref="ClientException"></exception>
    public static string MatrixToUserPermalink(string @userId)
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
                        FfiConverterString.INSTANCE.Lower(@userId),
                        ref _status
                    )
            )
        );
    }

    public static RoomMessageEventContentWithoutRelation MessageEventContentFromHtml(string @body, string @htmlBody)
    {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
                        FfiConverterString.INSTANCE.Lower(@body),
                        FfiConverterString.INSTANCE.Lower(@htmlBody),
                        ref _status
                    )
            )
        );
    }

    public static RoomMessageEventContentWithoutRelation MessageEventContentFromHtmlAsEmote(
        string @body,
        string @htmlBody
    )
    {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
                        FfiConverterString.INSTANCE.Lower(@body),
                        FfiConverterString.INSTANCE.Lower(@htmlBody),
                        ref _status
                    )
            )
        );
    }

    public static RoomMessageEventContentWithoutRelation MessageEventContentFromMarkdown(string @md)
    {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
                        FfiConverterString.INSTANCE.Lower(@md),
                        ref _status
                    )
            )
        );
    }

    public static RoomMessageEventContentWithoutRelation MessageEventContentFromMarkdownAsEmote(string @md)
    {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
                        FfiConverterString.INSTANCE.Lower(@md),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="ClientException"></exception>
    public static RoomMessageEventContentWithoutRelation MessageEventContentNew(MessageType @msgtype)
    {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeClientError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
                        FfiConverterTypeMessageType.INSTANCE.Lower(@msgtype),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// `WidgetSettings` are usually created from a state event.
    /// (currently unimplemented)
    ///
    /// In some cases the client wants to create custom `WidgetSettings`
    /// for specific rooms based on other conditions.
    /// This function returns a `WidgetSettings` object which can be used
    /// to setup a widget using `run_client_widget_api`
    /// and to generate the correct url for the widget.
    ///
    /// # Arguments
    ///
    /// * `props` - A struct containing the configuration parameters for a element
    /// call widget.
    /// </summary>
    /// <exception cref="ParseException"></exception>
    public static WidgetSettings NewVirtualElementCallWidget(VirtualElementCallWidgetOptions @props)
    {
        return FfiConverterTypeWidgetSettings.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeParseError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
                        FfiConverterTypeVirtualElementCallWidgetOptions.INSTANCE.Lower(@props),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Parse a matrix entity from a given URI, be it either
    /// a `matrix.to` link or a `matrix:` URI
    /// </summary>
    public static MatrixEntity? ParseMatrixEntityFrom(string @uri)
    {
        return FfiConverterOptionalTypeMatrixEntity.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
                        FfiConverterString.INSTANCE.Lower(@uri),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Transforms a Room's display name into a valid room alias name.
    /// </summary>
    public static string RoomAliasNameFromRoomDisplayName(string @roomName)
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
                        FfiConverterString.INSTANCE.Lower(@roomName),
                        ref _status
                    )
            )
        );
    }

    public static string SdkGitSha()
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) => _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(ref _status)
            )
        );
    }

    public static long SuggestedPowerLevelForRole(RoomMemberRole @role)
    {
        return FfiConverterInt64.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
                        FfiConverterTypeRoomMemberRole.INSTANCE.Lower(@role),
                        ref _status
                    )
            )
        );
    }

    public static RoomMemberRole SuggestedRoleForPowerLevel(long @powerLevel)
    {
        return FfiConverterTypeRoomMemberRole.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
                        FfiConverterInt64.INSTANCE.Lower(@powerLevel),
                        ref _status
                    )
            )
        );
    }
}
