// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.0+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

namespace uniffi.matrix_sdk_crypto;

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer
{
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size)
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                var buffer = _UniFFILib.ffi_matrix_sdk_crypto_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
                if (buffer.data == IntPtr.Zero)
                {
                    throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
                }
                return buffer;
            }
        );
    }

    public static void Free(RustBuffer buffer)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_matrix_sdk_crypto_rustbuffer_free(buffer, ref status);
            }
        );
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len)));
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes
{
    public int length;
    public IntPtr data;
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType>
{
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value)
    {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try
        {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        }
        catch
        {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf)
    {
        var stream = rbuf.AsStream();
        try
        {
            var item = Read(stream);
            if (stream.HasRemaining())
            {
                throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
            }
            return item;
        }
        finally
        {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType> : FfiConverter<CsType, RustBuffer>
{
    public override CsType Lift(RustBuffer value)
    {
        return LiftFromRustBuffer(value);
    }

    public override RustBuffer Lower(CsType value)
    {
        return LowerIntoRustBuffer(value);
    }
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus
{
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess()
    {
        return code == 0;
    }

    public bool IsError()
    {
        return code == 1;
    }

    public bool IsPanic()
    {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException : System.Exception
{
    public UniffiException()
        : base() { }

    public UniffiException(string message)
        : base(message) { }
}

internal class UndeclaredErrorException : UniffiException
{
    public UndeclaredErrorException(string message)
        : base(message) { }
}

internal class PanicException : UniffiException
{
    public PanicException(string message)
        : base(message) { }
}

internal class AllocationException : UniffiException
{
    public AllocationException(string message)
        : base(message) { }
}

internal class InternalException : UniffiException
{
    public InternalException(string message)
        : base(message) { }
}

internal class InvalidEnumException : InternalException
{
    public InvalidEnumException(string message)
        : base(message) { }
}

internal class UniffiContractVersionException : UniffiException
{
    public UniffiContractVersionException(string message)
        : base(message) { }
}

internal class UniffiContractChecksumException : UniffiException
{
    public UniffiContractChecksumException(string message)
        : base(message) { }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E>
    where E : System.Exception
{
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
{
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf)
    {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers
{
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E : UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess())
        {
            return return_value;
        }
        else if (status.IsError())
        {
            throw errorHandler.Lift(status.error_buf);
        }
        else if (status.IsPanic())
        {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0)
            {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            }
            else
            {
                throw new PanicException("Rust panic");
            }
        }
        else
        {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E : UniffiException
    {
        _UniffiHelpers.RustCallWithError(
            errorHandler,
            (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback)
    {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }
}

static class FFIObjectUtil
{
    public static void DisposeAll(params Object?[] list)
    {
        foreach (var obj in list)
        {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj)
    {
        if (obj == null)
        {
            return;
        }

        if (obj is IDisposable disposable)
        {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null)
        {
            if (type.IsGenericType)
            {
                if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))
                {
                    foreach (var value in obj)
                    {
                        Dispose(value);
                    }
                }
                else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>)))
                {
                    foreach (var value in obj.Values)
                    {
                        Dispose(value);
                    }
                }
            }
        }
    }
}

// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException : System.Exception
{
    public StreamUnderflowException() { }
}

class BigEndianStream
{
    Stream stream;

    public BigEndianStream(Stream stream)
    {
        this.stream = stream;
    }

    public bool HasRemaining()
    {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position
    {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value)
    {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value)
    {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value)
    {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value)
    {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value)
    {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value)
    {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value)
    {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value)
    {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value)
    {
        unsafe
        {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value)
    {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value)
    {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length)
    {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte()
    {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort()
    {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt()
    {
        CheckRemaining(4);
        return (uint)(stream.ReadByte() << 24 | stream.ReadByte() << 16 | stream.ReadByte() << 8 | stream.ReadByte());
    }

    public ulong ReadULong()
    {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte()
    {
        return (sbyte)ReadByte();
    }

    public short ReadShort()
    {
        return (short)ReadUShort();
    }

    public int ReadInt()
    {
        return (int)ReadUInt();
    }

    public float ReadFloat()
    {
        unsafe
        {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong()
    {
        return (long)ReadULong();
    }

    public double ReadDouble()
    {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length)
    {
        if (stream.Length - stream.Position < length)
        {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.

// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(ulong @data, sbyte @pollResult);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(ulong @handle);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(ulong @handle);

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU8 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI8 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU16 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI16 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructF32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructF64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructPointer @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructVoid @result
    );

    static _UniFFILib()
    {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
    }

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_crypto_rustbuffer_alloc(
        ulong @size,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_crypto_rustbuffer_from_bytes(
        ForeignBytes @bytes,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rustbuffer_free(
        RustBuffer @buf,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_crypto_rustbuffer_reserve(
        RustBuffer @buf,
        ulong @additional,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_u8(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_u8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_u8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_matrix_sdk_crypto_rust_future_complete_u8(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_i8(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_i8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_i8(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_matrix_sdk_crypto_rust_future_complete_i8(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_u16(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_u16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_u16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_matrix_sdk_crypto_rust_future_complete_u16(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_i16(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_i16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_i16(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_matrix_sdk_crypto_rust_future_complete_i16(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_u32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_u32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_u32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_matrix_sdk_crypto_rust_future_complete_u32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_i32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_i32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_i32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_matrix_sdk_crypto_rust_future_complete_i32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_u64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_u64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_u64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_matrix_sdk_crypto_rust_future_complete_u64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_i64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_i64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_i64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_matrix_sdk_crypto_rust_future_complete_i64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_f32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_f32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_f32(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_matrix_sdk_crypto_rust_future_complete_f32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_f64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_f64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_f64(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_matrix_sdk_crypto_rust_future_complete_f64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_pointer(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_pointer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_pointer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_matrix_sdk_crypto_rust_future_complete_pointer(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_rust_buffer(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_rust_buffer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_rust_buffer(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_matrix_sdk_crypto_rust_future_complete_rust_buffer(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_poll_void(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_cancel_void(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_free_void(IntPtr @handle);

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_matrix_sdk_crypto_rust_future_complete_void(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("matrix_sdk_ffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_matrix_sdk_crypto_uniffi_contract_version();

    static void uniffiCheckContractApiVersion()
    {
        var scaffolding_contract_version = _UniFFILib.ffi_matrix_sdk_crypto_uniffi_contract_version();
        if (26 != scaffolding_contract_version)
        {
            throw new UniffiContractVersionException(
                $"uniffi.matrix_sdk_crypto: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`"
            );
        }
    }

    static void uniffiCheckApiChecksums() { }
}

// Public interface members begin here.

#pragma warning disable 8625

class FfiConverterString : FfiConverter<string, RustBuffer>
{
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value)
    {
        try
        {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        }
        finally
        {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value)
    {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}

/// <summary>
/// Settings for decrypting messages
/// </summary>
/// <param name="sender_device_trust_requirement">
/// The trust level in the sender's device that is required to decrypt the
/// event. If the sender's device is not sufficiently trusted,
/// [`MegolmError::SenderIdentityNotTrusted`] will be returned.
/// </param>
internal record DecryptionSettings(
    /// <summary>
    /// The trust level in the sender's device that is required to decrypt the
    /// event. If the sender's device is not sufficiently trusted,
    /// [`MegolmError::SenderIdentityNotTrusted`] will be returned.
    /// </summary>
    TrustRequirement @senderDeviceTrustRequirement
) { }

class FfiConverterTypeDecryptionSettings : FfiConverterRustBuffer<DecryptionSettings>
{
    public static FfiConverterTypeDecryptionSettings INSTANCE = new FfiConverterTypeDecryptionSettings();

    public override DecryptionSettings Read(BigEndianStream stream)
    {
        return new DecryptionSettings(
            @senderDeviceTrustRequirement: FfiConverterTypeTrustRequirement.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(DecryptionSettings value)
    {
        return 0 + FfiConverterTypeTrustRequirement.INSTANCE.AllocationSize(value.@senderDeviceTrustRequirement);
    }

    public override void Write(DecryptionSettings value, BigEndianStream stream)
    {
        FfiConverterTypeTrustRequirement.INSTANCE.Write(value.@senderDeviceTrustRequirement, stream);
    }
}

/// <summary>
/// Strategy to collect the devices that should receive room keys for the
/// current discussion.
/// </summary>
internal enum CollectStrategy : int
{
    /// <summary>
    /// Share with all (unblacklisted) devices.
    /// </summary>
    AllDevices,

    /// <summary>
    /// Share with all devices, except errors for *verified* users cause sharing
    /// to fail with an error.
    ///
    /// In this strategy, if a verified user has an unsigned device,
    /// key sharing will fail with a
    /// [`SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`].
    /// If a verified user has replaced their identity, key
    /// sharing will fail with a
    /// [`SessionRecipientCollectionError::VerifiedUserChangedIdentity`].
    ///
    /// Otherwise, keys are shared with unsigned devices as normal.
    ///
    /// Once the problematic devices are blacklisted or whitelisted the
    /// caller can retry to share a second time.
    /// </summary>
    ErrorOnVerifiedUserProblem,

    /// <summary>
    /// Share based on identity. Only distribute to devices signed by their
    /// owner. If a user has no published identity he will not receive
    /// any room keys.
    /// </summary>
    IdentityBasedStrategy,

    /// <summary>
    /// Only share keys with devices that we "trust". A device is trusted if any
    /// of the following is true:
    /// - It was manually marked as trusted.
    /// - It was marked as verified via interactive verification.
    /// - It is signed by its owner identity, and this identity has been
    /// trusted via interactive verification.
    /// - It is the current own device of the user.
    /// </summary>
    OnlyTrustedDevices,
}

class FfiConverterTypeCollectStrategy : FfiConverterRustBuffer<CollectStrategy>
{
    public static FfiConverterTypeCollectStrategy INSTANCE = new FfiConverterTypeCollectStrategy();

    public override CollectStrategy Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(CollectStrategy), value))
        {
            return (CollectStrategy)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeCollectStrategy.Read()", value)
            );
        }
    }

    public override int AllocationSize(CollectStrategy value)
    {
        return 4;
    }

    public override void Write(CollectStrategy value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// The state of an identity - verified, pinned etc.
/// </summary>
internal enum IdentityState : int
{
    /// <summary>
    /// The user is verified with us
    /// </summary>
    Verified,

    /// <summary>
    /// Either this is the first identity we have seen for this user, or the
    /// user has acknowledged a change of identity explicitly e.g. by
    /// clicking OK on a notification.
    /// </summary>
    Pinned,

    /// <summary>
    /// The user's identity has changed since it was pinned. The user should be
    /// notified about this and given the opportunity to acknowledge the
    /// change, which will make the new identity pinned.
    /// When the user acknowledges the change, the app should call
    /// [`crate::OtherUserIdentity::pin_current_master_key`].
    /// </summary>
    PinViolation,

    /// <summary>
    /// The user's identity has changed, and before that it was verified. This
    /// is a serious problem. The user can either verify again to make this
    /// identity verified, or withdraw verification
    /// [`UserIdentity::withdraw_verification`] to make it pinned.
    /// </summary>
    VerificationViolation,
}

class FfiConverterTypeIdentityState : FfiConverterRustBuffer<IdentityState>
{
    public static FfiConverterTypeIdentityState INSTANCE = new FfiConverterTypeIdentityState();

    public override IdentityState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(IdentityState), value))
        {
            return (IdentityState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityState.Read()", value)
            );
        }
    }

    public override int AllocationSize(IdentityState value)
    {
        return 4;
    }

    public override void Write(IdentityState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// The local trust state of a device.
/// </summary>
internal enum LocalTrust : int
{
    /// <summary>
    /// The device has been verified and is trusted.
    /// </summary>
    Verified,

    /// <summary>
    /// The device been blacklisted from communicating.
    /// </summary>
    BlackListed,

    /// <summary>
    /// The trust state of the device is being ignored.
    /// </summary>
    Ignored,

    /// <summary>
    /// The trust state is unset.
    /// </summary>
    Unset,
}

class FfiConverterTypeLocalTrust : FfiConverterRustBuffer<LocalTrust>
{
    public static FfiConverterTypeLocalTrust INSTANCE = new FfiConverterTypeLocalTrust();

    public override LocalTrust Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(LocalTrust), value))
        {
            return (LocalTrust)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeLocalTrust.Read()", value)
            );
        }
    }

    public override int AllocationSize(LocalTrust value)
    {
        return 4;
    }

    public override void Write(LocalTrust value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// Error type for the decoding of the [`QrCodeData`].
/// </summary>
internal class LoginQrCodeDecodeException : UniffiException
{
    LoginQrCodeDecodeException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    /// <summary>
    /// The QR code data is no long enough, it's missing some fields.
    /// </summary>
    public class NotEnoughData : LoginQrCodeDecodeException
    {
        public NotEnoughData(string message)
            : base(message) { }
    }

    /// <summary>
    /// One of the URLs in the QR code data is not a valid UTF-8 encoded string.
    /// </summary>
    public class NotUtf8 : LoginQrCodeDecodeException
    {
        public NotUtf8(string message)
            : base(message) { }
    }

    /// <summary>
    /// One of the URLs in the QR code data could not be parsed.
    /// </summary>
    public class UrlParse : LoginQrCodeDecodeException
    {
        public UrlParse(string message)
            : base(message) { }
    }

    /// <summary>
    /// The QR code data contains an invalid mode, we expect the login (0x03)
    /// mode or the reciprocate mode (0x04).
    /// </summary>
    public class InvalidMode : LoginQrCodeDecodeException
    {
        public InvalidMode(string message)
            : base(message) { }
    }

    /// <summary>
    /// The QR code data contains an unsupported version.
    /// </summary>
    public class InvalidVersion : LoginQrCodeDecodeException
    {
        public InvalidVersion(string message)
            : base(message) { }
    }

    /// <summary>
    /// The base64 encoded variant of the QR code data is not a valid base64
    /// string.
    /// </summary>
    public class Base64 : LoginQrCodeDecodeException
    {
        public Base64(string message)
            : base(message) { }
    }

    /// <summary>
    /// The QR code data doesn't contain the expected `MATRIX` prefix.
    /// </summary>
    public class InvalidPrefix : LoginQrCodeDecodeException
    {
        public InvalidPrefix(string message)
            : base(message) { }
    }
}

class FfiConverterTypeLoginQrCodeDecodeError
    : FfiConverterRustBuffer<LoginQrCodeDecodeException>,
        CallStatusErrorHandler<LoginQrCodeDecodeException>
{
    public static FfiConverterTypeLoginQrCodeDecodeError INSTANCE = new FfiConverterTypeLoginQrCodeDecodeError();

    public override LoginQrCodeDecodeException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new LoginQrCodeDecodeException.NotEnoughData(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new LoginQrCodeDecodeException.NotUtf8(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new LoginQrCodeDecodeException.UrlParse(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new LoginQrCodeDecodeException.InvalidMode(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new LoginQrCodeDecodeException.InvalidVersion(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new LoginQrCodeDecodeException.Base64(FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new LoginQrCodeDecodeException.InvalidPrefix(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeLoginQrCodeDecodeError.Read()", value)
                );
        }
    }

    public override int AllocationSize(LoginQrCodeDecodeException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(LoginQrCodeDecodeException value, BigEndianStream stream)
    {
        switch (value)
        {
            case LoginQrCodeDecodeException.NotEnoughData:
                stream.WriteInt(1);
                break;
            case LoginQrCodeDecodeException.NotUtf8:
                stream.WriteInt(2);
                break;
            case LoginQrCodeDecodeException.UrlParse:
                stream.WriteInt(3);
                break;
            case LoginQrCodeDecodeException.InvalidMode:
                stream.WriteInt(4);
                break;
            case LoginQrCodeDecodeException.InvalidVersion:
                stream.WriteInt(5);
                break;
            case LoginQrCodeDecodeException.Base64:
                stream.WriteInt(6);
                break;
            case LoginQrCodeDecodeException.InvalidPrefix:
                stream.WriteInt(7);
                break;
            default:
                throw new InternalException(
                    String.Format("invalid error value '{0}' in FfiConverterTypeLoginQrCodeDecodeError.Write()", value)
                );
        }
    }
}

/// <summary>
/// The result of a signature check.
/// </summary>
internal enum SignatureState : int
{
    /// <summary>
    /// The signature is missing.
    /// </summary>
    Missing,

    /// <summary>
    /// The signature is invalid.
    /// </summary>
    Invalid,

    /// <summary>
    /// The signature is valid but the device or user identity that created the
    /// signature is not trusted.
    /// </summary>
    ValidButNotTrusted,

    /// <summary>
    /// The signature is valid and the device or user identity that created the
    /// signature is trusted.
    /// </summary>
    ValidAndTrusted,
}

class FfiConverterTypeSignatureState : FfiConverterRustBuffer<SignatureState>
{
    public static FfiConverterTypeSignatureState INSTANCE = new FfiConverterTypeSignatureState();

    public override SignatureState Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SignatureState), value))
        {
            return (SignatureState)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeSignatureState.Read()", value)
            );
        }
    }

    public override int AllocationSize(SignatureState value)
    {
        return 4;
    }

    public override void Write(SignatureState value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// The trust level in the sender's device that is required to decrypt an
/// event.
/// </summary>
internal enum TrustRequirement : int
{
    /// <summary>
    /// Decrypt events from everyone regardless of trust.
    /// </summary>
    Untrusted,

    /// <summary>
    /// Only decrypt events from cross-signed devices or legacy sessions (Megolm
    /// sessions created before we started collecting trust information).
    /// </summary>
    CrossSignedOrLegacy,

    /// <summary>
    /// Only decrypt events from cross-signed devices.
    /// </summary>
    CrossSigned,
}

class FfiConverterTypeTrustRequirement : FfiConverterRustBuffer<TrustRequirement>
{
    public static FfiConverterTypeTrustRequirement INSTANCE = new FfiConverterTypeTrustRequirement();

    public override TrustRequirement Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(TrustRequirement), value))
        {
            return (TrustRequirement)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeTrustRequirement.Read()", value)
            );
        }
    }

    public override int AllocationSize(TrustRequirement value)
    {
        return 4;
    }

    public override void Write(TrustRequirement value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

/// <summary>
/// Our best guess at the reason why an event can't be decrypted.
/// </summary>
internal enum UtdCause : int
{
    /// <summary>
    /// We don't have an explanation for why this UTD happened - it is probably
    /// a bug, or a network split between the two homeservers.
    ///
    /// For example:
    ///
    /// - the keys for this event are missing, but a key storage backup exists
    /// and is working, so we should be able to find the keys in the backup.
    ///
    /// - the keys for this event are missing, and a key storage backup exists
    /// on the server, but that backup is not working on this client even
    /// though this device is verified.
    /// </summary>
    Unknown,

    /// <summary>
    /// We are missing the keys for this event, and the event was sent when we
    /// were not a member of the room (or invited).
    /// </summary>
    SentBeforeWeJoined,

    /// <summary>
    /// The message was sent by a user identity we have not verified, but the
    /// user was previously verified.
    /// </summary>
    VerificationViolation,

    /// <summary>
    /// The [`crate::TrustRequirement`] requires that the sending device be
    /// signed by its owner, and it was not.
    /// </summary>
    UnsignedDevice,

    /// <summary>
    /// The [`crate::TrustRequirement`] requires that the sending device be
    /// signed by its owner, and we were unable to securely find the device.
    ///
    /// This could be because the device has since been deleted, because we
    /// haven't yet downloaded it from the server, or because the session
    /// data was obtained from an insecure source (imported from a file,
    /// obtained from a legacy (asymmetric) backup, unsafe key forward, etc.)
    /// </summary>
    UnknownDevice,

    /// <summary>
    /// We are missing the keys for this event, but it is a "device-historical"
    /// message and there is no key storage backup on the server, presumably
    /// because the user has turned it off.
    ///
    /// Device-historical means that the message was sent before the current
    /// device existed (but the current user was probably a member of the room
    /// at the time the message was sent). Not to
    /// be confused with pre-join or pre-invite messages (see
    /// [`UtdCause::SentBeforeWeJoined`] for that).
    ///
    /// Expected message to user: "History is not available on this device".
    /// </summary>
    HistoricalMessageAndBackupIsDisabled,

    /// <summary>
    /// The keys for this event are intentionally withheld.
    ///
    /// The sender has refused to share the key because our device does not meet
    /// the sender's security requirements.
    /// </summary>
    WithheldForUnverifiedOrInsecureDevice,

    /// <summary>
    /// The keys for this event are missing, likely because the sender was
    /// unable to share them (e.g., failure to establish an Olm 1:1
    /// channel). Alternatively, the sender may have deliberately excluded
    /// this device by cherry-picking and blocking it, in which case, no action
    /// can be taken on our side.
    /// </summary>
    WithheldBySender,

    /// <summary>
    /// We are missing the keys for this event, but it is a "device-historical"
    /// message, and even though a key storage backup does exist, we can't use
    /// it because our device is unverified.
    ///
    /// Device-historical means that the message was sent before the current
    /// device existed (but the current user was probably a member of the room
    /// at the time the message was sent). Not to
    /// be confused with pre-join or pre-invite messages (see
    /// [`UtdCause::SentBeforeWeJoined`] for that).
    ///
    /// Expected message to user: "You need to verify this device".
    /// </summary>
    HistoricalMessageAndDeviceIsUnverified,
}

class FfiConverterTypeUtdCause : FfiConverterRustBuffer<UtdCause>
{
    public static FfiConverterTypeUtdCause INSTANCE = new FfiConverterTypeUtdCause();

    public override UtdCause Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(UtdCause), value))
        {
            return (UtdCause)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeUtdCause.Read()", value)
            );
        }
    }

    public override int AllocationSize(UtdCause value)
    {
        return 4;
    }

    public override void Write(UtdCause value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

#pragma warning restore 8625
internal static class MatrixSdkCryptoMethods { }
